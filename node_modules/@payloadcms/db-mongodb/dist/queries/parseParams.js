/* eslint-disable no-restricted-syntax */ /* eslint-disable no-await-in-loop */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "parseParams", {
    enumerable: true,
    get: function() {
        return parseParams;
    }
});
const _deepmerge = /*#__PURE__*/ _interop_require_default(require("deepmerge"));
const _types = require("payload/types");
const _utilities = require("payload/utilities");
const _buildAndOrConditions = require("./buildAndOrConditions");
const _buildSearchParams = require("./buildSearchParams");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function parseParams({ collectionSlug, fields, globalSlug, locale, payload, where }) {
    let result = {};
    if (typeof where === 'object') {
        // We need to determine if the whereKey is an AND, OR, or a schema path
        for (const relationOrPath of Object.keys(where)){
            const condition = where[relationOrPath];
            let conditionOperator;
            if (relationOrPath.toLowerCase() === 'and') {
                conditionOperator = '$and';
            } else if (relationOrPath.toLowerCase() === 'or') {
                conditionOperator = '$or';
            }
            if (Array.isArray(condition)) {
                const builtConditions = await (0, _buildAndOrConditions.buildAndOrConditions)({
                    collectionSlug,
                    fields,
                    globalSlug,
                    locale,
                    payload,
                    where: condition
                });
                if (builtConditions.length > 0) result[conditionOperator] = builtConditions;
            } else {
                // It's a path - and there can be multiple comparisons on a single path.
                // For example - title like 'test' and title not equal to 'tester'
                // So we need to loop on keys again here to handle each operator independently
                const pathOperators = where[relationOrPath];
                if (typeof pathOperators === 'object') {
                    for (const operator of Object.keys(pathOperators)){
                        if (_types.validOperators.includes(operator)) {
                            const searchParam = await (0, _buildSearchParams.buildSearchParam)({
                                collectionSlug,
                                fields,
                                globalSlug,
                                incomingPath: relationOrPath,
                                locale,
                                operator,
                                payload,
                                val: pathOperators[operator]
                            });
                            if (searchParam?.value && searchParam?.path) {
                                result = {
                                    ...result,
                                    [searchParam.path]: searchParam.value
                                };
                            } else if (typeof searchParam?.value === 'object') {
                                result = (0, _deepmerge.default)(result, searchParam.value, {
                                    arrayMerge: _utilities.combineMerge
                                });
                            }
                        }
                    }
                }
            }
        }
    }
    return result;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9xdWVyaWVzL3BhcnNlUGFyYW1zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1hd2FpdC1pbi1sb29wICovXG5pbXBvcnQgdHlwZSB7IEZpbHRlclF1ZXJ5IH0gZnJvbSAnbW9uZ29vc2UnXG5pbXBvcnQgdHlwZSB7IFBheWxvYWQgfSBmcm9tICdwYXlsb2FkJ1xuaW1wb3J0IHR5cGUgeyBPcGVyYXRvciwgV2hlcmUgfSBmcm9tICdwYXlsb2FkL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBGaWVsZCB9IGZyb20gJ3BheWxvYWQvdHlwZXMnXG5cbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJ1xuaW1wb3J0IHsgdmFsaWRPcGVyYXRvcnMgfSBmcm9tICdwYXlsb2FkL3R5cGVzJ1xuaW1wb3J0IHsgY29tYmluZU1lcmdlIH0gZnJvbSAncGF5bG9hZC91dGlsaXRpZXMnXG5cbmltcG9ydCB7IGJ1aWxkQW5kT3JDb25kaXRpb25zIH0gZnJvbSAnLi9idWlsZEFuZE9yQ29uZGl0aW9ucydcbmltcG9ydCB7IGJ1aWxkU2VhcmNoUGFyYW0gfSBmcm9tICcuL2J1aWxkU2VhcmNoUGFyYW1zJ1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcGFyc2VQYXJhbXMoe1xuICBjb2xsZWN0aW9uU2x1ZyxcbiAgZmllbGRzLFxuICBnbG9iYWxTbHVnLFxuICBsb2NhbGUsXG4gIHBheWxvYWQsXG4gIHdoZXJlLFxufToge1xuICBjb2xsZWN0aW9uU2x1Zz86IHN0cmluZ1xuICBmaWVsZHM6IEZpZWxkW11cbiAgZ2xvYmFsU2x1Zz86IHN0cmluZ1xuICBsb2NhbGU6IHN0cmluZ1xuICBwYXlsb2FkOiBQYXlsb2FkXG4gIHdoZXJlOiBXaGVyZVxufSk6IFByb21pc2U8UmVjb3JkPHN0cmluZywgdW5rbm93bj4+IHtcbiAgbGV0IHJlc3VsdCA9IHt9IGFzIEZpbHRlclF1ZXJ5PGFueT5cblxuICBpZiAodHlwZW9mIHdoZXJlID09PSAnb2JqZWN0Jykge1xuICAgIC8vIFdlIG5lZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSB3aGVyZUtleSBpcyBhbiBBTkQsIE9SLCBvciBhIHNjaGVtYSBwYXRoXG4gICAgZm9yIChjb25zdCByZWxhdGlvbk9yUGF0aCBvZiBPYmplY3Qua2V5cyh3aGVyZSkpIHtcbiAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHdoZXJlW3JlbGF0aW9uT3JQYXRoXVxuICAgICAgbGV0IGNvbmRpdGlvbk9wZXJhdG9yOiAnJGFuZCcgfCAnJG9yJ1xuICAgICAgaWYgKHJlbGF0aW9uT3JQYXRoLnRvTG93ZXJDYXNlKCkgPT09ICdhbmQnKSB7XG4gICAgICAgIGNvbmRpdGlvbk9wZXJhdG9yID0gJyRhbmQnXG4gICAgICB9IGVsc2UgaWYgKHJlbGF0aW9uT3JQYXRoLnRvTG93ZXJDYXNlKCkgPT09ICdvcicpIHtcbiAgICAgICAgY29uZGl0aW9uT3BlcmF0b3IgPSAnJG9yJ1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29uZGl0aW9uKSkge1xuICAgICAgICBjb25zdCBidWlsdENvbmRpdGlvbnMgPSBhd2FpdCBidWlsZEFuZE9yQ29uZGl0aW9ucyh7XG4gICAgICAgICAgY29sbGVjdGlvblNsdWcsXG4gICAgICAgICAgZmllbGRzLFxuICAgICAgICAgIGdsb2JhbFNsdWcsXG4gICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgd2hlcmU6IGNvbmRpdGlvbixcbiAgICAgICAgfSlcbiAgICAgICAgaWYgKGJ1aWx0Q29uZGl0aW9ucy5sZW5ndGggPiAwKSByZXN1bHRbY29uZGl0aW9uT3BlcmF0b3JdID0gYnVpbHRDb25kaXRpb25zXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJdCdzIGEgcGF0aCAtIGFuZCB0aGVyZSBjYW4gYmUgbXVsdGlwbGUgY29tcGFyaXNvbnMgb24gYSBzaW5nbGUgcGF0aC5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGUgLSB0aXRsZSBsaWtlICd0ZXN0JyBhbmQgdGl0bGUgbm90IGVxdWFsIHRvICd0ZXN0ZXInXG4gICAgICAgIC8vIFNvIHdlIG5lZWQgdG8gbG9vcCBvbiBrZXlzIGFnYWluIGhlcmUgdG8gaGFuZGxlIGVhY2ggb3BlcmF0b3IgaW5kZXBlbmRlbnRseVxuICAgICAgICBjb25zdCBwYXRoT3BlcmF0b3JzID0gd2hlcmVbcmVsYXRpb25PclBhdGhdXG4gICAgICAgIGlmICh0eXBlb2YgcGF0aE9wZXJhdG9ycyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG9wZXJhdG9yIG9mIE9iamVjdC5rZXlzKHBhdGhPcGVyYXRvcnMpKSB7XG4gICAgICAgICAgICBpZiAodmFsaWRPcGVyYXRvcnMuaW5jbHVkZXMob3BlcmF0b3IgYXMgT3BlcmF0b3IpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtID0gYXdhaXQgYnVpbGRTZWFyY2hQYXJhbSh7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvblNsdWcsXG4gICAgICAgICAgICAgICAgZmllbGRzLFxuICAgICAgICAgICAgICAgIGdsb2JhbFNsdWcsXG4gICAgICAgICAgICAgICAgaW5jb21pbmdQYXRoOiByZWxhdGlvbk9yUGF0aCxcbiAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgb3BlcmF0b3IsXG4gICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICB2YWw6IHBhdGhPcGVyYXRvcnNbb3BlcmF0b3JdLFxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIGlmIChzZWFyY2hQYXJhbT8udmFsdWUgJiYgc2VhcmNoUGFyYW0/LnBhdGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgICAgICAgICAgICBbc2VhcmNoUGFyYW0ucGF0aF06IHNlYXJjaFBhcmFtLnZhbHVlLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc2VhcmNoUGFyYW0/LnZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGRlZXBtZXJnZShyZXN1bHQsIHNlYXJjaFBhcmFtLnZhbHVlLCB7IGFycmF5TWVyZ2U6IGNvbWJpbmVNZXJnZSB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuIl0sIm5hbWVzIjpbInBhcnNlUGFyYW1zIiwiY29sbGVjdGlvblNsdWciLCJmaWVsZHMiLCJnbG9iYWxTbHVnIiwibG9jYWxlIiwicGF5bG9hZCIsIndoZXJlIiwicmVzdWx0IiwicmVsYXRpb25PclBhdGgiLCJPYmplY3QiLCJrZXlzIiwiY29uZGl0aW9uIiwiY29uZGl0aW9uT3BlcmF0b3IiLCJ0b0xvd2VyQ2FzZSIsIkFycmF5IiwiaXNBcnJheSIsImJ1aWx0Q29uZGl0aW9ucyIsImJ1aWxkQW5kT3JDb25kaXRpb25zIiwibGVuZ3RoIiwicGF0aE9wZXJhdG9ycyIsIm9wZXJhdG9yIiwidmFsaWRPcGVyYXRvcnMiLCJpbmNsdWRlcyIsInNlYXJjaFBhcmFtIiwiYnVpbGRTZWFyY2hQYXJhbSIsImluY29taW5nUGF0aCIsInZhbCIsInZhbHVlIiwicGF0aCIsImRlZXBtZXJnZSIsImFycmF5TWVyZ2UiLCJjb21iaW5lTWVyZ2UiXSwibWFwcGluZ3MiOiJBQUFBLHVDQUF1QyxHQUN2QyxtQ0FBbUM7Ozs7K0JBYWJBOzs7ZUFBQUE7OztrRUFQQTt1QkFDUzsyQkFDRjtzQ0FFUTttQ0FDSjs7Ozs7O0FBRTFCLGVBQWVBLFlBQVksRUFDaENDLGNBQWMsRUFDZEMsTUFBTSxFQUNOQyxVQUFVLEVBQ1ZDLE1BQU0sRUFDTkMsT0FBTyxFQUNQQyxLQUFLLEVBUU47SUFDQyxJQUFJQyxTQUFTLENBQUM7SUFFZCxJQUFJLE9BQU9ELFVBQVUsVUFBVTtRQUM3Qix1RUFBdUU7UUFDdkUsS0FBSyxNQUFNRSxrQkFBa0JDLE9BQU9DLElBQUksQ0FBQ0osT0FBUTtZQUMvQyxNQUFNSyxZQUFZTCxLQUFLLENBQUNFLGVBQWU7WUFDdkMsSUFBSUk7WUFDSixJQUFJSixlQUFlSyxXQUFXLE9BQU8sT0FBTztnQkFDMUNELG9CQUFvQjtZQUN0QixPQUFPLElBQUlKLGVBQWVLLFdBQVcsT0FBTyxNQUFNO2dCQUNoREQsb0JBQW9CO1lBQ3RCO1lBQ0EsSUFBSUUsTUFBTUMsT0FBTyxDQUFDSixZQUFZO2dCQUM1QixNQUFNSyxrQkFBa0IsTUFBTUMsSUFBQUEsMENBQW9CLEVBQUM7b0JBQ2pEaEI7b0JBQ0FDO29CQUNBQztvQkFDQUM7b0JBQ0FDO29CQUNBQyxPQUFPSztnQkFDVDtnQkFDQSxJQUFJSyxnQkFBZ0JFLE1BQU0sR0FBRyxHQUFHWCxNQUFNLENBQUNLLGtCQUFrQixHQUFHSTtZQUM5RCxPQUFPO2dCQUNMLHdFQUF3RTtnQkFDeEUsa0VBQWtFO2dCQUNsRSw4RUFBOEU7Z0JBQzlFLE1BQU1HLGdCQUFnQmIsS0FBSyxDQUFDRSxlQUFlO2dCQUMzQyxJQUFJLE9BQU9XLGtCQUFrQixVQUFVO29CQUNyQyxLQUFLLE1BQU1DLFlBQVlYLE9BQU9DLElBQUksQ0FBQ1MsZUFBZ0I7d0JBQ2pELElBQUlFLHFCQUFjLENBQUNDLFFBQVEsQ0FBQ0YsV0FBdUI7NEJBQ2pELE1BQU1HLGNBQWMsTUFBTUMsSUFBQUEsbUNBQWdCLEVBQUM7Z0NBQ3pDdkI7Z0NBQ0FDO2dDQUNBQztnQ0FDQXNCLGNBQWNqQjtnQ0FDZEo7Z0NBQ0FnQjtnQ0FDQWY7Z0NBQ0FxQixLQUFLUCxhQUFhLENBQUNDLFNBQVM7NEJBQzlCOzRCQUVBLElBQUlHLGFBQWFJLFNBQVNKLGFBQWFLLE1BQU07Z0NBQzNDckIsU0FBUztvQ0FDUCxHQUFHQSxNQUFNO29DQUNULENBQUNnQixZQUFZSyxJQUFJLENBQUMsRUFBRUwsWUFBWUksS0FBSztnQ0FDdkM7NEJBQ0YsT0FBTyxJQUFJLE9BQU9KLGFBQWFJLFVBQVUsVUFBVTtnQ0FDakRwQixTQUFTc0IsSUFBQUEsa0JBQVMsRUFBQ3RCLFFBQVFnQixZQUFZSSxLQUFLLEVBQUU7b0NBQUVHLFlBQVlDLHVCQUFZO2dDQUFDOzRCQUMzRTt3QkFDRjtvQkFDRjtnQkFDRjtZQUNGO1FBQ0Y7SUFDRjtJQUVBLE9BQU94QjtBQUNUIn0=