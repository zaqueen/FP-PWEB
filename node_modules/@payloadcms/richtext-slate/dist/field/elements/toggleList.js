"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _slate = require("slate");
const _slatereact = require("slate-react");
const _getCommonBlock = require("./getCommonBlock");
const _isListActive = /*#__PURE__*/ _interop_require_default(require("./isListActive"));
const _listTypes = /*#__PURE__*/ _interop_require_default(require("./listTypes"));
const _unwrapList = require("./unwrapList");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const toggleList = (editor, format)=>{
    let currentListFormat;
    if ((0, _isListActive.default)(editor, 'ol')) currentListFormat = 'ol';
    if ((0, _isListActive.default)(editor, 'ul')) currentListFormat = 'ul';
    // If the format is currently active,
    // remove the list
    if (currentListFormat === format) {
        const selectedLeaf = _slate.Node.descendant(editor, editor.selection.anchor.path);
        // If on an empty bullet, leave the above list alone
        // and unwrap only the active bullet
        if (_slate.Text.isText(selectedLeaf) && String(selectedLeaf.text).length === 0) {
            _slate.Transforms.unwrapNodes(editor, {
                match: (n)=>_slate.Element.isElement(n) && _listTypes.default.includes(n.type),
                mode: 'lowest',
                split: true
            });
            _slate.Transforms.setNodes(editor, {
                type: undefined
            });
        } else {
            // Otherwise, we need to unset li on all lis in the parent list
            // and unwrap the parent list itself
            const [, listPath] = (0, _getCommonBlock.getCommonBlock)(editor, (n)=>_slate.Element.isElement(n) && n.type === format);
            (0, _unwrapList.unwrapList)(editor, listPath);
        }
    // Otherwise, if a list is active and we are changing it,
    // change it
    } else if (currentListFormat && currentListFormat !== format) {
        _slate.Transforms.setNodes(editor, {
            type: format
        }, {
            match: (node)=>_slate.Element.isElement(node) && _listTypes.default.includes(node.type),
            mode: 'lowest'
        });
    // Otherwise we can assume that we should just activate the list
    } else {
        _slate.Transforms.wrapNodes(editor, {
            children: [],
            type: format
        });
        const [, parentNodePath] = (0, _getCommonBlock.getCommonBlock)(editor, (node)=>_slate.Element.isElement(node) && node.type === format);
        // Only set li on nodes that don't have type
        _slate.Transforms.setNodes(editor, {
            type: 'li'
        }, {
            match: (node, path)=>{
                const match = _slate.Element.isElement(node) && typeof node.type === 'undefined' && path.length === parentNodePath.length + 1;
                return match;
            },
            voids: true
        });
        // Wrap nodes that do have a type with an li
        // so as to not lose their existing formatting
        const nodesToWrap = Array.from(_slate.Editor.nodes(editor, {
            match: (node, path)=>{
                const match = _slate.Element.isElement(node) && typeof node.type !== 'undefined' && node.type !== 'li' && path.length === parentNodePath.length + 1;
                return match;
            }
        }));
        nodesToWrap.forEach(([, path])=>{
            _slate.Transforms.wrapNodes(editor, {
                children: [],
                type: 'li'
            }, {
                at: path
            });
        });
    }
    _slatereact.ReactEditor.focus(editor);
};
const _default = toggleList;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9maWVsZC9lbGVtZW50cy90b2dnbGVMaXN0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFZGl0b3IsIEVsZW1lbnQsIE5vZGUsIFRleHQsIFRyYW5zZm9ybXMgfSBmcm9tICdzbGF0ZSdcbmltcG9ydCB7IFJlYWN0RWRpdG9yIH0gZnJvbSAnc2xhdGUtcmVhY3QnXG5cbmltcG9ydCB7IGdldENvbW1vbkJsb2NrIH0gZnJvbSAnLi9nZXRDb21tb25CbG9jaydcbmltcG9ydCBpc0xpc3RBY3RpdmUgZnJvbSAnLi9pc0xpc3RBY3RpdmUnXG5pbXBvcnQgbGlzdFR5cGVzIGZyb20gJy4vbGlzdFR5cGVzJ1xuaW1wb3J0IHsgdW53cmFwTGlzdCB9IGZyb20gJy4vdW53cmFwTGlzdCdcblxuY29uc3QgdG9nZ2xlTGlzdCA9IChlZGl0b3I6IEVkaXRvciwgZm9ybWF0OiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgbGV0IGN1cnJlbnRMaXN0Rm9ybWF0OiBzdHJpbmdcblxuICBpZiAoaXNMaXN0QWN0aXZlKGVkaXRvciwgJ29sJykpIGN1cnJlbnRMaXN0Rm9ybWF0ID0gJ29sJ1xuICBpZiAoaXNMaXN0QWN0aXZlKGVkaXRvciwgJ3VsJykpIGN1cnJlbnRMaXN0Rm9ybWF0ID0gJ3VsJ1xuXG4gIC8vIElmIHRoZSBmb3JtYXQgaXMgY3VycmVudGx5IGFjdGl2ZSxcbiAgLy8gcmVtb3ZlIHRoZSBsaXN0XG4gIGlmIChjdXJyZW50TGlzdEZvcm1hdCA9PT0gZm9ybWF0KSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRMZWFmID0gTm9kZS5kZXNjZW5kYW50KGVkaXRvciwgZWRpdG9yLnNlbGVjdGlvbi5hbmNob3IucGF0aClcblxuICAgIC8vIElmIG9uIGFuIGVtcHR5IGJ1bGxldCwgbGVhdmUgdGhlIGFib3ZlIGxpc3QgYWxvbmVcbiAgICAvLyBhbmQgdW53cmFwIG9ubHkgdGhlIGFjdGl2ZSBidWxsZXRcbiAgICBpZiAoVGV4dC5pc1RleHQoc2VsZWN0ZWRMZWFmKSAmJiBTdHJpbmcoc2VsZWN0ZWRMZWFmLnRleHQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IChuKSA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBsaXN0VHlwZXMuaW5jbHVkZXMobi50eXBlKSxcbiAgICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICAgIHNwbGl0OiB0cnVlLFxuICAgICAgfSlcblxuICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHsgdHlwZTogdW5kZWZpbmVkIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSwgd2UgbmVlZCB0byB1bnNldCBsaSBvbiBhbGwgbGlzIGluIHRoZSBwYXJlbnQgbGlzdFxuICAgICAgLy8gYW5kIHVud3JhcCB0aGUgcGFyZW50IGxpc3QgaXRzZWxmXG4gICAgICBjb25zdCBbLCBsaXN0UGF0aF0gPSBnZXRDb21tb25CbG9jayhlZGl0b3IsIChuKSA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBuLnR5cGUgPT09IGZvcm1hdClcbiAgICAgIHVud3JhcExpc3QoZWRpdG9yLCBsaXN0UGF0aClcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2UsIGlmIGEgbGlzdCBpcyBhY3RpdmUgYW5kIHdlIGFyZSBjaGFuZ2luZyBpdCxcbiAgICAvLyBjaGFuZ2UgaXRcbiAgfSBlbHNlIGlmIChjdXJyZW50TGlzdEZvcm1hdCAmJiBjdXJyZW50TGlzdEZvcm1hdCAhPT0gZm9ybWF0KSB7XG4gICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhcbiAgICAgIGVkaXRvcixcbiAgICAgIHtcbiAgICAgICAgdHlwZTogZm9ybWF0LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBsaXN0VHlwZXMuaW5jbHVkZXMobm9kZS50eXBlKSxcbiAgICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICB9LFxuICAgIClcbiAgICAvLyBPdGhlcndpc2Ugd2UgY2FuIGFzc3VtZSB0aGF0IHdlIHNob3VsZCBqdXN0IGFjdGl2YXRlIHRoZSBsaXN0XG4gIH0gZWxzZSB7XG4gICAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCB7IGNoaWxkcmVuOiBbXSwgdHlwZTogZm9ybWF0IH0pXG5cbiAgICBjb25zdCBbLCBwYXJlbnROb2RlUGF0aF0gPSBnZXRDb21tb25CbG9jayhcbiAgICAgIGVkaXRvcixcbiAgICAgIChub2RlKSA9PiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLnR5cGUgPT09IGZvcm1hdCxcbiAgICApXG5cbiAgICAvLyBPbmx5IHNldCBsaSBvbiBub2RlcyB0aGF0IGRvbid0IGhhdmUgdHlwZVxuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoXG4gICAgICBlZGl0b3IsXG4gICAgICB7IHR5cGU6ICdsaScgfSxcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IChub2RlLCBwYXRoKSA9PiB7XG4gICAgICAgICAgY29uc3QgbWF0Y2ggPVxuICAgICAgICAgICAgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiZcbiAgICAgICAgICAgIHR5cGVvZiBub2RlLnR5cGUgPT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBwYXRoLmxlbmd0aCA9PT0gcGFyZW50Tm9kZVBhdGgubGVuZ3RoICsgMVxuXG4gICAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICAgIH0sXG4gICAgICAgIHZvaWRzOiB0cnVlLFxuICAgICAgfSxcbiAgICApXG5cbiAgICAvLyBXcmFwIG5vZGVzIHRoYXQgZG8gaGF2ZSBhIHR5cGUgd2l0aCBhbiBsaVxuICAgIC8vIHNvIGFzIHRvIG5vdCBsb3NlIHRoZWlyIGV4aXN0aW5nIGZvcm1hdHRpbmdcbiAgICBjb25zdCBub2Rlc1RvV3JhcCA9IEFycmF5LmZyb20oXG4gICAgICBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiAobm9kZSwgcGF0aCkgPT4ge1xuICAgICAgICAgIGNvbnN0IG1hdGNoID1cbiAgICAgICAgICAgIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmXG4gICAgICAgICAgICB0eXBlb2Ygbm9kZS50eXBlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgbm9kZS50eXBlICE9PSAnbGknICYmXG4gICAgICAgICAgICBwYXRoLmxlbmd0aCA9PT0gcGFyZW50Tm9kZVBhdGgubGVuZ3RoICsgMVxuXG4gICAgICAgICAgcmV0dXJuIG1hdGNoXG4gICAgICAgIH0sXG4gICAgICB9KSxcbiAgICApXG5cbiAgICBub2Rlc1RvV3JhcC5mb3JFYWNoKChbLCBwYXRoXSkgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy53cmFwTm9kZXMoZWRpdG9yLCB7IGNoaWxkcmVuOiBbXSwgdHlwZTogJ2xpJyB9LCB7IGF0OiBwYXRoIH0pXG4gICAgfSlcbiAgfVxuXG4gIFJlYWN0RWRpdG9yLmZvY3VzKGVkaXRvcilcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9nZ2xlTGlzdFxuIl0sIm5hbWVzIjpbInRvZ2dsZUxpc3QiLCJlZGl0b3IiLCJmb3JtYXQiLCJjdXJyZW50TGlzdEZvcm1hdCIsImlzTGlzdEFjdGl2ZSIsInNlbGVjdGVkTGVhZiIsIk5vZGUiLCJkZXNjZW5kYW50Iiwic2VsZWN0aW9uIiwiYW5jaG9yIiwicGF0aCIsIlRleHQiLCJpc1RleHQiLCJTdHJpbmciLCJ0ZXh0IiwibGVuZ3RoIiwiVHJhbnNmb3JtcyIsInVud3JhcE5vZGVzIiwibWF0Y2giLCJuIiwiRWxlbWVudCIsImlzRWxlbWVudCIsImxpc3RUeXBlcyIsImluY2x1ZGVzIiwidHlwZSIsIm1vZGUiLCJzcGxpdCIsInNldE5vZGVzIiwidW5kZWZpbmVkIiwibGlzdFBhdGgiLCJnZXRDb21tb25CbG9jayIsInVud3JhcExpc3QiLCJub2RlIiwid3JhcE5vZGVzIiwiY2hpbGRyZW4iLCJwYXJlbnROb2RlUGF0aCIsInZvaWRzIiwibm9kZXNUb1dyYXAiLCJBcnJheSIsImZyb20iLCJFZGl0b3IiLCJub2RlcyIsImZvckVhY2giLCJhdCIsIlJlYWN0RWRpdG9yIiwiZm9jdXMiXSwibWFwcGluZ3MiOiI7Ozs7K0JBbUdBOzs7ZUFBQTs7O3VCQW5Hd0Q7NEJBQzVCO2dDQUVHO3FFQUNOO2tFQUNIOzRCQUNLOzs7Ozs7QUFFM0IsTUFBTUEsYUFBYSxDQUFDQyxRQUFnQkM7SUFDbEMsSUFBSUM7SUFFSixJQUFJQyxJQUFBQSxxQkFBWSxFQUFDSCxRQUFRLE9BQU9FLG9CQUFvQjtJQUNwRCxJQUFJQyxJQUFBQSxxQkFBWSxFQUFDSCxRQUFRLE9BQU9FLG9CQUFvQjtJQUVwRCxxQ0FBcUM7SUFDckMsa0JBQWtCO0lBQ2xCLElBQUlBLHNCQUFzQkQsUUFBUTtRQUNoQyxNQUFNRyxlQUFlQyxXQUFJLENBQUNDLFVBQVUsQ0FBQ04sUUFBUUEsT0FBT08sU0FBUyxDQUFDQyxNQUFNLENBQUNDLElBQUk7UUFFekUsb0RBQW9EO1FBQ3BELG9DQUFvQztRQUNwQyxJQUFJQyxXQUFJLENBQUNDLE1BQU0sQ0FBQ1AsaUJBQWlCUSxPQUFPUixhQUFhUyxJQUFJLEVBQUVDLE1BQU0sS0FBSyxHQUFHO1lBQ3ZFQyxpQkFBVSxDQUFDQyxXQUFXLENBQUNoQixRQUFRO2dCQUM3QmlCLE9BQU8sQ0FBQ0MsSUFBTUMsY0FBTyxDQUFDQyxTQUFTLENBQUNGLE1BQU1HLGtCQUFTLENBQUNDLFFBQVEsQ0FBQ0osRUFBRUssSUFBSTtnQkFDL0RDLE1BQU07Z0JBQ05DLE9BQU87WUFDVDtZQUVBVixpQkFBVSxDQUFDVyxRQUFRLENBQUMxQixRQUFRO2dCQUFFdUIsTUFBTUk7WUFBVTtRQUNoRCxPQUFPO1lBQ0wsK0RBQStEO1lBQy9ELG9DQUFvQztZQUNwQyxNQUFNLEdBQUdDLFNBQVMsR0FBR0MsSUFBQUEsOEJBQWMsRUFBQzdCLFFBQVEsQ0FBQ2tCLElBQU1DLGNBQU8sQ0FBQ0MsU0FBUyxDQUFDRixNQUFNQSxFQUFFSyxJQUFJLEtBQUt0QjtZQUN0RjZCLElBQUFBLHNCQUFVLEVBQUM5QixRQUFRNEI7UUFDckI7SUFFQSx5REFBeUQ7SUFDekQsWUFBWTtJQUNkLE9BQU8sSUFBSTFCLHFCQUFxQkEsc0JBQXNCRCxRQUFRO1FBQzVEYyxpQkFBVSxDQUFDVyxRQUFRLENBQ2pCMUIsUUFDQTtZQUNFdUIsTUFBTXRCO1FBQ1IsR0FDQTtZQUNFZ0IsT0FBTyxDQUFDYyxPQUFTWixjQUFPLENBQUNDLFNBQVMsQ0FBQ1csU0FBU1Ysa0JBQVMsQ0FBQ0MsUUFBUSxDQUFDUyxLQUFLUixJQUFJO1lBQ3hFQyxNQUFNO1FBQ1I7SUFFRixnRUFBZ0U7SUFDbEUsT0FBTztRQUNMVCxpQkFBVSxDQUFDaUIsU0FBUyxDQUFDaEMsUUFBUTtZQUFFaUMsVUFBVSxFQUFFO1lBQUVWLE1BQU10QjtRQUFPO1FBRTFELE1BQU0sR0FBR2lDLGVBQWUsR0FBR0wsSUFBQUEsOEJBQWMsRUFDdkM3QixRQUNBLENBQUMrQixPQUFTWixjQUFPLENBQUNDLFNBQVMsQ0FBQ1csU0FBU0EsS0FBS1IsSUFBSSxLQUFLdEI7UUFHckQsNENBQTRDO1FBQzVDYyxpQkFBVSxDQUFDVyxRQUFRLENBQ2pCMUIsUUFDQTtZQUFFdUIsTUFBTTtRQUFLLEdBQ2I7WUFDRU4sT0FBTyxDQUFDYyxNQUFNdEI7Z0JBQ1osTUFBTVEsUUFDSkUsY0FBTyxDQUFDQyxTQUFTLENBQUNXLFNBQ2xCLE9BQU9BLEtBQUtSLElBQUksS0FBSyxlQUNyQmQsS0FBS0ssTUFBTSxLQUFLb0IsZUFBZXBCLE1BQU0sR0FBRztnQkFFMUMsT0FBT0c7WUFDVDtZQUNBa0IsT0FBTztRQUNUO1FBR0YsNENBQTRDO1FBQzVDLDhDQUE4QztRQUM5QyxNQUFNQyxjQUFjQyxNQUFNQyxJQUFJLENBQzVCQyxhQUFNLENBQUNDLEtBQUssQ0FBQ3hDLFFBQVE7WUFDbkJpQixPQUFPLENBQUNjLE1BQU10QjtnQkFDWixNQUFNUSxRQUNKRSxjQUFPLENBQUNDLFNBQVMsQ0FBQ1csU0FDbEIsT0FBT0EsS0FBS1IsSUFBSSxLQUFLLGVBQ3JCUSxLQUFLUixJQUFJLEtBQUssUUFDZGQsS0FBS0ssTUFBTSxLQUFLb0IsZUFBZXBCLE1BQU0sR0FBRztnQkFFMUMsT0FBT0c7WUFDVDtRQUNGO1FBR0ZtQixZQUFZSyxPQUFPLENBQUMsQ0FBQyxHQUFHaEMsS0FBSztZQUMzQk0saUJBQVUsQ0FBQ2lCLFNBQVMsQ0FBQ2hDLFFBQVE7Z0JBQUVpQyxVQUFVLEVBQUU7Z0JBQUVWLE1BQU07WUFBSyxHQUFHO2dCQUFFbUIsSUFBSWpDO1lBQUs7UUFDeEU7SUFDRjtJQUVBa0MsdUJBQVcsQ0FBQ0MsS0FBSyxDQUFDNUM7QUFDcEI7TUFFQSxXQUFlRCJ9