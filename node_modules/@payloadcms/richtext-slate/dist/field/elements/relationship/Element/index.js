'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _components = require("payload/components");
const _elements = require("payload/components/elements");
const _hooks = require("payload/components/hooks");
const _utilities = require("payload/components/utilities");
const _utilities1 = require("payload/utilities");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _slate = require("slate");
const _slatereact = require("slate-react");
const _EnabledRelationshipsCondition = require("../../EnabledRelationshipsCondition");
require("./index.scss");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'rich-text-relationship';
const initialParams = {
    depth: 0
};
const Element = (props)=>{
    const { attributes, children, element, element: { relationTo, value }, fieldProps } = props;
    const { collections, routes: { api }, serverURL } = (0, _utilities.useConfig)();
    const [enabledCollectionSlugs] = (0, _react.useState)(()=>collections.filter(({ admin: { enableRichTextRelationship } })=>enableRichTextRelationship).map(({ slug })=>slug));
    const [relatedCollection, setRelatedCollection] = (0, _react.useState)(()=>collections.find((coll)=>coll.slug === relationTo));
    const selected = (0, _slatereact.useSelected)();
    const focused = (0, _slatereact.useFocused)();
    const { i18n, t } = (0, _reacti18next.useTranslation)([
        'fields',
        'general'
    ]);
    const editor = (0, _slatereact.useSlateStatic)();
    const [cacheBust, dispatchCacheBust] = (0, _react.useReducer)((state)=>state + 1, 0);
    const [{ data }, { setParams }] = (0, _hooks.usePayloadAPI)(`${serverURL}${api}/${relatedCollection.slug}/${value?.id}`, {
        initialParams
    });
    const [DocumentDrawer, DocumentDrawerToggler, { closeDrawer }] = (0, _elements.useDocumentDrawer)({
        id: value?.id,
        collectionSlug: relatedCollection.slug
    });
    const [ListDrawer, ListDrawerToggler, { closeDrawer: closeListDrawer }] = (0, _elements.useListDrawer)({
        collectionSlugs: enabledCollectionSlugs,
        selectedCollection: relatedCollection.slug
    });
    const removeRelationship = (0, _react.useCallback)(()=>{
        const elementPath = _slatereact.ReactEditor.findPath(editor, element);
        _slate.Transforms.removeNodes(editor, {
            at: elementPath
        });
    }, [
        editor,
        element
    ]);
    const updateRelationship = _react.default.useCallback(({ doc })=>{
        const elementPath = _slatereact.ReactEditor.findPath(editor, element);
        _slate.Transforms.setNodes(editor, {
            children: [
                {
                    text: ' '
                }
            ],
            relationTo: relatedCollection.slug,
            type: 'relationship',
            value: {
                id: doc.id
            }
        }, {
            at: elementPath
        });
        setParams({
            ...initialParams,
            cacheBust
        });
        closeDrawer();
        dispatchCacheBust();
    }, [
        editor,
        element,
        relatedCollection,
        cacheBust,
        setParams,
        closeDrawer
    ]);
    const swapRelationship = _react.default.useCallback(({ collectionConfig, docID })=>{
        const elementPath = _slatereact.ReactEditor.findPath(editor, element);
        _slate.Transforms.setNodes(editor, {
            children: [
                {
                    text: ' '
                }
            ],
            relationTo: collectionConfig.slug,
            type: 'relationship',
            value: {
                id: docID
            }
        }, {
            at: elementPath
        });
        setRelatedCollection(collections.find((coll)=>coll.slug === collectionConfig.slug));
        setParams({
            ...initialParams,
            cacheBust
        });
        closeListDrawer();
        dispatchCacheBust();
    }, [
        closeListDrawer,
        editor,
        element,
        cacheBust,
        setParams,
        collections
    ]);
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: [
            baseClass,
            selected && focused && `${baseClass}--selected`
        ].filter(Boolean).join(' '),
        contentEditable: false,
        ...attributes
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__wrap`
    }, /*#__PURE__*/ _react.default.createElement("p", {
        className: `${baseClass}__label`
    }, t('labelRelationship', {
        label: (0, _utilities1.getTranslation)(relatedCollection.labels.singular, i18n)
    })), /*#__PURE__*/ _react.default.createElement(DocumentDrawerToggler, {
        className: `${baseClass}__doc-drawer-toggler`
    }, /*#__PURE__*/ _react.default.createElement("p", {
        className: `${baseClass}__title`
    }, data[relatedCollection?.admin?.useAsTitle || 'id']))), /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__actions`
    }, /*#__PURE__*/ _react.default.createElement(ListDrawerToggler, {
        className: `${baseClass}__list-drawer-toggler`,
        disabled: fieldProps?.admin?.readOnly
    }, /*#__PURE__*/ _react.default.createElement(_components.Button, {
        buttonStyle: "icon-label",
        disabled: fieldProps?.admin?.readOnly,
        el: "div",
        icon: "swap",
        onClick: ()=>{
        // do nothing
        },
        round: true,
        tooltip: t('swapRelationship')
    })), /*#__PURE__*/ _react.default.createElement(_components.Button, {
        buttonStyle: "icon-label",
        className: `${baseClass}__removeButton`,
        disabled: fieldProps?.admin?.readOnly,
        icon: "x",
        onClick: (e)=>{
            e.preventDefault();
            removeRelationship();
        },
        round: true,
        tooltip: t('fields:removeRelationship')
    })), value?.id && /*#__PURE__*/ _react.default.createElement(DocumentDrawer, {
        onSave: updateRelationship
    }), /*#__PURE__*/ _react.default.createElement(ListDrawer, {
        onSelect: swapRelationship
    }), children);
};
const _default = (props)=>{
    return /*#__PURE__*/ _react.default.createElement(_EnabledRelationshipsCondition.EnabledRelationshipsCondition, props, /*#__PURE__*/ _react.default.createElement(Element, props));
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9maWVsZC9lbGVtZW50cy9yZWxhdGlvbnNoaXAvRWxlbWVudC9pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB0eXBlIHsgSFRNTEF0dHJpYnV0ZXMgfSBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHsgQnV0dG9uIH0gZnJvbSAncGF5bG9hZC9jb21wb25lbnRzJ1xuaW1wb3J0IHsgdXNlRG9jdW1lbnREcmF3ZXIsIHVzZUxpc3REcmF3ZXIgfSBmcm9tICdwYXlsb2FkL2NvbXBvbmVudHMvZWxlbWVudHMnXG5pbXBvcnQgeyB1c2VQYXlsb2FkQVBJIH0gZnJvbSAncGF5bG9hZC9jb21wb25lbnRzL2hvb2tzJ1xuaW1wb3J0IHsgdXNlQ29uZmlnIH0gZnJvbSAncGF5bG9hZC9jb21wb25lbnRzL3V0aWxpdGllcydcbmltcG9ydCB7IGdldFRyYW5zbGF0aW9uIH0gZnJvbSAncGF5bG9hZC91dGlsaXRpZXMnXG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZVJlZHVjZXIsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VUcmFuc2xhdGlvbiB9IGZyb20gJ3JlYWN0LWkxOG5leHQnXG5pbXBvcnQgeyBUcmFuc2Zvcm1zIH0gZnJvbSAnc2xhdGUnXG5pbXBvcnQgeyBSZWFjdEVkaXRvciwgdXNlRm9jdXNlZCwgdXNlU2VsZWN0ZWQsIHVzZVNsYXRlU3RhdGljIH0gZnJvbSAnc2xhdGUtcmVhY3QnXG5cbmltcG9ydCB0eXBlIHsgRmllbGRQcm9wcyB9IGZyb20gJy4uLy4uLy4uLy4uL3R5cGVzJ1xuXG5pbXBvcnQgeyBFbmFibGVkUmVsYXRpb25zaGlwc0NvbmRpdGlvbiB9IGZyb20gJy4uLy4uL0VuYWJsZWRSZWxhdGlvbnNoaXBzQ29uZGl0aW9uJ1xuaW1wb3J0ICcuL2luZGV4LnNjc3MnXG5cbmNvbnN0IGJhc2VDbGFzcyA9ICdyaWNoLXRleHQtcmVsYXRpb25zaGlwJ1xuXG5jb25zdCBpbml0aWFsUGFyYW1zID0ge1xuICBkZXB0aDogMCxcbn1cblxudHlwZSBQcm9wcyA9IHtcbiAgYXR0cmlidXRlczogSFRNTEF0dHJpYnV0ZXM8SFRNTERpdkVsZW1lbnQ+XG4gIGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGVcbiAgZWxlbWVudDogYW55XG4gIGZpZWxkUHJvcHM6IEZpZWxkUHJvcHNcbn1cbmNvbnN0IEVsZW1lbnQ6IFJlYWN0LkZDPFByb3BzPiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgYXR0cmlidXRlcyxcbiAgICBjaGlsZHJlbixcbiAgICBlbGVtZW50LFxuICAgIGVsZW1lbnQ6IHsgcmVsYXRpb25UbywgdmFsdWUgfSxcbiAgICBmaWVsZFByb3BzLFxuICB9ID0gcHJvcHNcblxuICBjb25zdCB7XG4gICAgY29sbGVjdGlvbnMsXG4gICAgcm91dGVzOiB7IGFwaSB9LFxuICAgIHNlcnZlclVSTCxcbiAgfSA9IHVzZUNvbmZpZygpXG4gIGNvbnN0IFtlbmFibGVkQ29sbGVjdGlvblNsdWdzXSA9IHVzZVN0YXRlKCgpID0+XG4gICAgY29sbGVjdGlvbnNcbiAgICAgIC5maWx0ZXIoKHsgYWRtaW46IHsgZW5hYmxlUmljaFRleHRSZWxhdGlvbnNoaXAgfSB9KSA9PiBlbmFibGVSaWNoVGV4dFJlbGF0aW9uc2hpcClcbiAgICAgIC5tYXAoKHsgc2x1ZyB9KSA9PiBzbHVnKSxcbiAgKVxuICBjb25zdCBbcmVsYXRlZENvbGxlY3Rpb24sIHNldFJlbGF0ZWRDb2xsZWN0aW9uXSA9IHVzZVN0YXRlKCgpID0+XG4gICAgY29sbGVjdGlvbnMuZmluZCgoY29sbCkgPT4gY29sbC5zbHVnID09PSByZWxhdGlvblRvKSxcbiAgKVxuICBjb25zdCBzZWxlY3RlZCA9IHVzZVNlbGVjdGVkKClcbiAgY29uc3QgZm9jdXNlZCA9IHVzZUZvY3VzZWQoKVxuICBjb25zdCB7IGkxOG4sIHQgfSA9IHVzZVRyYW5zbGF0aW9uKFsnZmllbGRzJywgJ2dlbmVyYWwnXSlcbiAgY29uc3QgZWRpdG9yID0gdXNlU2xhdGVTdGF0aWMoKVxuICBjb25zdCBbY2FjaGVCdXN0LCBkaXNwYXRjaENhY2hlQnVzdF0gPSB1c2VSZWR1Y2VyKChzdGF0ZSkgPT4gc3RhdGUgKyAxLCAwKVxuICBjb25zdCBbeyBkYXRhIH0sIHsgc2V0UGFyYW1zIH1dID0gdXNlUGF5bG9hZEFQSShcbiAgICBgJHtzZXJ2ZXJVUkx9JHthcGl9LyR7cmVsYXRlZENvbGxlY3Rpb24uc2x1Z30vJHt2YWx1ZT8uaWR9YCxcbiAgICB7IGluaXRpYWxQYXJhbXMgfSxcbiAgKVxuXG4gIGNvbnN0IFtEb2N1bWVudERyYXdlciwgRG9jdW1lbnREcmF3ZXJUb2dnbGVyLCB7IGNsb3NlRHJhd2VyIH1dID0gdXNlRG9jdW1lbnREcmF3ZXIoe1xuICAgIGlkOiB2YWx1ZT8uaWQsXG4gICAgY29sbGVjdGlvblNsdWc6IHJlbGF0ZWRDb2xsZWN0aW9uLnNsdWcsXG4gIH0pXG5cbiAgY29uc3QgW0xpc3REcmF3ZXIsIExpc3REcmF3ZXJUb2dnbGVyLCB7IGNsb3NlRHJhd2VyOiBjbG9zZUxpc3REcmF3ZXIgfV0gPSB1c2VMaXN0RHJhd2VyKHtcbiAgICBjb2xsZWN0aW9uU2x1Z3M6IGVuYWJsZWRDb2xsZWN0aW9uU2x1Z3MsXG4gICAgc2VsZWN0ZWRDb2xsZWN0aW9uOiByZWxhdGVkQ29sbGVjdGlvbi5zbHVnLFxuICB9KVxuXG4gIGNvbnN0IHJlbW92ZVJlbGF0aW9uc2hpcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBjb25zdCBlbGVtZW50UGF0aCA9IFJlYWN0RWRpdG9yLmZpbmRQYXRoKGVkaXRvciwgZWxlbWVudClcblxuICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7IGF0OiBlbGVtZW50UGF0aCB9KVxuICB9LCBbZWRpdG9yLCBlbGVtZW50XSlcblxuICBjb25zdCB1cGRhdGVSZWxhdGlvbnNoaXAgPSBSZWFjdC51c2VDYWxsYmFjayhcbiAgICAoeyBkb2MgfSkgPT4ge1xuICAgICAgY29uc3QgZWxlbWVudFBhdGggPSBSZWFjdEVkaXRvci5maW5kUGF0aChlZGl0b3IsIGVsZW1lbnQpXG5cbiAgICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoXG4gICAgICAgIGVkaXRvcixcbiAgICAgICAge1xuICAgICAgICAgIGNoaWxkcmVuOiBbeyB0ZXh0OiAnICcgfV0sXG4gICAgICAgICAgcmVsYXRpb25UbzogcmVsYXRlZENvbGxlY3Rpb24uc2x1ZyxcbiAgICAgICAgICB0eXBlOiAncmVsYXRpb25zaGlwJyxcbiAgICAgICAgICB2YWx1ZTogeyBpZDogZG9jLmlkIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHsgYXQ6IGVsZW1lbnRQYXRoIH0sXG4gICAgICApXG5cbiAgICAgIHNldFBhcmFtcyh7XG4gICAgICAgIC4uLmluaXRpYWxQYXJhbXMsXG4gICAgICAgIGNhY2hlQnVzdCwgLy8gZG8gdGhpcyB0byBnZXQgdGhlIHVzZVBheWxvYWRBUEkgdG8gcmUtZmV0Y2ggdGhlIGRhdGEgZXZlbiB0aG91Z2ggdGhlIFVSTCBzdHJpbmcgaGFzbid0IGNoYW5nZWRcbiAgICAgIH0pXG5cbiAgICAgIGNsb3NlRHJhd2VyKClcbiAgICAgIGRpc3BhdGNoQ2FjaGVCdXN0KClcbiAgICB9LFxuICAgIFtlZGl0b3IsIGVsZW1lbnQsIHJlbGF0ZWRDb2xsZWN0aW9uLCBjYWNoZUJ1c3QsIHNldFBhcmFtcywgY2xvc2VEcmF3ZXJdLFxuICApXG5cbiAgY29uc3Qgc3dhcFJlbGF0aW9uc2hpcCA9IFJlYWN0LnVzZUNhbGxiYWNrKFxuICAgICh7IGNvbGxlY3Rpb25Db25maWcsIGRvY0lEIH0pID0+IHtcbiAgICAgIGNvbnN0IGVsZW1lbnRQYXRoID0gUmVhY3RFZGl0b3IuZmluZFBhdGgoZWRpdG9yLCBlbGVtZW50KVxuXG4gICAgICBUcmFuc2Zvcm1zLnNldE5vZGVzKFxuICAgICAgICBlZGl0b3IsXG4gICAgICAgIHtcbiAgICAgICAgICBjaGlsZHJlbjogW3sgdGV4dDogJyAnIH1dLFxuICAgICAgICAgIHJlbGF0aW9uVG86IGNvbGxlY3Rpb25Db25maWcuc2x1ZyxcbiAgICAgICAgICB0eXBlOiAncmVsYXRpb25zaGlwJyxcbiAgICAgICAgICB2YWx1ZTogeyBpZDogZG9jSUQgfSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBhdDogZWxlbWVudFBhdGggfSxcbiAgICAgIClcblxuICAgICAgc2V0UmVsYXRlZENvbGxlY3Rpb24oY29sbGVjdGlvbnMuZmluZCgoY29sbCkgPT4gY29sbC5zbHVnID09PSBjb2xsZWN0aW9uQ29uZmlnLnNsdWcpKVxuXG4gICAgICBzZXRQYXJhbXMoe1xuICAgICAgICAuLi5pbml0aWFsUGFyYW1zLFxuICAgICAgICBjYWNoZUJ1c3QsIC8vIGRvIHRoaXMgdG8gZ2V0IHRoZSB1c2VQYXlsb2FkQVBJIHRvIHJlLWZldGNoIHRoZSBkYXRhIGV2ZW4gdGhvdWdoIHRoZSBVUkwgc3RyaW5nIGhhc24ndCBjaGFuZ2VkXG4gICAgICB9KVxuXG4gICAgICBjbG9zZUxpc3REcmF3ZXIoKVxuICAgICAgZGlzcGF0Y2hDYWNoZUJ1c3QoKVxuICAgIH0sXG4gICAgW2Nsb3NlTGlzdERyYXdlciwgZWRpdG9yLCBlbGVtZW50LCBjYWNoZUJ1c3QsIHNldFBhcmFtcywgY29sbGVjdGlvbnNdLFxuICApXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2XG4gICAgICBjbGFzc05hbWU9e1tiYXNlQ2xhc3MsIHNlbGVjdGVkICYmIGZvY3VzZWQgJiYgYCR7YmFzZUNsYXNzfS0tc2VsZWN0ZWRgXVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIC5qb2luKCcgJyl9XG4gICAgICBjb250ZW50RWRpdGFibGU9e2ZhbHNlfVxuICAgICAgey4uLmF0dHJpYnV0ZXN9XG4gICAgPlxuICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX3dyYXBgfT5cbiAgICAgICAgPHAgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19sYWJlbGB9PlxuICAgICAgICAgIHt0KCdsYWJlbFJlbGF0aW9uc2hpcCcsIHtcbiAgICAgICAgICAgIGxhYmVsOiBnZXRUcmFuc2xhdGlvbihyZWxhdGVkQ29sbGVjdGlvbi5sYWJlbHMuc2luZ3VsYXIsIGkxOG4pLFxuICAgICAgICAgIH0pfVxuICAgICAgICA8L3A+XG4gICAgICAgIDxEb2N1bWVudERyYXdlclRvZ2dsZXIgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19kb2MtZHJhd2VyLXRvZ2dsZXJgfT5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX3RpdGxlYH0+XG4gICAgICAgICAgICB7ZGF0YVtyZWxhdGVkQ29sbGVjdGlvbj8uYWRtaW4/LnVzZUFzVGl0bGUgfHwgJ2lkJ119XG4gICAgICAgICAgPC9wPlxuICAgICAgICA8L0RvY3VtZW50RHJhd2VyVG9nZ2xlcj5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2FjdGlvbnNgfT5cbiAgICAgICAgPExpc3REcmF3ZXJUb2dnbGVyXG4gICAgICAgICAgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19saXN0LWRyYXdlci10b2dnbGVyYH1cbiAgICAgICAgICBkaXNhYmxlZD17ZmllbGRQcm9wcz8uYWRtaW4/LnJlYWRPbmx5fVxuICAgICAgICA+XG4gICAgICAgICAgPEJ1dHRvblxuICAgICAgICAgICAgYnV0dG9uU3R5bGU9XCJpY29uLWxhYmVsXCJcbiAgICAgICAgICAgIGRpc2FibGVkPXtmaWVsZFByb3BzPy5hZG1pbj8ucmVhZE9ubHl9XG4gICAgICAgICAgICBlbD1cImRpdlwiXG4gICAgICAgICAgICBpY29uPVwic3dhcFwiXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgICByb3VuZFxuICAgICAgICAgICAgdG9vbHRpcD17dCgnc3dhcFJlbGF0aW9uc2hpcCcpfVxuICAgICAgICAgIC8+XG4gICAgICAgIDwvTGlzdERyYXdlclRvZ2dsZXI+XG4gICAgICAgIDxCdXR0b25cbiAgICAgICAgICBidXR0b25TdHlsZT1cImljb24tbGFiZWxcIlxuICAgICAgICAgIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fcmVtb3ZlQnV0dG9uYH1cbiAgICAgICAgICBkaXNhYmxlZD17ZmllbGRQcm9wcz8uYWRtaW4/LnJlYWRPbmx5fVxuICAgICAgICAgIGljb249XCJ4XCJcbiAgICAgICAgICBvbkNsaWNrPXsoZSkgPT4ge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICByZW1vdmVSZWxhdGlvbnNoaXAoKVxuICAgICAgICAgIH19XG4gICAgICAgICAgcm91bmRcbiAgICAgICAgICB0b29sdGlwPXt0KCdmaWVsZHM6cmVtb3ZlUmVsYXRpb25zaGlwJyl9XG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICAgIHt2YWx1ZT8uaWQgJiYgPERvY3VtZW50RHJhd2VyIG9uU2F2ZT17dXBkYXRlUmVsYXRpb25zaGlwfSAvPn1cbiAgICAgIDxMaXN0RHJhd2VyIG9uU2VsZWN0PXtzd2FwUmVsYXRpb25zaGlwfSAvPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvZGl2PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IChwcm9wczogUHJvcHMpOiBSZWFjdC5SZWFjdE5vZGUgPT4ge1xuICByZXR1cm4gKFxuICAgIDxFbmFibGVkUmVsYXRpb25zaGlwc0NvbmRpdGlvbiB7Li4ucHJvcHN9PlxuICAgICAgPEVsZW1lbnQgey4uLnByb3BzfSAvPlxuICAgIDwvRW5hYmxlZFJlbGF0aW9uc2hpcHNDb25kaXRpb24+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJiYXNlQ2xhc3MiLCJpbml0aWFsUGFyYW1zIiwiZGVwdGgiLCJFbGVtZW50IiwicHJvcHMiLCJhdHRyaWJ1dGVzIiwiY2hpbGRyZW4iLCJlbGVtZW50IiwicmVsYXRpb25UbyIsInZhbHVlIiwiZmllbGRQcm9wcyIsImNvbGxlY3Rpb25zIiwicm91dGVzIiwiYXBpIiwic2VydmVyVVJMIiwidXNlQ29uZmlnIiwiZW5hYmxlZENvbGxlY3Rpb25TbHVncyIsInVzZVN0YXRlIiwiZmlsdGVyIiwiYWRtaW4iLCJlbmFibGVSaWNoVGV4dFJlbGF0aW9uc2hpcCIsIm1hcCIsInNsdWciLCJyZWxhdGVkQ29sbGVjdGlvbiIsInNldFJlbGF0ZWRDb2xsZWN0aW9uIiwiZmluZCIsImNvbGwiLCJzZWxlY3RlZCIsInVzZVNlbGVjdGVkIiwiZm9jdXNlZCIsInVzZUZvY3VzZWQiLCJpMThuIiwidCIsInVzZVRyYW5zbGF0aW9uIiwiZWRpdG9yIiwidXNlU2xhdGVTdGF0aWMiLCJjYWNoZUJ1c3QiLCJkaXNwYXRjaENhY2hlQnVzdCIsInVzZVJlZHVjZXIiLCJzdGF0ZSIsImRhdGEiLCJzZXRQYXJhbXMiLCJ1c2VQYXlsb2FkQVBJIiwiaWQiLCJEb2N1bWVudERyYXdlciIsIkRvY3VtZW50RHJhd2VyVG9nZ2xlciIsImNsb3NlRHJhd2VyIiwidXNlRG9jdW1lbnREcmF3ZXIiLCJjb2xsZWN0aW9uU2x1ZyIsIkxpc3REcmF3ZXIiLCJMaXN0RHJhd2VyVG9nZ2xlciIsImNsb3NlTGlzdERyYXdlciIsInVzZUxpc3REcmF3ZXIiLCJjb2xsZWN0aW9uU2x1Z3MiLCJzZWxlY3RlZENvbGxlY3Rpb24iLCJyZW1vdmVSZWxhdGlvbnNoaXAiLCJ1c2VDYWxsYmFjayIsImVsZW1lbnRQYXRoIiwiUmVhY3RFZGl0b3IiLCJmaW5kUGF0aCIsIlRyYW5zZm9ybXMiLCJyZW1vdmVOb2RlcyIsImF0IiwidXBkYXRlUmVsYXRpb25zaGlwIiwiUmVhY3QiLCJkb2MiLCJzZXROb2RlcyIsInRleHQiLCJ0eXBlIiwic3dhcFJlbGF0aW9uc2hpcCIsImNvbGxlY3Rpb25Db25maWciLCJkb2NJRCIsImRpdiIsImNsYXNzTmFtZSIsIkJvb2xlYW4iLCJqb2luIiwiY29udGVudEVkaXRhYmxlIiwicCIsImxhYmVsIiwiZ2V0VHJhbnNsYXRpb24iLCJsYWJlbHMiLCJzaW5ndWxhciIsInVzZUFzVGl0bGUiLCJkaXNhYmxlZCIsInJlYWRPbmx5IiwiQnV0dG9uIiwiYnV0dG9uU3R5bGUiLCJlbCIsImljb24iLCJvbkNsaWNrIiwicm91bmQiLCJ0b29sdGlwIiwiZSIsInByZXZlbnREZWZhdWx0Iiwib25TYXZlIiwib25TZWxlY3QiLCJFbmFibGVkUmVsYXRpb25zaGlwc0NvbmRpdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OytCQThMQTs7O2VBQUE7Ozs0QkExTHVCOzBCQUMwQjt1QkFDbkI7MkJBQ0o7NEJBQ0s7K0RBQzBCOzhCQUMxQjt1QkFDSjs0QkFDMEM7K0NBSXZCO1FBQ3ZDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRVAsTUFBTUEsWUFBWTtBQUVsQixNQUFNQyxnQkFBZ0I7SUFDcEJDLE9BQU87QUFDVDtBQVFBLE1BQU1DLFVBQTJCLENBQUNDO0lBQ2hDLE1BQU0sRUFDSkMsVUFBVSxFQUNWQyxRQUFRLEVBQ1JDLE9BQU8sRUFDUEEsU0FBUyxFQUFFQyxVQUFVLEVBQUVDLEtBQUssRUFBRSxFQUM5QkMsVUFBVSxFQUNYLEdBQUdOO0lBRUosTUFBTSxFQUNKTyxXQUFXLEVBQ1hDLFFBQVEsRUFBRUMsR0FBRyxFQUFFLEVBQ2ZDLFNBQVMsRUFDVixHQUFHQyxJQUFBQSxvQkFBUztJQUNiLE1BQU0sQ0FBQ0MsdUJBQXVCLEdBQUdDLElBQUFBLGVBQVEsRUFBQyxJQUN4Q04sWUFDR08sTUFBTSxDQUFDLENBQUMsRUFBRUMsT0FBTyxFQUFFQywwQkFBMEIsRUFBRSxFQUFFLEdBQUtBLDRCQUN0REMsR0FBRyxDQUFDLENBQUMsRUFBRUMsSUFBSSxFQUFFLEdBQUtBO0lBRXZCLE1BQU0sQ0FBQ0MsbUJBQW1CQyxxQkFBcUIsR0FBR1AsSUFBQUEsZUFBUSxFQUFDLElBQ3pETixZQUFZYyxJQUFJLENBQUMsQ0FBQ0MsT0FBU0EsS0FBS0osSUFBSSxLQUFLZDtJQUUzQyxNQUFNbUIsV0FBV0MsSUFBQUEsdUJBQVc7SUFDNUIsTUFBTUMsVUFBVUMsSUFBQUEsc0JBQVU7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