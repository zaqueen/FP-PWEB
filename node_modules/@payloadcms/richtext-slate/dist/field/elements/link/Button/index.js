'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "LinkButton", {
    enumerable: true,
    get: function() {
        return LinkButton;
    }
});
const _modal = require("@faceless-ui/modal");
const _elements = require("payload/components/elements");
const _forms = require("payload/components/forms");
const _utilities = require("payload/components/utilities");
const _config = require("payload/config");
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _slate = require("slate");
const _slatereact = require("slate-react");
const _Link = /*#__PURE__*/ _interop_require_default(require("../../../icons/Link"));
const _Button = /*#__PURE__*/ _interop_require_default(require("../../Button"));
const _isActive = /*#__PURE__*/ _interop_require_default(require("../../isActive"));
const _LinkDrawer = require("../LinkDrawer");
const _utilities1 = require("../utilities");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
/**
 * This function is called when an new link is created - not when an existing link is edited.
 */ const insertLink = (editor, fields)=>{
    const isCollapsed = editor.selection && _slate.Range.isCollapsed(editor.selection);
    const data = (0, _forms.reduceFieldsToValues)(fields, true);
    const newLink = {
        children: [],
        doc: data.doc,
        fields: data.fields,
        linkType: data.linkType,
        newTab: data.newTab,
        type: 'link',
        url: data.url
    };
    if (isCollapsed || !editor.selection) {
        // If selection anchor and focus are the same,
        // Just inject a new node with children already set
        _slate.Transforms.insertNodes(editor, {
            ...newLink,
            children: [
                {
                    text: String(data.text)
                }
            ]
        });
    } else if (editor.selection) {
        // Otherwise we need to wrap the selected node in a link,
        // Delete its old text,
        // Move the selection one position forward into the link,
        // And insert the text back into the new link
        _slate.Transforms.wrapNodes(editor, newLink, {
            split: true
        });
        _slate.Transforms.delete(editor, {
            at: editor.selection.focus.path,
            unit: 'word'
        });
        _slate.Transforms.move(editor, {
            distance: 1,
            unit: 'offset'
        });
        _slate.Transforms.insertText(editor, String(data.text), {
            at: editor.selection.focus.path
        });
    }
    _slatereact.ReactEditor.focus(editor);
};
const LinkButton = ({ fieldProps })=>{
    const customFieldSchema = fieldProps?.admin?.link?.fields;
    const { user } = (0, _utilities.useAuth)();
    const { code: locale } = (0, _utilities.useLocale)();
    const [initialState, setInitialState] = (0, _react.useState)({});
    const { i18n, t } = (0, _reacti18next.useTranslation)([
        'upload',
        'general'
    ]);
    const editor = (0, _slatereact.useSlate)();
    const config = (0, _utilities.useConfig)();
    const [fieldSchema] = (0, _react.useState)(()=>{
        const fieldsUnsanitized = (0, _utilities1.transformExtraFields)(customFieldSchema, config, i18n);
        // Sanitize custom fields here
        const validRelationships = config.collections.map((c)=>c.slug) || [];
        const fields = (0, _config.sanitizeFields)({
            config: config,
            fields: fieldsUnsanitized,
            validRelationships
        });
        return fields;
    });
    const { closeModal, openModal } = (0, _modal.useModal)();
    const drawerSlug = (0, _elements.useDrawerSlug)('rich-text-link');
    const { getDocPreferences } = (0, _utilities.useDocumentInfo)();
    return /*#__PURE__*/ _react.default.createElement(_react.Fragment, null, /*#__PURE__*/ _react.default.createElement(_Button.default, {
        className: "link",
        format: "link",
        onClick: async ()=>{
            if ((0, _isActive.default)(editor, 'link')) {
                (0, _utilities1.unwrapLink)(editor);
            } else {
                openModal(drawerSlug);
                const isCollapsed = editor.selection && _slate.Range.isCollapsed(editor.selection);
                if (!isCollapsed) {
                    const data = {
                        text: editor.selection ? _slate.Editor.string(editor, editor.selection) : ''
                    };
                    const preferences = await getDocPreferences();
                    const state = await (0, _utilities.buildStateFromSchema)({
                        config,
                        data,
                        fieldSchema,
                        locale,
                        operation: 'create',
                        preferences,
                        t,
                        user
                    });
                    setInitialState(state);
                }
            }
        },
        tooltip: t('fields:addLink')
    }, /*#__PURE__*/ _react.default.createElement(_Link.default, null)), /*#__PURE__*/ _react.default.createElement(_LinkDrawer.LinkDrawer, {
        drawerSlug: drawerSlug,
        fieldSchema: fieldSchema,
        handleClose: ()=>{
            closeModal(drawerSlug);
        },
        handleModalSubmit: (fields)=>{
            insertLink(editor, fields);
            closeModal(drawerSlug);
        },
        initialState: initialState
    }));
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9maWVsZC9lbGVtZW50cy9saW5rL0J1dHRvbi9pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbmltcG9ydCB0eXBlIHsgRmllbGRzIH0gZnJvbSAncGF5bG9hZC90eXBlcydcblxuaW1wb3J0IHsgdXNlTW9kYWwgfSBmcm9tICdAZmFjZWxlc3MtdWkvbW9kYWwnXG5pbXBvcnQgeyB1c2VEcmF3ZXJTbHVnIH0gZnJvbSAncGF5bG9hZC9jb21wb25lbnRzL2VsZW1lbnRzJ1xuaW1wb3J0IHsgcmVkdWNlRmllbGRzVG9WYWx1ZXMgfSBmcm9tICdwYXlsb2FkL2NvbXBvbmVudHMvZm9ybXMnXG5pbXBvcnQge1xuICBidWlsZFN0YXRlRnJvbVNjaGVtYSxcbiAgdXNlQXV0aCxcbiAgdXNlQ29uZmlnLFxuICB1c2VEb2N1bWVudEluZm8sXG4gIHVzZUxvY2FsZSxcbn0gZnJvbSAncGF5bG9hZC9jb21wb25lbnRzL3V0aWxpdGllcydcbmltcG9ydCB7IHNhbml0aXplRmllbGRzIH0gZnJvbSAncGF5bG9hZC9jb25maWcnXG5pbXBvcnQgUmVhY3QsIHsgRnJhZ21lbnQsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VUcmFuc2xhdGlvbiB9IGZyb20gJ3JlYWN0LWkxOG5leHQnXG5pbXBvcnQgeyBFZGl0b3IsIFJhbmdlLCBUcmFuc2Zvcm1zIH0gZnJvbSAnc2xhdGUnXG5pbXBvcnQgeyBSZWFjdEVkaXRvciwgdXNlU2xhdGUgfSBmcm9tICdzbGF0ZS1yZWFjdCdcblxuaW1wb3J0IHR5cGUgeyBGaWVsZFByb3BzIH0gZnJvbSAnLi4vLi4vLi4vLi4vdHlwZXMnXG5cbmltcG9ydCBMaW5rSWNvbiBmcm9tICcuLi8uLi8uLi9pY29ucy9MaW5rJ1xuaW1wb3J0IEVsZW1lbnRCdXR0b24gZnJvbSAnLi4vLi4vQnV0dG9uJ1xuaW1wb3J0IGlzRWxlbWVudEFjdGl2ZSBmcm9tICcuLi8uLi9pc0FjdGl2ZSdcbmltcG9ydCB7IExpbmtEcmF3ZXIgfSBmcm9tICcuLi9MaW5rRHJhd2VyJ1xuaW1wb3J0IHsgdHJhbnNmb3JtRXh0cmFGaWVsZHMsIHVud3JhcExpbmsgfSBmcm9tICcuLi91dGlsaXRpZXMnXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhbiBuZXcgbGluayBpcyBjcmVhdGVkIC0gbm90IHdoZW4gYW4gZXhpc3RpbmcgbGluayBpcyBlZGl0ZWQuXG4gKi9cbmNvbnN0IGluc2VydExpbmsgPSAoZWRpdG9yLCBmaWVsZHMpID0+IHtcbiAgY29uc3QgaXNDb2xsYXBzZWQgPSBlZGl0b3Iuc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKGVkaXRvci5zZWxlY3Rpb24pXG4gIGNvbnN0IGRhdGEgPSByZWR1Y2VGaWVsZHNUb1ZhbHVlcyhmaWVsZHMsIHRydWUpXG5cbiAgY29uc3QgbmV3TGluayA9IHtcbiAgICBjaGlsZHJlbjogW10sXG4gICAgZG9jOiBkYXRhLmRvYyxcbiAgICBmaWVsZHM6IGRhdGEuZmllbGRzLCAvLyBBbnkgY3VzdG9tIHVzZXItYWRkZWQgZmllbGRzIGFyZSBwYXJ0IG9mIGRhdGEuZmllbGRzXG4gICAgbGlua1R5cGU6IGRhdGEubGlua1R5cGUsXG4gICAgbmV3VGFiOiBkYXRhLm5ld1RhYixcbiAgICB0eXBlOiAnbGluaycsXG4gICAgdXJsOiBkYXRhLnVybCxcbiAgfVxuXG4gIGlmIChpc0NvbGxhcHNlZCB8fCAhZWRpdG9yLnNlbGVjdGlvbikge1xuICAgIC8vIElmIHNlbGVjdGlvbiBhbmNob3IgYW5kIGZvY3VzIGFyZSB0aGUgc2FtZSxcbiAgICAvLyBKdXN0IGluamVjdCBhIG5ldyBub2RlIHdpdGggY2hpbGRyZW4gYWxyZWFkeSBzZXRcbiAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwge1xuICAgICAgLi4ubmV3TGluayxcbiAgICAgIGNoaWxkcmVuOiBbeyB0ZXh0OiBTdHJpbmcoZGF0YS50ZXh0KSB9XSxcbiAgICB9KVxuICB9IGVsc2UgaWYgKGVkaXRvci5zZWxlY3Rpb24pIHtcbiAgICAvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byB3cmFwIHRoZSBzZWxlY3RlZCBub2RlIGluIGEgbGluayxcbiAgICAvLyBEZWxldGUgaXRzIG9sZCB0ZXh0LFxuICAgIC8vIE1vdmUgdGhlIHNlbGVjdGlvbiBvbmUgcG9zaXRpb24gZm9yd2FyZCBpbnRvIHRoZSBsaW5rLFxuICAgIC8vIEFuZCBpbnNlcnQgdGhlIHRleHQgYmFjayBpbnRvIHRoZSBuZXcgbGlua1xuICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwgbmV3TGluaywgeyBzcGxpdDogdHJ1ZSB9KVxuICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwgeyBhdDogZWRpdG9yLnNlbGVjdGlvbi5mb2N1cy5wYXRoLCB1bml0OiAnd29yZCcgfSlcbiAgICBUcmFuc2Zvcm1zLm1vdmUoZWRpdG9yLCB7IGRpc3RhbmNlOiAxLCB1bml0OiAnb2Zmc2V0JyB9KVxuICAgIFRyYW5zZm9ybXMuaW5zZXJ0VGV4dChlZGl0b3IsIFN0cmluZyhkYXRhLnRleHQpLCB7IGF0OiBlZGl0b3Iuc2VsZWN0aW9uLmZvY3VzLnBhdGggfSlcbiAgfVxuXG4gIFJlYWN0RWRpdG9yLmZvY3VzKGVkaXRvcilcbn1cblxuZXhwb3J0IGNvbnN0IExpbmtCdXR0b246IFJlYWN0LkZDPHtcbiAgZmllbGRQcm9wczogRmllbGRQcm9wc1xuICBwYXRoOiBzdHJpbmdcbn0+ID0gKHsgZmllbGRQcm9wcyB9KSA9PiB7XG4gIGNvbnN0IGN1c3RvbUZpZWxkU2NoZW1hID0gZmllbGRQcm9wcz8uYWRtaW4/Lmxpbms/LmZpZWxkc1xuICBjb25zdCB7IHVzZXIgfSA9IHVzZUF1dGgoKVxuICBjb25zdCB7IGNvZGU6IGxvY2FsZSB9ID0gdXNlTG9jYWxlKClcbiAgY29uc3QgW2luaXRpYWxTdGF0ZSwgc2V0SW5pdGlhbFN0YXRlXSA9IHVzZVN0YXRlPEZpZWxkcz4oe30pXG5cbiAgY29uc3QgeyBpMThuLCB0IH0gPSB1c2VUcmFuc2xhdGlvbihbJ3VwbG9hZCcsICdnZW5lcmFsJ10pXG4gIGNvbnN0IGVkaXRvciA9IHVzZVNsYXRlKClcbiAgY29uc3QgY29uZmlnID0gdXNlQ29uZmlnKClcblxuICBjb25zdCBbZmllbGRTY2hlbWFdID0gdXNlU3RhdGUoKCkgPT4ge1xuICAgIGNvbnN0IGZpZWxkc1Vuc2FuaXRpemVkID0gdHJhbnNmb3JtRXh0cmFGaWVsZHMoY3VzdG9tRmllbGRTY2hlbWEsIGNvbmZpZywgaTE4bilcbiAgICAvLyBTYW5pdGl6ZSBjdXN0b20gZmllbGRzIGhlcmVcbiAgICBjb25zdCB2YWxpZFJlbGF0aW9uc2hpcHMgPSBjb25maWcuY29sbGVjdGlvbnMubWFwKChjKSA9PiBjLnNsdWcpIHx8IFtdXG4gICAgY29uc3QgZmllbGRzID0gc2FuaXRpemVGaWVsZHMoe1xuICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICBmaWVsZHM6IGZpZWxkc1Vuc2FuaXRpemVkLFxuICAgICAgdmFsaWRSZWxhdGlvbnNoaXBzLFxuICAgIH0pXG5cbiAgICByZXR1cm4gZmllbGRzXG4gIH0pXG5cbiAgY29uc3QgeyBjbG9zZU1vZGFsLCBvcGVuTW9kYWwgfSA9IHVzZU1vZGFsKClcbiAgY29uc3QgZHJhd2VyU2x1ZyA9IHVzZURyYXdlclNsdWcoJ3JpY2gtdGV4dC1saW5rJylcbiAgY29uc3QgeyBnZXREb2NQcmVmZXJlbmNlcyB9ID0gdXNlRG9jdW1lbnRJbmZvKClcblxuICByZXR1cm4gKFxuICAgIDxGcmFnbWVudD5cbiAgICAgIDxFbGVtZW50QnV0dG9uXG4gICAgICAgIGNsYXNzTmFtZT1cImxpbmtcIlxuICAgICAgICBmb3JtYXQ9XCJsaW5rXCJcbiAgICAgICAgb25DbGljaz17YXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmIChpc0VsZW1lbnRBY3RpdmUoZWRpdG9yLCAnbGluaycpKSB7XG4gICAgICAgICAgICB1bndyYXBMaW5rKGVkaXRvcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3Blbk1vZGFsKGRyYXdlclNsdWcpXG5cbiAgICAgICAgICAgIGNvbnN0IGlzQ29sbGFwc2VkID0gZWRpdG9yLnNlbGVjdGlvbiAmJiBSYW5nZS5pc0NvbGxhcHNlZChlZGl0b3Iuc2VsZWN0aW9uKVxuXG4gICAgICAgICAgICBpZiAoIWlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogZWRpdG9yLnNlbGVjdGlvbiA/IEVkaXRvci5zdHJpbmcoZWRpdG9yLCBlZGl0b3Iuc2VsZWN0aW9uKSA6ICcnLFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY29uc3QgcHJlZmVyZW5jZXMgPSBhd2FpdCBnZXREb2NQcmVmZXJlbmNlcygpXG4gICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gYXdhaXQgYnVpbGRTdGF0ZUZyb21TY2hlbWEoe1xuICAgICAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGZpZWxkU2NoZW1hLFxuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246ICdjcmVhdGUnLFxuICAgICAgICAgICAgICAgIHByZWZlcmVuY2VzLFxuICAgICAgICAgICAgICAgIHQsXG4gICAgICAgICAgICAgICAgdXNlcixcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgc2V0SW5pdGlhbFN0YXRlKHN0YXRlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfX1cbiAgICAgICAgdG9vbHRpcD17dCgnZmllbGRzOmFkZExpbmsnKX1cbiAgICAgID5cbiAgICAgICAgPExpbmtJY29uIC8+XG4gICAgICA8L0VsZW1lbnRCdXR0b24+XG4gICAgICA8TGlua0RyYXdlclxuICAgICAgICBkcmF3ZXJTbHVnPXtkcmF3ZXJTbHVnfVxuICAgICAgICBmaWVsZFNjaGVtYT17ZmllbGRTY2hlbWF9XG4gICAgICAgIGhhbmRsZUNsb3NlPXsoKSA9PiB7XG4gICAgICAgICAgY2xvc2VNb2RhbChkcmF3ZXJTbHVnKVxuICAgICAgICB9fVxuICAgICAgICBoYW5kbGVNb2RhbFN1Ym1pdD17KGZpZWxkcykgPT4ge1xuICAgICAgICAgIGluc2VydExpbmsoZWRpdG9yLCBmaWVsZHMpXG4gICAgICAgICAgY2xvc2VNb2RhbChkcmF3ZXJTbHVnKVxuICAgICAgICB9fVxuICAgICAgICBpbml0aWFsU3RhdGU9e2luaXRpYWxTdGF0ZX1cbiAgICAgIC8+XG4gICAgPC9GcmFnbWVudD5cbiAgKVxufVxuIl0sIm5hbWVzIjpbIkxpbmtCdXR0b24iLCJpbnNlcnRMaW5rIiwiZWRpdG9yIiwiZmllbGRzIiwiaXNDb2xsYXBzZWQiLCJzZWxlY3Rpb24iLCJSYW5nZSIsImRhdGEiLCJyZWR1Y2VGaWVsZHNUb1ZhbHVlcyIsIm5ld0xpbmsiLCJjaGlsZHJlbiIsImRvYyIsImxpbmtUeXBlIiwibmV3VGFiIiwidHlwZSIsInVybCIsIlRyYW5zZm9ybXMiLCJpbnNlcnROb2RlcyIsInRleHQiLCJTdHJpbmciLCJ3cmFwTm9kZXMiLCJzcGxpdCIsImRlbGV0ZSIsImF0IiwiZm9jdXMiLCJwYXRoIiwidW5pdCIsIm1vdmUiLCJkaXN0YW5jZSIsImluc2VydFRleHQiLCJSZWFjdEVkaXRvciIsImZpZWxkUHJvcHMiLCJjdXN0b21GaWVsZFNjaGVtYSIsImFkbWluIiwibGluayIsInVzZXIiLCJ1c2VBdXRoIiwiY29kZSIsImxvY2FsZSIsInVzZUxvY2FsZSIsImluaXRpYWxTdGF0ZSIsInNldEluaXRpYWxTdGF0ZSIsInVzZVN0YXRlIiwiaTE4biIsInQiLCJ1c2VUcmFuc2xhdGlvbiIsInVzZVNsYXRlIiwiY29uZmlnIiwidXNlQ29uZmlnIiwiZmllbGRTY2hlbWEiLCJmaWVsZHNVbnNhbml0aXplZCIsInRyYW5zZm9ybUV4dHJhRmllbGRzIiwidmFsaWRSZWxhdGlvbnNoaXBzIiwiY29sbGVjdGlvbnMiLCJtYXAiLCJjIiwic2x1ZyIsInNhbml0aXplRmllbGRzIiwiY2xvc2VNb2RhbCIsIm9wZW5Nb2RhbCIsInVzZU1vZGFsIiwiZHJhd2VyU2x1ZyIsInVzZURyYXdlclNsdWciLCJnZXREb2NQcmVmZXJlbmNlcyIsInVzZURvY3VtZW50SW5mbyIsIkZyYWdtZW50IiwiRWxlbWVudEJ1dHRvbiIsImNsYXNzTmFtZSIsImZvcm1hdCIsIm9uQ2xpY2siLCJpc0VsZW1lbnRBY3RpdmUiLCJ1bndyYXBMaW5rIiwiRWRpdG9yIiwic3RyaW5nIiwicHJlZmVyZW5jZXMiLCJzdGF0ZSIsImJ1aWxkU3RhdGVGcm9tU2NoZW1hIiwib3BlcmF0aW9uIiwidG9vbHRpcCIsIkxpbmtJY29uIiwiTGlua0RyYXdlciIsImhhbmRsZUNsb3NlIiwiaGFuZGxlTW9kYWxTdWJtaXQiXSwibWFwcGluZ3MiOiJBQUFBOzs7OzsrQkFrRWFBOzs7ZUFBQUE7Ozt1QkE5RFk7MEJBQ0s7dUJBQ087MkJBTzlCO3dCQUN3QjsrREFDVzs4QkFDWDt1QkFDVzs0QkFDSjs2REFJakI7K0RBQ0s7aUVBQ0U7NEJBQ0Q7NEJBQ3NCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFakQ7O0NBRUMsR0FDRCxNQUFNQyxhQUFhLENBQUNDLFFBQVFDO0lBQzFCLE1BQU1DLGNBQWNGLE9BQU9HLFNBQVMsSUFBSUMsWUFBSyxDQUFDRixXQUFXLENBQUNGLE9BQU9HLFNBQVM7SUFDMUUsTUFBTUUsT0FBT0MsSUFBQUEsMkJBQW9CLEVBQUNMLFFBQVE7SUFFMUMsTUFBTU0sVUFBVTtRQUNkQyxVQUFVLEVBQUU7UUFDWkMsS0FBS0osS0FBS0ksR0FBRztRQUNiUixRQUFRSSxLQUFLSixNQUFNO1FBQ25CUyxVQUFVTCxLQUFLSyxRQUFRO1FBQ3ZCQyxRQUFRTixLQUFLTSxNQUFNO1FBQ25CQyxNQUFNO1FBQ05DLEtBQUtSLEtBQUtRLEdBQUc7SUFDZjtJQUVBLElBQUlYLGVBQWUsQ0FBQ0YsT0FBT0csU0FBUyxFQUFFO1FBQ3BD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