"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _slate = require("slate");
const _slatereact = require("slate-react");
const _IndentLeft = /*#__PURE__*/ _interop_require_default(require("../../icons/IndentLeft"));
const _IndentRight = /*#__PURE__*/ _interop_require_default(require("../../icons/IndentRight"));
const _Button = require("../Button");
const _getCommonBlock = require("../getCommonBlock");
const _isActive = /*#__PURE__*/ _interop_require_default(require("../isActive"));
const _isBlockElement = require("../isBlockElement");
const _listTypes = /*#__PURE__*/ _interop_require_default(require("../listTypes"));
const _unwrapList = require("../unwrapList");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const indentType = 'indent';
const IndentWithPadding = ({ attributes, children })=>/*#__PURE__*/ _react.default.createElement("div", {
        style: {
            paddingLeft: 25
        },
        ...attributes
    }, children);
const indent = {
    Button: ()=>{
        const editor = (0, _slatereact.useSlate)();
        const handleIndent = (0, _react.useCallback)((e, dir)=>{
            e.preventDefault();
            if (dir === 'left') {
                if ((0, _isActive.default)(editor, 'li')) {
                    const [, listPath] = (0, _getCommonBlock.getCommonBlock)(editor, (n)=>_slate.Element.isElement(n) && _listTypes.default.includes(n.type));
                    const matchedParentList = _slate.Editor.above(editor, {
                        at: listPath,
                        match: (n)=>!_slate.Editor.isEditor(n) && (0, _isBlockElement.isBlockElement)(editor, n)
                    });
                    if (matchedParentList) {
                        const [parentListItem, parentListItemPath] = matchedParentList;
                        if (parentListItem.children.length > 1) {
                            // Remove nested list
                            _slate.Transforms.unwrapNodes(editor, {
                                at: parentListItemPath,
                                match: (node, path)=>{
                                    const matches = !_slate.Editor.isEditor(node) && _slate.Element.isElement(node) && _listTypes.default.includes(node.type) && path.length === parentListItemPath.length + 1;
                                    return matches;
                                }
                            });
                            // Set li type on any children that don't have a type
                            _slate.Transforms.setNodes(editor, {
                                type: 'li'
                            }, {
                                at: parentListItemPath,
                                match: (node, path)=>{
                                    const matches = !_slate.Editor.isEditor(node) && _slate.Element.isElement(node) && node.type !== 'li' && path.length === parentListItemPath.length + 1;
                                    return matches;
                                }
                            });
                            // Parent list item path has changed at this point
                            // so we need to re-fetch the parent node
                            const [newParentNode] = _slate.Editor.node(editor, parentListItemPath);
                            // If the parent node is an li,
                            // lift all li nodes within
                            if (_slate.Element.isElement(newParentNode) && newParentNode.type === 'li') {
                                // Lift the nested lis
                                _slate.Transforms.liftNodes(editor, {
                                    at: parentListItemPath,
                                    match: (node, path)=>{
                                        const matches = !_slate.Editor.isEditor(node) && _slate.Element.isElement(node) && path.length === parentListItemPath.length + 1 && node.type === 'li';
                                        return matches;
                                    }
                                });
                            }
                        } else {
                            _slate.Transforms.unwrapNodes(editor, {
                                at: parentListItemPath,
                                match: (node, path)=>{
                                    return _slate.Element.isElement(node) && node.type === 'li' && path.length === parentListItemPath.length;
                                }
                            });
                            _slate.Transforms.unwrapNodes(editor, {
                                match: (n)=>_slate.Element.isElement(n) && _listTypes.default.includes(n.type)
                            });
                        }
                    } else {
                        (0, _unwrapList.unwrapList)(editor, listPath);
                    }
                } else {
                    _slate.Transforms.unwrapNodes(editor, {
                        match: (n)=>_slate.Element.isElement(n) && n.type === indentType,
                        mode: 'lowest',
                        split: true
                    });
                }
            }
            if (dir === 'right') {
                const isCurrentlyOL = (0, _isActive.default)(editor, 'ol');
                const isCurrentlyUL = (0, _isActive.default)(editor, 'ul');
                if (isCurrentlyOL || isCurrentlyUL) {
                    // Get the path of the first selected li -
                    // Multiple lis could be selected
                    // and the selection may start in the middle of the first li
                    const [[, firstSelectedLIPath]] = Array.from(_slate.Editor.nodes(editor, {
                        match: (node)=>_slate.Element.isElement(node) && node.type === 'li',
                        mode: 'lowest'
                    }));
                    // Is the first selected li the first in its list?
                    const hasPrecedingLI = firstSelectedLIPath[firstSelectedLIPath.length - 1] > 0;
                    // If the first selected li is NOT the first in its list,
                    // we need to inject it into the prior li
                    if (hasPrecedingLI) {
                        const [, precedingLIPath] = _slate.Editor.previous(editor, {
                            at: firstSelectedLIPath
                        });
                        const [precedingLIChildren] = _slate.Editor.node(editor, [
                            ...precedingLIPath,
                            0
                        ]);
                        const precedingLIChildrenIsText = _slate.Text.isText(precedingLIChildren);
                        if (precedingLIChildrenIsText) {
                            // Wrap the prior li text content so that it can be nested next to a list
                            _slate.Transforms.wrapNodes(editor, {
                                children: []
                            }, {
                                at: [
                                    ...precedingLIPath,
                                    0
                                ]
                            });
                        }
                        // Move the selected lis after the prior li contents
                        _slate.Transforms.moveNodes(editor, {
                            match: (node)=>_slate.Element.isElement(node) && node.type === 'li',
                            mode: 'lowest',
                            to: [
                                ...precedingLIPath,
                                1
                            ]
                        });
                        // Wrap the selected lis in a new list
                        _slate.Transforms.wrapNodes(editor, {
                            children: [],
                            type: isCurrentlyOL ? 'ol' : 'ul'
                        }, {
                            match: (node)=>_slate.Element.isElement(node) && node.type === 'li',
                            mode: 'lowest'
                        });
                    } else {
                        // Otherwise, just wrap the node in a list / li
                        _slate.Transforms.wrapNodes(editor, {
                            children: [
                                {
                                    children: [],
                                    type: 'li'
                                }
                            ],
                            type: isCurrentlyOL ? 'ol' : 'ul'
                        }, {
                            match: (node)=>_slate.Element.isElement(node) && node.type === 'li',
                            mode: 'lowest'
                        });
                    }
                } else {
                    _slate.Transforms.wrapNodes(editor, {
                        children: [],
                        type: indentType
                    });
                }
            }
            _slatereact.ReactEditor.focus(editor);
        }, [
            editor
        ]);
        const canDeIndent = (0, _isActive.default)(editor, 'li') || (0, _isActive.default)(editor, indentType);
        return /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement("button", {
            className: [
                _Button.baseClass,
                !canDeIndent && `${_Button.baseClass}--disabled`
            ].filter(Boolean).join(' '),
            onClick: canDeIndent ? (e)=>handleIndent(e, 'left') : undefined,
            type: "button"
        }, /*#__PURE__*/ _react.default.createElement(_IndentLeft.default, null)), /*#__PURE__*/ _react.default.createElement("button", {
            className: _Button.baseClass,
            onClick: (e)=>handleIndent(e, 'right'),
            type: "button"
        }, /*#__PURE__*/ _react.default.createElement(_IndentRight.default, null)));
    },
    Element: IndentWithPadding
};
const _default = indent;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9maWVsZC9lbGVtZW50cy9pbmRlbnQvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgRWRpdG9yLCBFbGVtZW50LCBUZXh0LCBUcmFuc2Zvcm1zIH0gZnJvbSAnc2xhdGUnXG5pbXBvcnQgeyBSZWFjdEVkaXRvciwgdXNlU2xhdGUgfSBmcm9tICdzbGF0ZS1yZWFjdCdcblxuaW1wb3J0IHR5cGUgeyBFbGVtZW50Tm9kZSB9IGZyb20gJy4uLy4uLy4uL3R5cGVzJ1xuXG5pbXBvcnQgSW5kZW50TGVmdCBmcm9tICcuLi8uLi9pY29ucy9JbmRlbnRMZWZ0J1xuaW1wb3J0IEluZGVudFJpZ2h0IGZyb20gJy4uLy4uL2ljb25zL0luZGVudFJpZ2h0J1xuaW1wb3J0IHsgYmFzZUNsYXNzIH0gZnJvbSAnLi4vQnV0dG9uJ1xuaW1wb3J0IHsgZ2V0Q29tbW9uQmxvY2sgfSBmcm9tICcuLi9nZXRDb21tb25CbG9jaydcbmltcG9ydCBpc0VsZW1lbnRBY3RpdmUgZnJvbSAnLi4vaXNBY3RpdmUnXG5pbXBvcnQgeyBpc0Jsb2NrRWxlbWVudCB9IGZyb20gJy4uL2lzQmxvY2tFbGVtZW50J1xuaW1wb3J0IGxpc3RUeXBlcyBmcm9tICcuLi9saXN0VHlwZXMnXG5pbXBvcnQgeyB1bndyYXBMaXN0IH0gZnJvbSAnLi4vdW53cmFwTGlzdCdcblxuY29uc3QgaW5kZW50VHlwZSA9ICdpbmRlbnQnXG5cbmNvbnN0IEluZGVudFdpdGhQYWRkaW5nID0gKHsgYXR0cmlidXRlcywgY2hpbGRyZW4gfSkgPT4gKFxuICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmdMZWZ0OiAyNSB9fSB7Li4uYXR0cmlidXRlc30+XG4gICAge2NoaWxkcmVufVxuICA8L2Rpdj5cbilcblxuY29uc3QgaW5kZW50ID0ge1xuICBCdXR0b246ICgpID0+IHtcbiAgICBjb25zdCBlZGl0b3IgPSB1c2VTbGF0ZSgpXG4gICAgY29uc3QgaGFuZGxlSW5kZW50ID0gdXNlQ2FsbGJhY2soXG4gICAgICAoZSwgZGlyKSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgICAgIGlmIChkaXIgPT09ICdsZWZ0Jykge1xuICAgICAgICAgIGlmIChpc0VsZW1lbnRBY3RpdmUoZWRpdG9yLCAnbGknKSkge1xuICAgICAgICAgICAgY29uc3QgWywgbGlzdFBhdGhdID0gZ2V0Q29tbW9uQmxvY2soXG4gICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgKG4pID0+IEVsZW1lbnQuaXNFbGVtZW50KG4pICYmIGxpc3RUeXBlcy5pbmNsdWRlcyhuLnR5cGUpLFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBjb25zdCBtYXRjaGVkUGFyZW50TGlzdCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IGxpc3RQYXRoLFxuICAgICAgICAgICAgICBtYXRjaDogKG46IEVsZW1lbnROb2RlKSA9PiAhRWRpdG9yLmlzRWRpdG9yKG4pICYmIGlzQmxvY2tFbGVtZW50KGVkaXRvciwgbiksXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBpZiAobWF0Y2hlZFBhcmVudExpc3QpIHtcbiAgICAgICAgICAgICAgY29uc3QgW3BhcmVudExpc3RJdGVtLCBwYXJlbnRMaXN0SXRlbVBhdGhdID0gbWF0Y2hlZFBhcmVudExpc3RcblxuICAgICAgICAgICAgICBpZiAocGFyZW50TGlzdEl0ZW0uY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBuZXN0ZWQgbGlzdFxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBhdDogcGFyZW50TGlzdEl0ZW1QYXRoLFxuICAgICAgICAgICAgICAgICAgbWF0Y2g6IChub2RlLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICFFZGl0b3IuaXNFZGl0b3Iobm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgIGxpc3RUeXBlcy5pbmNsdWRlcyhub2RlLnR5cGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgcGF0aC5sZW5ndGggPT09IHBhcmVudExpc3RJdGVtUGF0aC5sZW5ndGggKyAxXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIC8vIFNldCBsaSB0eXBlIG9uIGFueSBjaGlsZHJlbiB0aGF0IGRvbid0IGhhdmUgYSB0eXBlXG4gICAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhcbiAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgIHsgdHlwZTogJ2xpJyB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBhdDogcGFyZW50TGlzdEl0ZW1QYXRoLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaDogKG5vZGUsIHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICFFZGl0b3IuaXNFZGl0b3Iobm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnR5cGUgIT09ICdsaScgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgubGVuZ3RoID09PSBwYXJlbnRMaXN0SXRlbVBhdGgubGVuZ3RoICsgMVxuXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgLy8gUGFyZW50IGxpc3QgaXRlbSBwYXRoIGhhcyBjaGFuZ2VkIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHJlLWZldGNoIHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgICAgICAgIGNvbnN0IFtuZXdQYXJlbnROb2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGFyZW50TGlzdEl0ZW1QYXRoKVxuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHBhcmVudCBub2RlIGlzIGFuIGxpLFxuICAgICAgICAgICAgICAgIC8vIGxpZnQgYWxsIGxpIG5vZGVzIHdpdGhpblxuICAgICAgICAgICAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChuZXdQYXJlbnROb2RlKSAmJiBuZXdQYXJlbnROb2RlLnR5cGUgPT09ICdsaScpIHtcbiAgICAgICAgICAgICAgICAgIC8vIExpZnQgdGhlIG5lc3RlZCBsaXNcbiAgICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMubGlmdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgICBhdDogcGFyZW50TGlzdEl0ZW1QYXRoLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaDogKG5vZGUsIHBhdGgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICFFZGl0b3IuaXNFZGl0b3Iobm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoLmxlbmd0aCA9PT0gcGFyZW50TGlzdEl0ZW1QYXRoLmxlbmd0aCArIDEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9PT0gJ2xpJ1xuXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgICBhdDogcGFyZW50TGlzdEl0ZW1QYXRoLFxuICAgICAgICAgICAgICAgICAgbWF0Y2g6IChub2RlLCBwYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgICAgICAgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICBub2RlLnR5cGUgPT09ICdsaScgJiZcbiAgICAgICAgICAgICAgICAgICAgICBwYXRoLmxlbmd0aCA9PT0gcGFyZW50TGlzdEl0ZW1QYXRoLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgICAgbWF0Y2g6IChuKSA9PiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiBsaXN0VHlwZXMuaW5jbHVkZXMobi50eXBlKSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bndyYXBMaXN0KGVkaXRvciwgbGlzdFBhdGgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMudW53cmFwTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgIG1hdGNoOiAobikgPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgbi50eXBlID09PSBpbmRlbnRUeXBlLFxuICAgICAgICAgICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgICAgICAgICAgc3BsaXQ6IHRydWUsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXIgPT09ICdyaWdodCcpIHtcbiAgICAgICAgICBjb25zdCBpc0N1cnJlbnRseU9MID0gaXNFbGVtZW50QWN0aXZlKGVkaXRvciwgJ29sJylcbiAgICAgICAgICBjb25zdCBpc0N1cnJlbnRseVVMID0gaXNFbGVtZW50QWN0aXZlKGVkaXRvciwgJ3VsJylcblxuICAgICAgICAgIGlmIChpc0N1cnJlbnRseU9MIHx8IGlzQ3VycmVudGx5VUwpIHtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcGF0aCBvZiB0aGUgZmlyc3Qgc2VsZWN0ZWQgbGkgLVxuICAgICAgICAgICAgLy8gTXVsdGlwbGUgbGlzIGNvdWxkIGJlIHNlbGVjdGVkXG4gICAgICAgICAgICAvLyBhbmQgdGhlIHNlbGVjdGlvbiBtYXkgc3RhcnQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgZmlyc3QgbGlcbiAgICAgICAgICAgIGNvbnN0IFtbLCBmaXJzdFNlbGVjdGVkTElQYXRoXV0gPSBBcnJheS5mcm9tKFxuICAgICAgICAgICAgICBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdsaScsXG4gICAgICAgICAgICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAvLyBJcyB0aGUgZmlyc3Qgc2VsZWN0ZWQgbGkgdGhlIGZpcnN0IGluIGl0cyBsaXN0P1xuICAgICAgICAgICAgY29uc3QgaGFzUHJlY2VkaW5nTEkgPSBmaXJzdFNlbGVjdGVkTElQYXRoW2ZpcnN0U2VsZWN0ZWRMSVBhdGgubGVuZ3RoIC0gMV0gPiAwXG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBmaXJzdCBzZWxlY3RlZCBsaSBpcyBOT1QgdGhlIGZpcnN0IGluIGl0cyBsaXN0LFxuICAgICAgICAgICAgLy8gd2UgbmVlZCB0byBpbmplY3QgaXQgaW50byB0aGUgcHJpb3IgbGlcbiAgICAgICAgICAgIGlmIChoYXNQcmVjZWRpbmdMSSkge1xuICAgICAgICAgICAgICBjb25zdCBbLCBwcmVjZWRpbmdMSVBhdGhdID0gRWRpdG9yLnByZXZpb3VzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBmaXJzdFNlbGVjdGVkTElQYXRoLFxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIGNvbnN0IFtwcmVjZWRpbmdMSUNoaWxkcmVuXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgWy4uLnByZWNlZGluZ0xJUGF0aCwgMF0pXG4gICAgICAgICAgICAgIGNvbnN0IHByZWNlZGluZ0xJQ2hpbGRyZW5Jc1RleHQgPSBUZXh0LmlzVGV4dChwcmVjZWRpbmdMSUNoaWxkcmVuKVxuXG4gICAgICAgICAgICAgIGlmIChwcmVjZWRpbmdMSUNoaWxkcmVuSXNUZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gV3JhcCB0aGUgcHJpb3IgbGkgdGV4dCBjb250ZW50IHNvIHRoYXQgaXQgY2FuIGJlIG5lc3RlZCBuZXh0IHRvIGEgbGlzdFxuICAgICAgICAgICAgICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwgeyBjaGlsZHJlbjogW10gfSwgeyBhdDogWy4uLnByZWNlZGluZ0xJUGF0aCwgMF0gfSlcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIE1vdmUgdGhlIHNlbGVjdGVkIGxpcyBhZnRlciB0aGUgcHJpb3IgbGkgY29udGVudHNcbiAgICAgICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdsaScsXG4gICAgICAgICAgICAgICAgbW9kZTogJ2xvd2VzdCcsXG4gICAgICAgICAgICAgICAgdG86IFsuLi5wcmVjZWRpbmdMSVBhdGgsIDFdLFxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIC8vIFdyYXAgdGhlIHNlbGVjdGVkIGxpcyBpbiBhIG5ldyBsaXN0XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKFxuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICAgICAgICB0eXBlOiBpc0N1cnJlbnRseU9MID8gJ29sJyA6ICd1bCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBtYXRjaDogKG5vZGUpID0+IEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ2xpJyxcbiAgICAgICAgICAgICAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwganVzdCB3cmFwIHRoZSBub2RlIGluIGEgbGlzdCAvIGxpXG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKFxuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW3sgY2hpbGRyZW46IFtdLCB0eXBlOiAnbGknIH1dLFxuICAgICAgICAgICAgICAgICAgdHlwZTogaXNDdXJyZW50bHlPTCA/ICdvbCcgOiAndWwnLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgbWF0Y2g6IChub2RlKSA9PiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdsaScsXG4gICAgICAgICAgICAgICAgICBtb2RlOiAnbG93ZXN0JyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFRyYW5zZm9ybXMud3JhcE5vZGVzKGVkaXRvciwgeyBjaGlsZHJlbjogW10sIHR5cGU6IGluZGVudFR5cGUgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBSZWFjdEVkaXRvci5mb2N1cyhlZGl0b3IpXG4gICAgICB9LFxuICAgICAgW2VkaXRvcl0sXG4gICAgKVxuXG4gICAgY29uc3QgY2FuRGVJbmRlbnQgPSBpc0VsZW1lbnRBY3RpdmUoZWRpdG9yLCAnbGknKSB8fCBpc0VsZW1lbnRBY3RpdmUoZWRpdG9yLCBpbmRlbnRUeXBlKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNsYXNzTmFtZT17W2Jhc2VDbGFzcywgIWNhbkRlSW5kZW50ICYmIGAke2Jhc2VDbGFzc30tLWRpc2FibGVkYF1cbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5qb2luKCcgJyl9XG4gICAgICAgICAgb25DbGljaz17Y2FuRGVJbmRlbnQgPyAoZSkgPT4gaGFuZGxlSW5kZW50KGUsICdsZWZ0JykgOiB1bmRlZmluZWR9XG4gICAgICAgICAgdHlwZT1cImJ1dHRvblwiXG4gICAgICAgID5cbiAgICAgICAgICA8SW5kZW50TGVmdCAvPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9e2Jhc2VDbGFzc30gb25DbGljaz17KGUpID0+IGhhbmRsZUluZGVudChlLCAncmlnaHQnKX0gdHlwZT1cImJ1dHRvblwiPlxuICAgICAgICAgIDxJbmRlbnRSaWdodCAvPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICAgKVxuICB9LFxuICBFbGVtZW50OiBJbmRlbnRXaXRoUGFkZGluZyxcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5kZW50XG4iXSwibmFtZXMiOlsiaW5kZW50VHlwZSIsIkluZGVudFdpdGhQYWRkaW5nIiwiYXR0cmlidXRlcyIsImNoaWxkcmVuIiwiZGl2Iiwic3R5bGUiLCJwYWRkaW5nTGVmdCIsImluZGVudCIsIkJ1dHRvbiIsImVkaXRvciIsInVzZVNsYXRlIiwiaGFuZGxlSW5kZW50IiwidXNlQ2FsbGJhY2siLCJlIiwiZGlyIiwicHJldmVudERlZmF1bHQiLCJpc0VsZW1lbnRBY3RpdmUiLCJsaXN0UGF0aCIsImdldENvbW1vbkJsb2NrIiwibiIsIkVsZW1lbnQiLCJpc0VsZW1lbnQiLCJsaXN0VHlwZXMiLCJpbmNsdWRlcyIsInR5cGUiLCJtYXRjaGVkUGFyZW50TGlzdCIsIkVkaXRvciIsImFib3ZlIiwiYXQiLCJtYXRjaCIsImlzRWRpdG9yIiwiaXNCbG9ja0VsZW1lbnQiLCJwYXJlbnRMaXN0SXRlbSIsInBhcmVudExpc3RJdGVtUGF0aCIsImxlbmd0aCIsIlRyYW5zZm9ybXMiLCJ1bndyYXBOb2RlcyIsIm5vZGUiLCJwYXRoIiwibWF0Y2hlcyIsInNldE5vZGVzIiwibmV3UGFyZW50Tm9kZSIsImxpZnROb2RlcyIsInVud3JhcExpc3QiLCJtb2RlIiwic3BsaXQiLCJpc0N1cnJlbnRseU9MIiwiaXNDdXJyZW50bHlVTCIsImZpcnN0U2VsZWN0ZWRMSVBhdGgiLCJBcnJheSIsImZyb20iLCJub2RlcyIsImhhc1ByZWNlZGluZ0xJIiwicHJlY2VkaW5nTElQYXRoIiwicHJldmlvdXMiLCJwcmVjZWRpbmdMSUNoaWxkcmVuIiwicHJlY2VkaW5nTElDaGlsZHJlbklzVGV4dCIsIlRleHQiLCJpc1RleHQiLCJ3cmFwTm9kZXMiLCJtb3ZlTm9kZXMiLCJ0byIsIlJlYWN0RWRpdG9yIiwiZm9jdXMiLCJjYW5EZUluZGVudCIsIlJlYWN0IiwiRnJhZ21lbnQiLCJidXR0b24iLCJjbGFzc05hbWUiLCJiYXNlQ2xhc3MiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsIm9uQ2xpY2siLCJ1bmRlZmluZWQiLCJJbmRlbnRMZWZ0IiwiSW5kZW50UmlnaHQiXSwibWFwcGluZ3MiOiI7Ozs7K0JBaU9BOzs7ZUFBQTs7OytEQWpPbUM7dUJBQ2U7NEJBQ1o7bUVBSWY7b0VBQ0M7d0JBQ0U7Z0NBQ0s7aUVBQ0g7Z0NBQ0c7a0VBQ1Q7NEJBQ0s7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUUzQixNQUFNQSxhQUFhO0FBRW5CLE1BQU1DLG9CQUFvQixDQUFDLEVBQUVDLFVBQVUsRUFBRUMsUUFBUSxFQUFFLGlCQUNqRCw2QkFBQ0M7UUFBSUMsT0FBTztZQUFFQyxhQUFhO1FBQUc7UUFBSSxHQUFHSixVQUFVO09BQzVDQztBQUlMLE1BQU1JLFNBQVM7SUFDYkMsUUFBUTtRQUNOLE1BQU1DLFNBQVNDLElBQUFBLG9CQUFRO1FBQ3ZCLE1BQU1DLGVBQWVDLElBQUFBLGtCQUFXLEVBQzlCLENBQUNDLEdBQUdDO1lBQ0ZELEVBQUVFLGNBQWM7WUFFaEIsSUFBSUQsUUFBUSxRQUFRO2dCQUNsQixJQUFJRSxJQUFBQSxpQkFBZSxFQUFDUCxRQUFRLE9BQU87b0JBQ2pDLE1BQU0sR0FBR1EsU0FBUyxHQUFHQyxJQUFBQSw4QkFBYyxFQUNqQ1QsUUFDQSxDQUFDVSxJQUFNQyxjQUFPLENBQUNDLFNBQVMsQ0FBQ0YsTUFBTUcsa0JBQVMsQ0FBQ0MsUUFBUSxDQUFDSixFQUFFSyxJQUFJO29CQUcxRCxNQUFNQyxvQkFBb0JDLGFBQU0sQ0FBQ0MsS0FBSyxDQUFDbEIsUUFBUTt3QkFDN0NtQixJQUFJWDt3QkFDSlksT0FBTyxDQUFDVixJQUFtQixDQUFDTyxhQUFNLENBQUNJLFFBQVEsQ0FBQ1gsTUFBTVksSUFBQUEsOEJBQWMsRUFBQ3RCLFFBQVFVO29CQUMzRTtv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