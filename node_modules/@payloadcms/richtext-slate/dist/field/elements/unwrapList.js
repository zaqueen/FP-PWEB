"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "unwrapList", {
    enumerable: true,
    get: function() {
        return unwrapList;
    }
});
const _slate = require("slate");
const _areAllChildrenElements = require("./areAllChildrenElements");
const _listTypes = /*#__PURE__*/ _interop_require_default(require("./listTypes"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const unwrapList = (editor, atPath)=>{
    // Remove type for any nodes that have text children -
    // this means that the node should remain
    _slate.Transforms.setNodes(editor, {
        type: undefined
    }, {
        at: atPath,
        match: (node, path)=>{
            const childrenAreAllElements = (0, _areAllChildrenElements.areAllChildrenElements)(node);
            const matches = !_slate.Editor.isEditor(node) && _slate.Element.isElement(node) && !childrenAreAllElements && node.type === 'li' && path.length === atPath.length + 1;
            return matches;
        }
    });
    // For nodes have all element children, unwrap it instead
    // because the li is a duplicative wrapper
    _slate.Transforms.unwrapNodes(editor, {
        at: atPath,
        match: (node, path)=>{
            const childrenAreAllElements = (0, _areAllChildrenElements.areAllChildrenElements)(node);
            const matches = !_slate.Editor.isEditor(node) && _slate.Element.isElement(node) && childrenAreAllElements && node.type === 'li' && path.length === atPath.length + 1;
            return matches;
        }
    });
    // Finally, unwrap the UL itself
    _slate.Transforms.unwrapNodes(editor, {
        match: (n)=>_slate.Element.isElement(n) && _listTypes.default.includes(n.type),
        mode: 'lowest'
    });
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9maWVsZC9lbGVtZW50cy91bndyYXBMaXN0LnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgUGF0aCB9IGZyb20gJ3NsYXRlJ1xuXG5pbXBvcnQgeyBFZGl0b3IsIEVsZW1lbnQsIFRyYW5zZm9ybXMgfSBmcm9tICdzbGF0ZSdcblxuaW1wb3J0IHsgYXJlQWxsQ2hpbGRyZW5FbGVtZW50cyB9IGZyb20gJy4vYXJlQWxsQ2hpbGRyZW5FbGVtZW50cydcbmltcG9ydCBsaXN0VHlwZXMgZnJvbSAnLi9saXN0VHlwZXMnXG5cbmV4cG9ydCBjb25zdCB1bndyYXBMaXN0ID0gKGVkaXRvcjogRWRpdG9yLCBhdFBhdGg6IFBhdGgpOiB2b2lkID0+IHtcbiAgLy8gUmVtb3ZlIHR5cGUgZm9yIGFueSBub2RlcyB0aGF0IGhhdmUgdGV4dCBjaGlsZHJlbiAtXG4gIC8vIHRoaXMgbWVhbnMgdGhhdCB0aGUgbm9kZSBzaG91bGQgcmVtYWluXG4gIFRyYW5zZm9ybXMuc2V0Tm9kZXMoXG4gICAgZWRpdG9yLFxuICAgIHsgdHlwZTogdW5kZWZpbmVkIH0sXG4gICAge1xuICAgICAgYXQ6IGF0UGF0aCxcbiAgICAgIG1hdGNoOiAobm9kZSwgcGF0aCkgPT4ge1xuICAgICAgICBjb25zdCBjaGlsZHJlbkFyZUFsbEVsZW1lbnRzID0gYXJlQWxsQ2hpbGRyZW5FbGVtZW50cyhub2RlKVxuXG4gICAgICAgIGNvbnN0IG1hdGNoZXMgPVxuICAgICAgICAgICFFZGl0b3IuaXNFZGl0b3Iobm9kZSkgJiZcbiAgICAgICAgICBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJlxuICAgICAgICAgICFjaGlsZHJlbkFyZUFsbEVsZW1lbnRzICYmXG4gICAgICAgICAgbm9kZS50eXBlID09PSAnbGknICYmXG4gICAgICAgICAgcGF0aC5sZW5ndGggPT09IGF0UGF0aC5sZW5ndGggKyAxXG5cbiAgICAgICAgcmV0dXJuIG1hdGNoZXNcbiAgICAgIH0sXG4gICAgfSxcbiAgKVxuXG4gIC8vIEZvciBub2RlcyBoYXZlIGFsbCBlbGVtZW50IGNoaWxkcmVuLCB1bndyYXAgaXQgaW5zdGVhZFxuICAvLyBiZWNhdXNlIHRoZSBsaSBpcyBhIGR1cGxpY2F0aXZlIHdyYXBwZXJcbiAgVHJhbnNmb3Jtcy51bndyYXBOb2RlcyhlZGl0b3IsIHtcbiAgICBhdDogYXRQYXRoLFxuICAgIG1hdGNoOiAobm9kZSwgcGF0aCkgPT4ge1xuICAgICAgY29uc3QgY2hpbGRyZW5BcmVBbGxFbGVtZW50cyA9IGFyZUFsbENoaWxkcmVuRWxlbWVudHMobm9kZSlcblxuICAgICAgY29uc3QgbWF0Y2hlcyA9XG4gICAgICAgICFFZGl0b3IuaXNFZGl0b3Iobm9kZSkgJiZcbiAgICAgICAgRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiZcbiAgICAgICAgY2hpbGRyZW5BcmVBbGxFbGVtZW50cyAmJlxuICAgICAgICBub2RlLnR5cGUgPT09ICdsaScgJiZcbiAgICAgICAgcGF0aC5sZW5ndGggPT09IGF0UGF0aC5sZW5ndGggKyAxXG5cbiAgICAgIHJldHVybiBtYXRjaGVzXG4gICAgfSxcbiAgfSlcblxuICAvLyBGaW5hbGx5LCB1bndyYXAgdGhlIFVMIGl0c2VsZlxuICBUcmFuc2Zvcm1zLnVud3JhcE5vZGVzKGVkaXRvciwge1xuICAgIG1hdGNoOiAobikgPT4gRWxlbWVudC5pc0VsZW1lbnQobikgJiYgbGlzdFR5cGVzLmluY2x1ZGVzKG4udHlwZSksXG4gICAgbW9kZTogJ2xvd2VzdCcsXG4gIH0pXG59XG4iXSwibmFtZXMiOlsidW53cmFwTGlzdCIsImVkaXRvciIsImF0UGF0aCIsIlRyYW5zZm9ybXMiLCJzZXROb2RlcyIsInR5cGUiLCJ1bmRlZmluZWQiLCJhdCIsIm1hdGNoIiwibm9kZSIsInBhdGgiLCJjaGlsZHJlbkFyZUFsbEVsZW1lbnRzIiwiYXJlQWxsQ2hpbGRyZW5FbGVtZW50cyIsIm1hdGNoZXMiLCJFZGl0b3IiLCJpc0VkaXRvciIsIkVsZW1lbnQiLCJpc0VsZW1lbnQiLCJsZW5ndGgiLCJ1bndyYXBOb2RlcyIsIm4iLCJsaXN0VHlwZXMiLCJpbmNsdWRlcyIsIm1vZGUiXSwibWFwcGluZ3MiOiI7Ozs7K0JBT2FBOzs7ZUFBQUE7Ozt1QkFMK0I7d0NBRUw7a0VBQ2pCOzs7Ozs7QUFFZixNQUFNQSxhQUFhLENBQUNDLFFBQWdCQztJQUN6QyxzREFBc0Q7SUFDdEQseUNBQXlDO0lBQ3pDQyxpQkFBVSxDQUFDQyxRQUFRLENBQ2pCSCxRQUNBO1FBQUVJLE1BQU1DO0lBQVUsR0FDbEI7UUFDRUMsSUFBSUw7UUFDSk0sT0FBTyxDQUFDQyxNQUFNQztZQUNaLE1BQU1DLHlCQUF5QkMsSUFBQUEsOENBQXNCLEVBQUNIO1lBRXRELE1BQU1JLFVBQ0osQ0FBQ0MsYUFBTSxDQUFDQyxRQUFRLENBQUNOLFNBQ2pCTyxjQUFPLENBQUNDLFNBQVMsQ0FBQ1IsU0FDbEIsQ0FBQ0UsMEJBQ0RGLEtBQUtKLElBQUksS0FBSyxRQUNkSyxLQUFLUSxNQUFNLEtBQUtoQixPQUFPZ0IsTUFBTSxHQUFHO1lBRWxDLE9BQU9MO1FBQ1Q7SUFDRjtJQUdGLHlEQUF5RDtJQUN6RCwwQ0FBMEM7SUFDMUNWLGlCQUFVLENBQUNnQixXQUFXLENBQUNsQixRQUFRO1FBQzdCTSxJQUFJTDtRQUNKTSxPQUFPLENBQUNDLE1BQU1DO1lBQ1osTUFBTUMseUJBQXlCQyxJQUFBQSw4Q0FBc0IsRUFBQ0g7WUFFdEQsTUFBTUksVUFDSixDQUFDQyxhQUFNLENBQUNDLFFBQVEsQ0FBQ04sU0FDakJPLGNBQU8sQ0FBQ0MsU0FBUyxDQUFDUixTQUNsQkUsMEJBQ0FGLEtBQUtKLElBQUksS0FBSyxRQUNkSyxLQUFLUSxNQUFNLEtBQUtoQixPQUFPZ0IsTUFBTSxHQUFHO1lBRWxDLE9BQU9MO1FBQ1Q7SUFDRjtJQUVBLGdDQUFnQztJQUNoQ1YsaUJBQVUsQ0FBQ2dCLFdBQVcsQ0FBQ2xCLFFBQVE7UUFDN0JPLE9BQU8sQ0FBQ1ksSUFBTUosY0FBTyxDQUFDQyxTQUFTLENBQUNHLE1BQU1DLGtCQUFTLENBQUNDLFFBQVEsQ0FBQ0YsRUFBRWYsSUFBSTtRQUMvRGtCLE1BQU07SUFDUjtBQUNGIn0=