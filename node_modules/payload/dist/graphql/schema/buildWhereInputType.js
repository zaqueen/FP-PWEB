/* eslint-disable @typescript-eslint/no-use-before-define */ /* eslint-disable no-use-before-define */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _graphql = require("graphql");
const _types = require("../../fields/config/types");
const _formatName = /*#__PURE__*/ _interop_require_default(require("../utilities/formatName"));
const _fieldToWhereInputSchemaMap = /*#__PURE__*/ _interop_require_default(require("./fieldToWhereInputSchemaMap"));
const _withOperators = require("./withOperators");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/** This does as the function name suggests. It builds a where GraphQL input type
 * for all the fields which are passed to the function.
 * Each field has different operators which may be valid for a where input type.
 * For example, a text field may have a "contains" operator, but a number field
 * may not.
 *
 * buildWhereInputType is similar to buildObjectType and operates
 * on a field basis with a few distinct differences.
 *
 * 1. Everything needs to be a GraphQLInputObjectType or scalar / enum
 * 2. Relationships, groups, repeaters and flex content are not
 *    directly searchable. Instead, we need to build a chained pathname
 *    using dot notation so MongoDB can properly search nested paths.
 */ const buildWhereInputType = ({ name, fields, parentName, payload })=>{
    // This is the function that builds nested paths for all
    // field types with nested paths.
    let idField;
    const fieldTypes = fields.reduce((schema, field)=>{
        if ((0, _types.fieldAffectsData)(field) && field.name === 'id') idField = field;
        if (!(0, _types.fieldIsPresentationalOnly)(field) && !field.hidden) {
            const getFieldSchema = (0, _fieldToWhereInputSchemaMap.default)({
                parentName,
                payload
            })[field.type];
            if (getFieldSchema) {
                const fieldSchema = getFieldSchema(field);
                if ((0, _types.fieldHasSubFields)(field) || field.type === 'tabs') {
                    return {
                        ...schema,
                        ...fieldSchema.reduce((subFields, subField)=>({
                                ...subFields,
                                [(0, _formatName.default)(subField.key)]: subField.type
                            }), {})
                    };
                }
                return {
                    ...schema,
                    [(0, _formatName.default)(field.name)]: fieldSchema
                };
            }
        }
        return schema;
    }, {});
    if (!idField) {
        fieldTypes.id = {
            type: (0, _withOperators.withOperators)({
                name: 'id',
                type: 'text'
            }, parentName)
        };
    }
    const fieldName = (0, _formatName.default)(name);
    const recursiveFields = {
        AND: {
            type: new _graphql.GraphQLList(new _graphql.GraphQLInputObjectType({
                name: `${fieldName}_where_and`,
                fields: ()=>({
                        ...fieldTypes,
                        ...recursiveFields
                    })
            }))
        },
        OR: {
            type: new _graphql.GraphQLList(new _graphql.GraphQLInputObjectType({
                name: `${fieldName}_where_or`,
                fields: ()=>({
                        ...fieldTypes,
                        ...recursiveFields
                    })
            }))
        }
    };
    return new _graphql.GraphQLInputObjectType({
        name: `${fieldName}_where`,
        fields: {
            ...fieldTypes,
            ...recursiveFields
        }
    });
};
const _default = buildWhereInputType;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ncmFwaHFsL3NjaGVtYS9idWlsZFdoZXJlSW5wdXRUeXBlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZSAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cbmltcG9ydCB7IEdyYXBoUUxJbnB1dE9iamVjdFR5cGUsIEdyYXBoUUxMaXN0IH0gZnJvbSAnZ3JhcGhxbCdcblxuaW1wb3J0IHR5cGUgeyBQYXlsb2FkIH0gZnJvbSAnLi4vLi4nXG5pbXBvcnQgdHlwZSB7IEZpZWxkLCBGaWVsZEFmZmVjdGluZ0RhdGEgfSBmcm9tICcuLi8uLi9maWVsZHMvY29uZmlnL3R5cGVzJ1xuXG5pbXBvcnQge1xuICBmaWVsZEFmZmVjdHNEYXRhLFxuICBmaWVsZEhhc1N1YkZpZWxkcyxcbiAgZmllbGRJc1ByZXNlbnRhdGlvbmFsT25seSxcbn0gZnJvbSAnLi4vLi4vZmllbGRzL2NvbmZpZy90eXBlcydcbmltcG9ydCBmb3JtYXROYW1lIGZyb20gJy4uL3V0aWxpdGllcy9mb3JtYXROYW1lJ1xuaW1wb3J0IGZpZWxkVG9TY2hlbWFNYXAgZnJvbSAnLi9maWVsZFRvV2hlcmVJbnB1dFNjaGVtYU1hcCdcbmltcG9ydCB7IHdpdGhPcGVyYXRvcnMgfSBmcm9tICcuL3dpdGhPcGVyYXRvcnMnXG5cbnR5cGUgQXJncyA9IHtcbiAgZmllbGRzOiBGaWVsZFtdXG4gIG5hbWU6IHN0cmluZ1xuICBwYXJlbnROYW1lOiBzdHJpbmdcbiAgcGF5bG9hZDogUGF5bG9hZFxufVxuXG4vKiogVGhpcyBkb2VzIGFzIHRoZSBmdW5jdGlvbiBuYW1lIHN1Z2dlc3RzLiBJdCBidWlsZHMgYSB3aGVyZSBHcmFwaFFMIGlucHV0IHR5cGVcbiAqIGZvciBhbGwgdGhlIGZpZWxkcyB3aGljaCBhcmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbi5cbiAqIEVhY2ggZmllbGQgaGFzIGRpZmZlcmVudCBvcGVyYXRvcnMgd2hpY2ggbWF5IGJlIHZhbGlkIGZvciBhIHdoZXJlIGlucHV0IHR5cGUuXG4gKiBGb3IgZXhhbXBsZSwgYSB0ZXh0IGZpZWxkIG1heSBoYXZlIGEgXCJjb250YWluc1wiIG9wZXJhdG9yLCBidXQgYSBudW1iZXIgZmllbGRcbiAqIG1heSBub3QuXG4gKlxuICogYnVpbGRXaGVyZUlucHV0VHlwZSBpcyBzaW1pbGFyIHRvIGJ1aWxkT2JqZWN0VHlwZSBhbmQgb3BlcmF0ZXNcbiAqIG9uIGEgZmllbGQgYmFzaXMgd2l0aCBhIGZldyBkaXN0aW5jdCBkaWZmZXJlbmNlcy5cbiAqXG4gKiAxLiBFdmVyeXRoaW5nIG5lZWRzIHRvIGJlIGEgR3JhcGhRTElucHV0T2JqZWN0VHlwZSBvciBzY2FsYXIgLyBlbnVtXG4gKiAyLiBSZWxhdGlvbnNoaXBzLCBncm91cHMsIHJlcGVhdGVycyBhbmQgZmxleCBjb250ZW50IGFyZSBub3RcbiAqICAgIGRpcmVjdGx5IHNlYXJjaGFibGUuIEluc3RlYWQsIHdlIG5lZWQgdG8gYnVpbGQgYSBjaGFpbmVkIHBhdGhuYW1lXG4gKiAgICB1c2luZyBkb3Qgbm90YXRpb24gc28gTW9uZ29EQiBjYW4gcHJvcGVybHkgc2VhcmNoIG5lc3RlZCBwYXRocy5cbiAqL1xuY29uc3QgYnVpbGRXaGVyZUlucHV0VHlwZSA9ICh7XG4gIG5hbWUsXG4gIGZpZWxkcyxcbiAgcGFyZW50TmFtZSxcbiAgcGF5bG9hZCxcbn06IEFyZ3MpOiBHcmFwaFFMSW5wdXRPYmplY3RUeXBlID0+IHtcbiAgLy8gVGhpcyBpcyB0aGUgZnVuY3Rpb24gdGhhdCBidWlsZHMgbmVzdGVkIHBhdGhzIGZvciBhbGxcbiAgLy8gZmllbGQgdHlwZXMgd2l0aCBuZXN0ZWQgcGF0aHMuXG5cbiAgbGV0IGlkRmllbGQ6IEZpZWxkQWZmZWN0aW5nRGF0YSB8IHVuZGVmaW5lZFxuXG4gIGNvbnN0IGZpZWxkVHlwZXMgPSBmaWVsZHMucmVkdWNlKChzY2hlbWEsIGZpZWxkKSA9PiB7XG4gICAgaWYgKGZpZWxkQWZmZWN0c0RhdGEoZmllbGQpICYmIGZpZWxkLm5hbWUgPT09ICdpZCcpIGlkRmllbGQgPSBmaWVsZFxuXG4gICAgaWYgKCFmaWVsZElzUHJlc2VudGF0aW9uYWxPbmx5KGZpZWxkKSAmJiAhZmllbGQuaGlkZGVuKSB7XG4gICAgICBjb25zdCBnZXRGaWVsZFNjaGVtYSA9IGZpZWxkVG9TY2hlbWFNYXAoe1xuICAgICAgICBwYXJlbnROYW1lLFxuICAgICAgICBwYXlsb2FkLFxuICAgICAgfSlbZmllbGQudHlwZV1cblxuICAgICAgaWYgKGdldEZpZWxkU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gZ2V0RmllbGRTY2hlbWEoZmllbGQpXG5cbiAgICAgICAgaWYgKGZpZWxkSGFzU3ViRmllbGRzKGZpZWxkKSB8fCBmaWVsZC50eXBlID09PSAndGFicycpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc2NoZW1hLFxuICAgICAgICAgICAgLi4uZmllbGRTY2hlbWEucmVkdWNlKFxuICAgICAgICAgICAgICAoc3ViRmllbGRzLCBzdWJGaWVsZCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5zdWJGaWVsZHMsXG4gICAgICAgICAgICAgICAgW2Zvcm1hdE5hbWUoc3ViRmllbGQua2V5KV06IHN1YkZpZWxkLnR5cGUsXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5zY2hlbWEsXG4gICAgICAgICAgW2Zvcm1hdE5hbWUoZmllbGQubmFtZSldOiBmaWVsZFNjaGVtYSxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzY2hlbWFcbiAgfSwge30pXG5cbiAgaWYgKCFpZEZpZWxkKSB7XG4gICAgZmllbGRUeXBlcy5pZCA9IHtcbiAgICAgIHR5cGU6IHdpdGhPcGVyYXRvcnMoeyBuYW1lOiAnaWQnLCB0eXBlOiAndGV4dCcgfSBhcyBGaWVsZEFmZmVjdGluZ0RhdGEsIHBhcmVudE5hbWUpLFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGZpZWxkTmFtZSA9IGZvcm1hdE5hbWUobmFtZSlcblxuICBjb25zdCByZWN1cnNpdmVGaWVsZHMgPSB7XG4gICAgQU5EOiB7XG4gICAgICB0eXBlOiBuZXcgR3JhcGhRTExpc3QoXG4gICAgICAgIG5ldyBHcmFwaFFMSW5wdXRPYmplY3RUeXBlKHtcbiAgICAgICAgICBuYW1lOiBgJHtmaWVsZE5hbWV9X3doZXJlX2FuZGAsXG4gICAgICAgICAgZmllbGRzOiAoKSA9PiAoe1xuICAgICAgICAgICAgLi4uZmllbGRUeXBlcyxcbiAgICAgICAgICAgIC4uLnJlY3Vyc2l2ZUZpZWxkcyxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSksXG4gICAgICApLFxuICAgIH0sXG4gICAgT1I6IHtcbiAgICAgIHR5cGU6IG5ldyBHcmFwaFFMTGlzdChcbiAgICAgICAgbmV3IEdyYXBoUUxJbnB1dE9iamVjdFR5cGUoe1xuICAgICAgICAgIG5hbWU6IGAke2ZpZWxkTmFtZX1fd2hlcmVfb3JgLFxuICAgICAgICAgIGZpZWxkczogKCkgPT4gKHtcbiAgICAgICAgICAgIC4uLmZpZWxkVHlwZXMsXG4gICAgICAgICAgICAuLi5yZWN1cnNpdmVGaWVsZHMsXG4gICAgICAgICAgfSksXG4gICAgICAgIH0pLFxuICAgICAgKSxcbiAgICB9LFxuICB9XG5cbiAgcmV0dXJuIG5ldyBHcmFwaFFMSW5wdXRPYmplY3RUeXBlKHtcbiAgICBuYW1lOiBgJHtmaWVsZE5hbWV9X3doZXJlYCxcbiAgICBmaWVsZHM6IHtcbiAgICAgIC4uLmZpZWxkVHlwZXMsXG4gICAgICAuLi5yZWN1cnNpdmVGaWVsZHMsXG4gICAgfSxcbiAgfSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgYnVpbGRXaGVyZUlucHV0VHlwZVxuIl0sIm5hbWVzIjpbImJ1aWxkV2hlcmVJbnB1dFR5cGUiLCJuYW1lIiwiZmllbGRzIiwicGFyZW50TmFtZSIsInBheWxvYWQiLCJpZEZpZWxkIiwiZmllbGRUeXBlcyIsInJlZHVjZSIsInNjaGVtYSIsImZpZWxkIiwiZmllbGRBZmZlY3RzRGF0YSIsImZpZWxkSXNQcmVzZW50YXRpb25hbE9ubHkiLCJoaWRkZW4iLCJnZXRGaWVsZFNjaGVtYSIsImZpZWxkVG9TY2hlbWFNYXAiLCJ0eXBlIiwiZmllbGRTY2hlbWEiLCJmaWVsZEhhc1N1YkZpZWxkcyIsInN1YkZpZWxkcyIsInN1YkZpZWxkIiwiZm9ybWF0TmFtZSIsImtleSIsImlkIiwid2l0aE9wZXJhdG9ycyIsImZpZWxkTmFtZSIsInJlY3Vyc2l2ZUZpZWxkcyIsIkFORCIsIkdyYXBoUUxMaXN0IiwiR3JhcGhRTElucHV0T2JqZWN0VHlwZSIsIk9SIl0sIm1hcHBpbmdzIjoiQUFBQSwwREFBMEQsR0FDMUQsdUNBQXVDOzs7OytCQTRIdkM7OztlQUFBOzs7eUJBM0hvRDt1QkFTN0M7bUVBQ2dCO21GQUNNOytCQUNDOzs7Ozs7QUFTOUI7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELE1BQU1BLHNCQUFzQixDQUFDLEVBQzNCQyxJQUFJLEVBQ0pDLE1BQU0sRUFDTkMsVUFBVSxFQUNWQyxPQUFPLEVBQ0Y7SUFDTCx3REFBd0Q7SUFDeEQsaUNBQWlDO0lBRWpDLElBQUlDO0lBRUosTUFBTUMsYUFBYUosT0FBT0ssTUFBTSxDQUFDLENBQUNDLFFBQVFDO1FBQ3hDLElBQUlDLElBQUFBLHVCQUFnQixFQUFDRCxVQUFVQSxNQUFNUixJQUFJLEtBQUssTUFBTUksVUFBVUk7UUFFOUQsSUFBSSxDQUFDRSxJQUFBQSxnQ0FBeUIsRUFBQ0YsVUFBVSxDQUFDQSxNQUFNRyxNQUFNLEVBQUU7WUFDdEQsTUFBTUMsaUJBQWlCQyxJQUFBQSxtQ0FBZ0IsRUFBQztnQkFDdENYO2dCQUNBQztZQUNGLEVBQUUsQ0FBQ0ssTUFBTU0sSUFBSSxDQUFDO1lBRWQsSUFBSUYsZ0JBQWdCO2dCQUNsQixNQUFNRyxjQUFjSCxlQUFlSjtnQkFFbkMsSUFBSVEsSUFBQUEsd0JBQWlCLEVBQUNSLFVBQVVBLE1BQU1NLElBQUksS0FBSyxRQUFRO29CQUNyRCxPQUFPO3dCQUNMLEdBQUdQLE1BQU07d0JBQ1QsR0FBR1EsWUFBWVQsTUFBTSxDQUNuQixDQUFDVyxXQUFXQyxXQUFjLENBQUE7Z0NBQ3hCLEdBQUdELFNBQVM7Z0NBQ1osQ0FBQ0UsSUFBQUEsbUJBQVUsRUFBQ0QsU0FBU0UsR0FBRyxFQUFFLEVBQUVGLFNBQVNKLElBQUk7NEJBQzNDLENBQUEsR0FDQSxDQUFDLEVBQ0Y7b0JBQ0g7Z0JBQ0Y7Z0JBRUEsT0FBTztvQkFDTCxHQUFHUCxNQUFNO29CQUNULENBQUNZLElBQUFBLG1CQUFVLEVBQUNYLE1BQU1SLElBQUksRUFBRSxFQUFFZTtnQkFDNUI7WUFDRjtRQUNGO1FBRUEsT0FBT1I7SUFDVCxHQUFHLENBQUM7SUFFSixJQUFJLENBQUNILFNBQVM7UUFDWkMsV0FBV2dCLEVBQUUsR0FBRztZQUNkUCxNQUFNUSxJQUFBQSw0QkFBYSxFQUFDO2dCQUFFdEIsTUFBTTtnQkFBTWMsTUFBTTtZQUFPLEdBQXlCWjtRQUMxRTtJQUNGO0lBRUEsTUFBTXFCLFlBQVlKLElBQUFBLG1CQUFVLEVBQUNuQjtJQUU3QixNQUFNd0Isa0JBQWtCO1FBQ3RCQyxLQUFLO1lBQ0hYLE1BQU0sSUFBSVksb0JBQVcsQ0FDbkIsSUFBSUMsK0JBQXNCLENBQUM7Z0JBQ3pCM0IsTUFBTSxDQUFDLEVBQUV1QixVQUFVLFVBQVUsQ0FBQztnQkFDOUJ0QixRQUFRLElBQU8sQ0FBQTt3QkFDYixHQUFHSSxVQUFVO3dCQUNiLEdBQUdtQixlQUFlO29CQUNwQixDQUFBO1lBQ0Y7UUFFSjtRQUNBSSxJQUFJO1lBQ0ZkLE1BQU0sSUFBSVksb0JBQVcsQ0FDbkIsSUFBSUMsK0JBQXNCLENBQUM7Z0JBQ3pCM0IsTUFBTSxDQUFDLEVBQUV1QixVQUFVLFNBQVMsQ0FBQztnQkFDN0J0QixRQUFRLElBQU8sQ0FBQTt3QkFDYixHQUFHSSxVQUFVO3dCQUNiLEdBQUdtQixlQUFlO29CQUNwQixDQUFBO1lBQ0Y7UUFFSjtJQUNGO0lBRUEsT0FBTyxJQUFJRywrQkFBc0IsQ0FBQztRQUNoQzNCLE1BQU0sQ0FBQyxFQUFFdUIsVUFBVSxNQUFNLENBQUM7UUFDMUJ0QixRQUFRO1lBQ04sR0FBR0ksVUFBVTtZQUNiLEdBQUdtQixlQUFlO1FBQ3BCO0lBQ0Y7QUFDRjtNQUVBLFdBQWV6QiJ9