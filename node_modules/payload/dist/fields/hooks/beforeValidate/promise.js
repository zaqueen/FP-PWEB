/* eslint-disable no-param-reassign */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "promise", {
    enumerable: true,
    get: function() {
        return promise;
    }
});
const _types = require("../../config/types");
const _getDefaultValue = /*#__PURE__*/ _interop_require_default(require("../../getDefaultValue"));
const _cloneDataFromOriginalDoc = require("../beforeChange/cloneDataFromOriginalDoc");
const _getExistingRowDoc = require("../beforeChange/getExistingRowDoc");
const _traverseFields = require("./traverseFields");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const promise = async ({ id, collection, context, data, doc, field, global, operation, overrideAccess, req, siblingData, siblingDoc })=>{
    if ((0, _types.fieldAffectsData)(field)) {
        if (field.name === 'id') {
            if (field.type === 'number' && typeof siblingData[field.name] === 'string') {
                const value = siblingData[field.name];
                siblingData[field.name] = parseFloat(value);
            }
            if (field.type === 'text' && typeof siblingData[field.name]?.toString === 'function' && typeof siblingData[field.name] !== 'string') {
                siblingData[field.name] = siblingData[field.name].toString();
            }
        }
        // Sanitize incoming data
        switch(field.type){
            case 'number':
                {
                    if (typeof siblingData[field.name] === 'string') {
                        const value = siblingData[field.name];
                        const trimmed = value.trim();
                        siblingData[field.name] = trimmed.length === 0 ? null : parseFloat(trimmed);
                    }
                    break;
                }
            case 'point':
                {
                    if (Array.isArray(siblingData[field.name])) {
                        siblingData[field.name] = siblingData[field.name].map((coordinate, i)=>{
                            if (typeof coordinate === 'string') {
                                const value = siblingData[field.name][i];
                                const trimmed = value.trim();
                                return trimmed.length === 0 ? null : parseFloat(trimmed);
                            }
                            return coordinate;
                        });
                    }
                    break;
                }
            case 'checkbox':
                {
                    if (siblingData[field.name] === 'true') siblingData[field.name] = true;
                    if (siblingData[field.name] === 'false') siblingData[field.name] = false;
                    if (siblingData[field.name] === '') siblingData[field.name] = false;
                    break;
                }
            case 'richText':
                {
                    if (typeof siblingData[field.name] === 'string') {
                        try {
                            const richTextJSON = JSON.parse(siblingData[field.name]);
                            siblingData[field.name] = richTextJSON;
                        } catch  {
                        // Disregard this data as it is not valid.
                        // Will be reported to user by field validation
                        }
                    }
                    break;
                }
            case 'relationship':
            case 'upload':
                {
                    if (siblingData[field.name] === '' || siblingData[field.name] === 'none' || siblingData[field.name] === 'null' || siblingData[field.name] === null) {
                        if (field.type === 'relationship' && field.hasMany === true) {
                            siblingData[field.name] = [];
                        } else {
                            siblingData[field.name] = null;
                        }
                    }
                    const value = siblingData[field.name];
                    if (Array.isArray(field.relationTo)) {
                        if (Array.isArray(value)) {
                            value.forEach((relatedDoc, i)=>{
                                const relatedCollection = req.payload.config.collections.find((collection)=>collection.slug === relatedDoc.relationTo);
                                const relationshipIDField = relatedCollection.fields.find((collectionField)=>(0, _types.fieldAffectsData)(collectionField) && collectionField.name === 'id');
                                if (relationshipIDField?.type === 'number') {
                                    siblingData[field.name][i] = {
                                        ...relatedDoc,
                                        value: parseFloat(relatedDoc.value)
                                    };
                                }
                            });
                        }
                        if (field.type === 'relationship' && field.hasMany !== true && (0, _types.valueIsValueWithRelation)(value)) {
                            const relatedCollection = req.payload.config.collections.find((collection)=>collection.slug === value.relationTo);
                            const relationshipIDField = relatedCollection.fields.find((collectionField)=>(0, _types.fieldAffectsData)(collectionField) && collectionField.name === 'id');
                            if (relationshipIDField?.type === 'number') {
                                siblingData[field.name] = {
                                    ...value,
                                    value: parseFloat(value.value)
                                };
                            }
                        }
                    } else {
                        if (Array.isArray(value)) {
                            value.forEach((relatedDoc, i)=>{
                                const relatedCollection = req.payload.config.collections.find((collection)=>collection.slug === field.relationTo);
                                const relationshipIDField = relatedCollection.fields.find((collectionField)=>(0, _types.fieldAffectsData)(collectionField) && collectionField.name === 'id');
                                if (relationshipIDField?.type === 'number') {
                                    siblingData[field.name][i] = parseFloat(relatedDoc);
                                }
                            });
                        }
                        if (field.type === 'relationship' && field.hasMany !== true && value) {
                            const relatedCollection = req.payload.config.collections.find((collection)=>collection.slug === field.relationTo);
                            const relationshipIDField = relatedCollection.fields.find((collectionField)=>(0, _types.fieldAffectsData)(collectionField) && collectionField.name === 'id');
                            if (relationshipIDField?.type === 'number') {
                                siblingData[field.name] = parseFloat(value);
                            }
                        }
                    }
                    break;
                }
            case 'array':
            case 'blocks':
                {
                    // Handle cases of arrays being intentionally set to 0
                    if (siblingData[field.name] === '0' || siblingData[field.name] === 0) {
                        siblingData[field.name] = [];
                    }
                    break;
                }
            default:
                {
                    break;
                }
        }
        // Execute hooks
        if (field.hooks?.beforeValidate) {
            await field.hooks.beforeValidate.reduce(async (priorHook, currentHook)=>{
                await priorHook;
                const hookedValue = await currentHook({
                    collection,
                    context,
                    data,
                    field,
                    global,
                    operation,
                    originalDoc: doc,
                    req,
                    siblingData,
                    value: siblingData[field.name]
                });
                if (hookedValue !== undefined) {
                    siblingData[field.name] = hookedValue;
                }
            }, Promise.resolve());
        }
        // Execute access control
        if (field.access && field.access[operation]) {
            const result = overrideAccess ? true : await field.access[operation]({
                id,
                data,
                doc,
                req,
                siblingData
            });
            if (!result) {
                delete siblingData[field.name];
            }
        }
        if (typeof siblingData[field.name] === 'undefined') {
            // If no incoming data, but existing document data is found, merge it in
            if (typeof siblingDoc[field.name] !== 'undefined') {
                siblingData[field.name] = (0, _cloneDataFromOriginalDoc.cloneDataFromOriginalDoc)(siblingDoc[field.name]);
            // Otherwise compute default value
            } else if (typeof field.defaultValue !== 'undefined') {
                siblingData[field.name] = await (0, _getDefaultValue.default)({
                    defaultValue: field.defaultValue,
                    locale: req.locale,
                    user: req.user,
                    value: siblingData[field.name]
                });
            }
        }
    }
    // Traverse subfields
    switch(field.type){
        case 'group':
            {
                if (typeof siblingData[field.name] !== 'object') siblingData[field.name] = {};
                if (typeof siblingDoc[field.name] !== 'object') siblingDoc[field.name] = {};
                const groupData = siblingData[field.name];
                const groupDoc = siblingDoc[field.name];
                await (0, _traverseFields.traverseFields)({
                    id,
                    collection,
                    context,
                    data,
                    doc,
                    fields: field.fields,
                    global,
                    operation,
                    overrideAccess,
                    req,
                    siblingData: groupData,
                    siblingDoc: groupDoc
                });
                break;
            }
        case 'array':
            {
                const rows = siblingData[field.name];
                if (Array.isArray(rows)) {
                    const promises = [];
                    rows.forEach((row)=>{
                        promises.push((0, _traverseFields.traverseFields)({
                            id,
                            collection,
                            context,
                            data,
                            doc,
                            fields: field.fields,
                            global,
                            operation,
                            overrideAccess,
                            req,
                            siblingData: row,
                            siblingDoc: (0, _getExistingRowDoc.getExistingRowDoc)(row, siblingDoc[field.name])
                        }));
                    });
                    await Promise.all(promises);
                }
                break;
            }
        case 'blocks':
            {
                const rows = siblingData[field.name];
                if (Array.isArray(rows)) {
                    const promises = [];
                    rows.forEach((row)=>{
                        const rowSiblingDoc = (0, _getExistingRowDoc.getExistingRowDoc)(row, siblingDoc[field.name]);
                        const blockTypeToMatch = row.blockType || rowSiblingDoc.blockType;
                        const block = field.blocks.find((blockType)=>blockType.slug === blockTypeToMatch);
                        if (block) {
                            row.blockType = blockTypeToMatch;
                            promises.push((0, _traverseFields.traverseFields)({
                                id,
                                collection,
                                context,
                                data,
                                doc,
                                fields: block.fields,
                                global,
                                operation,
                                overrideAccess,
                                req,
                                siblingData: row,
                                siblingDoc: rowSiblingDoc
                            }));
                        }
                    });
                    await Promise.all(promises);
                }
                break;
            }
        case 'row':
        case 'collapsible':
            {
                await (0, _traverseFields.traverseFields)({
                    id,
                    collection,
                    context,
                    data,
                    doc,
                    fields: field.fields,
                    global,
                    operation,
                    overrideAccess,
                    req,
                    siblingData,
                    siblingDoc
                });
                break;
            }
        case 'tab':
            {
                let tabSiblingData;
                let tabSiblingDoc;
                if ((0, _types.tabHasName)(field)) {
                    if (typeof siblingData[field.name] !== 'object') siblingData[field.name] = {};
                    if (typeof siblingDoc[field.name] !== 'object') siblingDoc[field.name] = {};
                    tabSiblingData = siblingData[field.name];
                    tabSiblingDoc = siblingDoc[field.name];
                } else {
                    tabSiblingData = siblingData;
                    tabSiblingDoc = siblingDoc;
                }
                await (0, _traverseFields.traverseFields)({
                    id,
                    collection,
                    context,
                    data,
                    doc,
                    fields: field.fields,
                    global,
                    operation,
                    overrideAccess,
                    req,
                    siblingData: tabSiblingData,
                    siblingDoc: tabSiblingDoc
                });
                break;
            }
        case 'tabs':
            {
                await (0, _traverseFields.traverseFields)({
                    id,
                    collection,
                    context,
                    data,
                    doc,
                    fields: field.tabs.map((tab)=>({
                            ...tab,
                            type: 'tab'
                        })),
                    global,
                    operation,
                    overrideAccess,
                    req,
                    siblingData,
                    siblingDoc
                });
                break;
            }
        default:
            {
                break;
            }
    }
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9maWVsZHMvaG9va3MvYmVmb3JlVmFsaWRhdGUvcHJvbWlzZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBuby1wYXJhbS1yZWFzc2lnbiAqL1xuaW1wb3J0IHR5cGUgeyBTYW5pdGl6ZWRDb2xsZWN0aW9uQ29uZmlnIH0gZnJvbSAnLi4vLi4vLi4vY29sbGVjdGlvbnMvY29uZmlnL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBQYXlsb2FkUmVxdWVzdCwgUmVxdWVzdENvbnRleHQgfSBmcm9tICcuLi8uLi8uLi9leHByZXNzL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBTYW5pdGl6ZWRHbG9iYWxDb25maWcgfSBmcm9tICcuLi8uLi8uLi9nbG9iYWxzL2NvbmZpZy90eXBlcydcbmltcG9ydCB0eXBlIHsgRmllbGQsIFRhYkFzRmllbGQgfSBmcm9tICcuLi8uLi9jb25maWcvdHlwZXMnXG5cbmltcG9ydCB7IGZpZWxkQWZmZWN0c0RhdGEsIHRhYkhhc05hbWUsIHZhbHVlSXNWYWx1ZVdpdGhSZWxhdGlvbiB9IGZyb20gJy4uLy4uL2NvbmZpZy90eXBlcydcbmltcG9ydCBnZXRWYWx1ZVdpdGhEZWZhdWx0IGZyb20gJy4uLy4uL2dldERlZmF1bHRWYWx1ZSdcbmltcG9ydCB7IGNsb25lRGF0YUZyb21PcmlnaW5hbERvYyB9IGZyb20gJy4uL2JlZm9yZUNoYW5nZS9jbG9uZURhdGFGcm9tT3JpZ2luYWxEb2MnXG5pbXBvcnQgeyBnZXRFeGlzdGluZ1Jvd0RvYyB9IGZyb20gJy4uL2JlZm9yZUNoYW5nZS9nZXRFeGlzdGluZ1Jvd0RvYydcbmltcG9ydCB7IHRyYXZlcnNlRmllbGRzIH0gZnJvbSAnLi90cmF2ZXJzZUZpZWxkcydcblxudHlwZSBBcmdzPFQ+ID0ge1xuICBjb2xsZWN0aW9uOiBTYW5pdGl6ZWRDb2xsZWN0aW9uQ29uZmlnIHwgbnVsbFxuICBjb250ZXh0OiBSZXF1ZXN0Q29udGV4dFxuICBkYXRhOiBUXG4gIGRvYzogVFxuICBmaWVsZDogRmllbGQgfCBUYWJBc0ZpZWxkXG4gIGdsb2JhbDogU2FuaXRpemVkR2xvYmFsQ29uZmlnIHwgbnVsbFxuICBpZD86IG51bWJlciB8IHN0cmluZ1xuICBvcGVyYXRpb246ICdjcmVhdGUnIHwgJ3VwZGF0ZSdcbiAgb3ZlcnJpZGVBY2Nlc3M6IGJvb2xlYW5cbiAgcmVxOiBQYXlsb2FkUmVxdWVzdFxuICBzaWJsaW5nRGF0YTogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbiAgc2libGluZ0RvYzogUmVjb3JkPHN0cmluZywgdW5rbm93bj5cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgdGhlIGZvbGxvd2luZyBhY3Rpb25zLCBpbiBvcmRlcjpcbi8vIC0gU2FuaXRpemUgaW5jb21pbmcgZGF0YVxuLy8gLSBFeGVjdXRlIGZpZWxkIGhvb2tzXG4vLyAtIEV4ZWN1dGUgZmllbGQgYWNjZXNzIGNvbnRyb2xcbi8vIC0gTWVyZ2Ugb3JpZ2luYWwgZG9jdW1lbnQgZGF0YSBpbnRvIGluY29taW5nIGRhdGFcbi8vIC0gQ29tcHV0ZSBkZWZhdWx0IHZhbHVlcyBmb3IgdW5kZWZpbmVkIGZpZWxkc1xuXG5leHBvcnQgY29uc3QgcHJvbWlzZSA9IGFzeW5jIDxUPih7XG4gIGlkLFxuICBjb2xsZWN0aW9uLFxuICBjb250ZXh0LFxuICBkYXRhLFxuICBkb2MsXG4gIGZpZWxkLFxuICBnbG9iYWwsXG4gIG9wZXJhdGlvbixcbiAgb3ZlcnJpZGVBY2Nlc3MsXG4gIHJlcSxcbiAgc2libGluZ0RhdGEsXG4gIHNpYmxpbmdEb2MsXG59OiBBcmdzPFQ+KTogUHJvbWlzZTx2b2lkPiA9PiB7XG4gIGlmIChmaWVsZEFmZmVjdHNEYXRhKGZpZWxkKSkge1xuICAgIGlmIChmaWVsZC5uYW1lID09PSAnaWQnKSB7XG4gICAgICBpZiAoZmllbGQudHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdIGFzIHN0cmluZ1xuXG4gICAgICAgIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID0gcGFyc2VGbG9hdCh2YWx1ZSlcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBmaWVsZC50eXBlID09PSAndGV4dCcgJiZcbiAgICAgICAgdHlwZW9mIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdPy50b1N0cmluZyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2Ygc2libGluZ0RhdGFbZmllbGQubmFtZV0gIT09ICdzdHJpbmcnXG4gICAgICApIHtcbiAgICAgICAgc2libGluZ0RhdGFbZmllbGQubmFtZV0gPSBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXS50b1N0cmluZygpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2FuaXRpemUgaW5jb21pbmcgZGF0YVxuICAgIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzoge1xuICAgICAgICBpZiAodHlwZW9mIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gc2libGluZ0RhdGFbZmllbGQubmFtZV0gYXMgc3RyaW5nXG4gICAgICAgICAgY29uc3QgdHJpbW1lZCA9IHZhbHVlLnRyaW0oKVxuICAgICAgICAgIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID0gdHJpbW1lZC5sZW5ndGggPT09IDAgPyBudWxsIDogcGFyc2VGbG9hdCh0cmltbWVkKVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY2FzZSAncG9pbnQnOiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdKSkge1xuICAgICAgICAgIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID0gKHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdIGFzIHN0cmluZ1tdKS5tYXAoKGNvb3JkaW5hdGUsIGkpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29vcmRpbmF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXVtpXSBhcyBzdHJpbmdcbiAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZCA9IHZhbHVlLnRyaW0oKVxuICAgICAgICAgICAgICByZXR1cm4gdHJpbW1lZC5sZW5ndGggPT09IDAgPyBudWxsIDogcGFyc2VGbG9hdCh0cmltbWVkKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvb3JkaW5hdGVcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY2FzZSAnY2hlY2tib3gnOiB7XG4gICAgICAgIGlmIChzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSA9PT0gJ3RydWUnKSBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSA9IHRydWVcbiAgICAgICAgaWYgKHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID09PSAnZmFsc2UnKSBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSA9IGZhbHNlXG4gICAgICAgIGlmIChzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSA9PT0gJycpIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID0gZmFsc2VcblxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBjYXNlICdyaWNoVGV4dCc6IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmljaFRleHRKU09OID0gSlNPTi5wYXJzZShzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSBhcyBzdHJpbmcpXG4gICAgICAgICAgICBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSA9IHJpY2hUZXh0SlNPTlxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgLy8gRGlzcmVnYXJkIHRoaXMgZGF0YSBhcyBpdCBpcyBub3QgdmFsaWQuXG4gICAgICAgICAgICAvLyBXaWxsIGJlIHJlcG9ydGVkIHRvIHVzZXIgYnkgZmllbGQgdmFsaWRhdGlvblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbGF0aW9uc2hpcCc6XG4gICAgICBjYXNlICd1cGxvYWQnOiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSA9PT0gJycgfHxcbiAgICAgICAgICBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSA9PT0gJ25vbmUnIHx8XG4gICAgICAgICAgc2libGluZ0RhdGFbZmllbGQubmFtZV0gPT09ICdudWxsJyB8fFxuICAgICAgICAgIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID09PSBudWxsXG4gICAgICAgICkge1xuICAgICAgICAgIGlmIChmaWVsZC50eXBlID09PSAncmVsYXRpb25zaGlwJyAmJiBmaWVsZC5oYXNNYW55ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSA9IFtdXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlID0gc2libGluZ0RhdGFbZmllbGQubmFtZV1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZC5yZWxhdGlvblRvKSkge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgocmVsYXRlZERvYzogeyByZWxhdGlvblRvOiBzdHJpbmc7IHZhbHVlOiB1bmtub3duIH0sIGkpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVsYXRlZENvbGxlY3Rpb24gPSByZXEucGF5bG9hZC5jb25maWcuY29sbGVjdGlvbnMuZmluZChcbiAgICAgICAgICAgICAgICAoY29sbGVjdGlvbikgPT4gY29sbGVjdGlvbi5zbHVnID09PSByZWxhdGVkRG9jLnJlbGF0aW9uVG8sXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgY29uc3QgcmVsYXRpb25zaGlwSURGaWVsZCA9IHJlbGF0ZWRDb2xsZWN0aW9uLmZpZWxkcy5maW5kKFxuICAgICAgICAgICAgICAgIChjb2xsZWN0aW9uRmllbGQpID0+XG4gICAgICAgICAgICAgICAgICBmaWVsZEFmZmVjdHNEYXRhKGNvbGxlY3Rpb25GaWVsZCkgJiYgY29sbGVjdGlvbkZpZWxkLm5hbWUgPT09ICdpZCcsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgaWYgKHJlbGF0aW9uc2hpcElERmllbGQ/LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgc2libGluZ0RhdGFbZmllbGQubmFtZV1baV0gPSB7XG4gICAgICAgICAgICAgICAgICAuLi5yZWxhdGVkRG9jLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQocmVsYXRlZERvYy52YWx1ZSBhcyBzdHJpbmcpLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgZmllbGQudHlwZSA9PT0gJ3JlbGF0aW9uc2hpcCcgJiZcbiAgICAgICAgICAgIGZpZWxkLmhhc01hbnkgIT09IHRydWUgJiZcbiAgICAgICAgICAgIHZhbHVlSXNWYWx1ZVdpdGhSZWxhdGlvbih2YWx1ZSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0ZWRDb2xsZWN0aW9uID0gcmVxLnBheWxvYWQuY29uZmlnLmNvbGxlY3Rpb25zLmZpbmQoXG4gICAgICAgICAgICAgIChjb2xsZWN0aW9uKSA9PiBjb2xsZWN0aW9uLnNsdWcgPT09IHZhbHVlLnJlbGF0aW9uVG8sXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBjb25zdCByZWxhdGlvbnNoaXBJREZpZWxkID0gcmVsYXRlZENvbGxlY3Rpb24uZmllbGRzLmZpbmQoXG4gICAgICAgICAgICAgIChjb2xsZWN0aW9uRmllbGQpID0+XG4gICAgICAgICAgICAgICAgZmllbGRBZmZlY3RzRGF0YShjb2xsZWN0aW9uRmllbGQpICYmIGNvbGxlY3Rpb25GaWVsZC5uYW1lID09PSAnaWQnLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKHJlbGF0aW9uc2hpcElERmllbGQ/LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID0geyAuLi52YWx1ZSwgdmFsdWU6IHBhcnNlRmxvYXQodmFsdWUudmFsdWUgYXMgc3RyaW5nKSB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgocmVsYXRlZERvYzogdW5rbm93biwgaSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCByZWxhdGVkQ29sbGVjdGlvbiA9IHJlcS5wYXlsb2FkLmNvbmZpZy5jb2xsZWN0aW9ucy5maW5kKFxuICAgICAgICAgICAgICAgIChjb2xsZWN0aW9uKSA9PiBjb2xsZWN0aW9uLnNsdWcgPT09IGZpZWxkLnJlbGF0aW9uVG8sXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgY29uc3QgcmVsYXRpb25zaGlwSURGaWVsZCA9IHJlbGF0ZWRDb2xsZWN0aW9uLmZpZWxkcy5maW5kKFxuICAgICAgICAgICAgICAgIChjb2xsZWN0aW9uRmllbGQpID0+XG4gICAgICAgICAgICAgICAgICBmaWVsZEFmZmVjdHNEYXRhKGNvbGxlY3Rpb25GaWVsZCkgJiYgY29sbGVjdGlvbkZpZWxkLm5hbWUgPT09ICdpZCcsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgaWYgKHJlbGF0aW9uc2hpcElERmllbGQ/LnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgc2libGluZ0RhdGFbZmllbGQubmFtZV1baV0gPSBwYXJzZUZsb2F0KHJlbGF0ZWREb2MgYXMgc3RyaW5nKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmllbGQudHlwZSA9PT0gJ3JlbGF0aW9uc2hpcCcgJiYgZmllbGQuaGFzTWFueSAhPT0gdHJ1ZSAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgcmVsYXRlZENvbGxlY3Rpb24gPSByZXEucGF5bG9hZC5jb25maWcuY29sbGVjdGlvbnMuZmluZChcbiAgICAgICAgICAgICAgKGNvbGxlY3Rpb24pID0+IGNvbGxlY3Rpb24uc2x1ZyA9PT0gZmllbGQucmVsYXRpb25UbyxcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGNvbnN0IHJlbGF0aW9uc2hpcElERmllbGQgPSByZWxhdGVkQ29sbGVjdGlvbi5maWVsZHMuZmluZChcbiAgICAgICAgICAgICAgKGNvbGxlY3Rpb25GaWVsZCkgPT5cbiAgICAgICAgICAgICAgICBmaWVsZEFmZmVjdHNEYXRhKGNvbGxlY3Rpb25GaWVsZCkgJiYgY29sbGVjdGlvbkZpZWxkLm5hbWUgPT09ICdpZCcsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBpZiAocmVsYXRpb25zaGlwSURGaWVsZD8udHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgc2libGluZ0RhdGFbZmllbGQubmFtZV0gPSBwYXJzZUZsb2F0KHZhbHVlIGFzIHN0cmluZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cblxuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnYmxvY2tzJzoge1xuICAgICAgICAvLyBIYW5kbGUgY2FzZXMgb2YgYXJyYXlzIGJlaW5nIGludGVudGlvbmFsbHkgc2V0IHRvIDBcbiAgICAgICAgaWYgKHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID09PSAnMCcgfHwgc2libGluZ0RhdGFbZmllbGQubmFtZV0gPT09IDApIHtcbiAgICAgICAgICBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSA9IFtdXG4gICAgICAgIH1cblxuICAgICAgICBicmVha1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRXhlY3V0ZSBob29rc1xuICAgIGlmIChmaWVsZC5ob29rcz8uYmVmb3JlVmFsaWRhdGUpIHtcbiAgICAgIGF3YWl0IGZpZWxkLmhvb2tzLmJlZm9yZVZhbGlkYXRlLnJlZHVjZShhc3luYyAocHJpb3JIb29rLCBjdXJyZW50SG9vaykgPT4ge1xuICAgICAgICBhd2FpdCBwcmlvckhvb2tcblxuICAgICAgICBjb25zdCBob29rZWRWYWx1ZSA9IGF3YWl0IGN1cnJlbnRIb29rKHtcbiAgICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBmaWVsZCxcbiAgICAgICAgICBnbG9iYWwsXG4gICAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICAgIG9yaWdpbmFsRG9jOiBkb2MsXG4gICAgICAgICAgcmVxLFxuICAgICAgICAgIHNpYmxpbmdEYXRhLFxuICAgICAgICAgIHZhbHVlOiBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSxcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoaG9va2VkVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID0gaG9va2VkVmFsdWVcbiAgICAgICAgfVxuICAgICAgfSwgUHJvbWlzZS5yZXNvbHZlKCkpXG4gICAgfVxuXG4gICAgLy8gRXhlY3V0ZSBhY2Nlc3MgY29udHJvbFxuICAgIGlmIChmaWVsZC5hY2Nlc3MgJiYgZmllbGQuYWNjZXNzW29wZXJhdGlvbl0pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IG92ZXJyaWRlQWNjZXNzXG4gICAgICAgID8gdHJ1ZVxuICAgICAgICA6IGF3YWl0IGZpZWxkLmFjY2Vzc1tvcGVyYXRpb25dKHsgaWQsIGRhdGEsIGRvYywgcmVxLCBzaWJsaW5nRGF0YSB9KVxuXG4gICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBkZWxldGUgc2libGluZ0RhdGFbZmllbGQubmFtZV1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSWYgbm8gaW5jb21pbmcgZGF0YSwgYnV0IGV4aXN0aW5nIGRvY3VtZW50IGRhdGEgaXMgZm91bmQsIG1lcmdlIGl0IGluXG4gICAgICBpZiAodHlwZW9mIHNpYmxpbmdEb2NbZmllbGQubmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID0gY2xvbmVEYXRhRnJvbU9yaWdpbmFsRG9jKHNpYmxpbmdEb2NbZmllbGQubmFtZV0pXG5cbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNvbXB1dGUgZGVmYXVsdCB2YWx1ZVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZmllbGQuZGVmYXVsdFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSA9IGF3YWl0IGdldFZhbHVlV2l0aERlZmF1bHQoe1xuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZmllbGQuZGVmYXVsdFZhbHVlLFxuICAgICAgICAgIGxvY2FsZTogcmVxLmxvY2FsZSxcbiAgICAgICAgICB1c2VyOiByZXEudXNlcixcbiAgICAgICAgICB2YWx1ZTogc2libGluZ0RhdGFbZmllbGQubmFtZV0sXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVHJhdmVyc2Ugc3ViZmllbGRzXG4gIHN3aXRjaCAoZmllbGQudHlwZSkge1xuICAgIGNhc2UgJ2dyb3VwJzoge1xuICAgICAgaWYgKHR5cGVvZiBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSAhPT0gJ29iamVjdCcpIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdID0ge31cbiAgICAgIGlmICh0eXBlb2Ygc2libGluZ0RvY1tmaWVsZC5uYW1lXSAhPT0gJ29iamVjdCcpIHNpYmxpbmdEb2NbZmllbGQubmFtZV0gPSB7fVxuXG4gICAgICBjb25zdCBncm91cERhdGEgPSBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXSBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuICAgICAgY29uc3QgZ3JvdXBEb2MgPSBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+XG5cbiAgICAgIGF3YWl0IHRyYXZlcnNlRmllbGRzKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGRvYyxcbiAgICAgICAgZmllbGRzOiBmaWVsZC5maWVsZHMsXG4gICAgICAgIGdsb2JhbCxcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICBvdmVycmlkZUFjY2VzcyxcbiAgICAgICAgcmVxLFxuICAgICAgICBzaWJsaW5nRGF0YTogZ3JvdXBEYXRhLFxuICAgICAgICBzaWJsaW5nRG9jOiBncm91cERvYyxcbiAgICAgIH0pXG5cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgY2FzZSAnYXJyYXknOiB7XG4gICAgICBjb25zdCByb3dzID0gc2libGluZ0RhdGFbZmllbGQubmFtZV1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm93cykpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBbXVxuICAgICAgICByb3dzLmZvckVhY2goKHJvdykgPT4ge1xuICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICB0cmF2ZXJzZUZpZWxkcyh7XG4gICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICAgIGZpZWxkczogZmllbGQuZmllbGRzLFxuICAgICAgICAgICAgICBnbG9iYWwsXG4gICAgICAgICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgICAgICAgb3ZlcnJpZGVBY2Nlc3MsXG4gICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgc2libGluZ0RhdGE6IHJvdyxcbiAgICAgICAgICAgICAgc2libGluZ0RvYzogZ2V0RXhpc3RpbmdSb3dEb2Mocm93LCBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgIClcbiAgICAgICAgfSlcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGNhc2UgJ2Jsb2Nrcyc6IHtcbiAgICAgIGNvbnN0IHJvd3MgPSBzaWJsaW5nRGF0YVtmaWVsZC5uYW1lXVxuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyb3dzKSkge1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdXG4gICAgICAgIHJvd3MuZm9yRWFjaCgocm93KSA9PiB7XG4gICAgICAgICAgY29uc3Qgcm93U2libGluZ0RvYyA9IGdldEV4aXN0aW5nUm93RG9jKHJvdywgc2libGluZ0RvY1tmaWVsZC5uYW1lXSlcbiAgICAgICAgICBjb25zdCBibG9ja1R5cGVUb01hdGNoID0gcm93LmJsb2NrVHlwZSB8fCByb3dTaWJsaW5nRG9jLmJsb2NrVHlwZVxuICAgICAgICAgIGNvbnN0IGJsb2NrID0gZmllbGQuYmxvY2tzLmZpbmQoKGJsb2NrVHlwZSkgPT4gYmxvY2tUeXBlLnNsdWcgPT09IGJsb2NrVHlwZVRvTWF0Y2gpXG5cbiAgICAgICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgICAgIHJvdy5ibG9ja1R5cGUgPSBibG9ja1R5cGVUb01hdGNoXG5cbiAgICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgIHRyYXZlcnNlRmllbGRzKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICAgICAgZmllbGRzOiBibG9jay5maWVsZHMsXG4gICAgICAgICAgICAgICAgZ2xvYmFsLFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBvdmVycmlkZUFjY2VzcyxcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgc2libGluZ0RhdGE6IHJvdyxcbiAgICAgICAgICAgICAgICBzaWJsaW5nRG9jOiByb3dTaWJsaW5nRG9jLFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgICAgfVxuXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGNhc2UgJ3Jvdyc6XG4gICAgY2FzZSAnY29sbGFwc2libGUnOiB7XG4gICAgICBhd2FpdCB0cmF2ZXJzZUZpZWxkcyh7XG4gICAgICAgIGlkLFxuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBkYXRhLFxuICAgICAgICBkb2MsXG4gICAgICAgIGZpZWxkczogZmllbGQuZmllbGRzLFxuICAgICAgICBnbG9iYWwsXG4gICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgb3ZlcnJpZGVBY2Nlc3MsXG4gICAgICAgIHJlcSxcbiAgICAgICAgc2libGluZ0RhdGEsXG4gICAgICAgIHNpYmxpbmdEb2MsXG4gICAgICB9KVxuXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGNhc2UgJ3RhYic6IHtcbiAgICAgIGxldCB0YWJTaWJsaW5nRGF0YVxuICAgICAgbGV0IHRhYlNpYmxpbmdEb2NcbiAgICAgIGlmICh0YWJIYXNOYW1lKGZpZWxkKSkge1xuICAgICAgICBpZiAodHlwZW9mIHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdICE9PSAnb2JqZWN0Jykgc2libGluZ0RhdGFbZmllbGQubmFtZV0gPSB7fVxuICAgICAgICBpZiAodHlwZW9mIHNpYmxpbmdEb2NbZmllbGQubmFtZV0gIT09ICdvYmplY3QnKSBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdID0ge31cblxuICAgICAgICB0YWJTaWJsaW5nRGF0YSA9IHNpYmxpbmdEYXRhW2ZpZWxkLm5hbWVdIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICAgICAgIHRhYlNpYmxpbmdEb2MgPSBzaWJsaW5nRG9jW2ZpZWxkLm5hbWVdIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWJTaWJsaW5nRGF0YSA9IHNpYmxpbmdEYXRhXG4gICAgICAgIHRhYlNpYmxpbmdEb2MgPSBzaWJsaW5nRG9jXG4gICAgICB9XG5cbiAgICAgIGF3YWl0IHRyYXZlcnNlRmllbGRzKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGNvbGxlY3Rpb24sXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGRvYyxcbiAgICAgICAgZmllbGRzOiBmaWVsZC5maWVsZHMsXG4gICAgICAgIGdsb2JhbCxcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICBvdmVycmlkZUFjY2VzcyxcbiAgICAgICAgcmVxLFxuICAgICAgICBzaWJsaW5nRGF0YTogdGFiU2libGluZ0RhdGEsXG4gICAgICAgIHNpYmxpbmdEb2M6IHRhYlNpYmxpbmdEb2MsXG4gICAgICB9KVxuXG4gICAgICBicmVha1xuICAgIH1cblxuICAgIGNhc2UgJ3RhYnMnOiB7XG4gICAgICBhd2FpdCB0cmF2ZXJzZUZpZWxkcyh7XG4gICAgICAgIGlkLFxuICAgICAgICBjb2xsZWN0aW9uLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBkYXRhLFxuICAgICAgICBkb2MsXG4gICAgICAgIGZpZWxkczogZmllbGQudGFicy5tYXAoKHRhYikgPT4gKHsgLi4udGFiLCB0eXBlOiAndGFiJyB9KSksXG4gICAgICAgIGdsb2JhbCxcbiAgICAgICAgb3BlcmF0aW9uLFxuICAgICAgICBvdmVycmlkZUFjY2VzcyxcbiAgICAgICAgcmVxLFxuICAgICAgICBzaWJsaW5nRGF0YSxcbiAgICAgICAgc2libGluZ0RvYyxcbiAgICAgIH0pXG5cbiAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgZGVmYXVsdDoge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJwcm9taXNlIiwiaWQiLCJjb2xsZWN0aW9uIiwiY29udGV4dCIsImRhdGEiLCJkb2MiLCJmaWVsZCIsImdsb2JhbCIsIm9wZXJhdGlvbiIsIm92ZXJyaWRlQWNjZXNzIiwicmVxIiwic2libGluZ0RhdGEiLCJzaWJsaW5nRG9jIiwiZmllbGRBZmZlY3RzRGF0YSIsIm5hbWUiLCJ0eXBlIiwidmFsdWUiLCJwYXJzZUZsb2F0IiwidG9TdHJpbmciLCJ0cmltbWVkIiwidHJpbSIsImxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsImNvb3JkaW5hdGUiLCJpIiwicmljaFRleHRKU09OIiwiSlNPTiIsInBhcnNlIiwiaGFzTWFueSIsInJlbGF0aW9uVG8iLCJmb3JFYWNoIiwicmVsYXRlZERvYyIsInJlbGF0ZWRDb2xsZWN0aW9uIiwicGF5bG9hZCIsImNvbmZpZyIsImNvbGxlY3Rpb25zIiwiZmluZCIsInNsdWciLCJyZWxhdGlvbnNoaXBJREZpZWxkIiwiZmllbGRzIiwiY29sbGVjdGlvbkZpZWxkIiwidmFsdWVJc1ZhbHVlV2l0aFJlbGF0aW9uIiwiaG9va3MiLCJiZWZvcmVWYWxpZGF0ZSIsInJlZHVjZSIsInByaW9ySG9vayIsImN1cnJlbnRIb29rIiwiaG9va2VkVmFsdWUiLCJvcmlnaW5hbERvYyIsInVuZGVmaW5lZCIsIlByb21pc2UiLCJyZXNvbHZlIiwiYWNjZXNzIiwicmVzdWx0IiwiY2xvbmVEYXRhRnJvbU9yaWdpbmFsRG9jIiwiZGVmYXVsdFZhbHVlIiwiZ2V0VmFsdWVXaXRoRGVmYXVsdCIsImxvY2FsZSIsInVzZXIiLCJncm91cERhdGEiLCJncm91cERvYyIsInRyYXZlcnNlRmllbGRzIiwicm93cyIsInByb21pc2VzIiwicm93IiwicHVzaCIsImdldEV4aXN0aW5nUm93RG9jIiwiYWxsIiwicm93U2libGluZ0RvYyIsImJsb2NrVHlwZVRvTWF0Y2giLCJibG9ja1R5cGUiLCJibG9jayIsImJsb2NrcyIsInRhYlNpYmxpbmdEYXRhIiwidGFiU2libGluZ0RvYyIsInRhYkhhc05hbWUiLCJ0YWJzIiwidGFiIl0sIm1hcHBpbmdzIjoiQUFBQSxvQ0FBb0M7Ozs7K0JBa0N2QkE7OztlQUFBQTs7O3VCQTVCMEQ7d0VBQ3ZDOzBDQUNTO21DQUNQO2dDQUNIOzs7Ozs7QUF3QnhCLE1BQU1BLFVBQVUsT0FBVSxFQUMvQkMsRUFBRSxFQUNGQyxVQUFVLEVBQ1ZDLE9BQU8sRUFDUEMsSUFBSSxFQUNKQyxHQUFHLEVBQ0hDLEtBQUssRUFDTEMsTUFBTSxFQUNOQyxTQUFTLEVBQ1RDLGNBQWMsRUFDZEMsR0FBRyxFQUNIQyxXQUFXLEVBQ1hDLFVBQVUsRUFDRjtJQUNSLElBQUlDLElBQUFBLHVCQUFnQixFQUFDUCxRQUFRO1FBQzNCLElBQUlBLE1BQU1RLElBQUksS0FBSyxNQUFNO1lBQ3ZCLElBQUlSLE1BQU1TLElBQUksS0FBSyxZQUFZLE9BQU9KLFdBQVcsQ0FBQ0wsTUFBTVEsSUFBSSxDQUFDLEtBQUssVUFBVTtnQkFDMUUsTUFBTUUsUUFBUUwsV0FBVyxD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