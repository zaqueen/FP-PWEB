/* eslint-disable no-restricted-syntax, no-await-in-loop */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "migrateRefresh", {
    enumerable: true,
    get: function() {
        return migrateRefresh;
    }
});
const _getMigrations = require("./getMigrations");
const _readMigrationFiles = require("./readMigrationFiles");
async function migrateRefresh() {
    const { payload } = this;
    const migrationFiles = await (0, _readMigrationFiles.readMigrationFiles)({
        payload
    });
    const { existingMigrations, latestBatch } = await (0, _getMigrations.getMigrations)({
        payload
    });
    if (!existingMigrations?.length) {
        payload.logger.info({
            msg: 'No migrations to rollback.'
        });
        return;
    }
    payload.logger.info({
        msg: `Rolling back batch ${latestBatch} consisting of ${existingMigrations.length} migration(s).`
    });
    let transactionID;
    // Reverse order of migrations to rollback
    existingMigrations.reverse();
    for (const migration of existingMigrations){
        try {
            const migrationFile = migrationFiles.find((m)=>m.name === migration.name);
            if (!migrationFile) {
                throw new Error(`Migration ${migration.name} not found locally.`);
            }
            payload.logger.info({
                msg: `Migrating down: ${migration.name}`
            });
            const start = Date.now();
            transactionID = await this.beginTransaction();
            await migrationFile.down({
                payload
            });
            payload.logger.info({
                msg: `Migrated down:  ${migration.name} (${Date.now() - start}ms)`
            });
            await payload.delete({
                collection: 'payload-migrations',
                req: {
                    transactionID
                },
                where: {
                    name: {
                        equals: migration.name
                    }
                }
            });
        } catch (err) {
            await this.rollbackTransaction(transactionID);
            let msg = `Error running migration ${migration.name}. Rolling back.`;
            if (err instanceof Error) {
                msg += ` ${err.message}`;
            }
            payload.logger.error({
                err,
                msg
            });
            process.exit(1);
        }
    }
    // Run all migrate up
    for (const migration of migrationFiles){
        payload.logger.info({
            msg: `Migrating: ${migration.name}`
        });
        try {
            const start = Date.now();
            transactionID = await this.beginTransaction();
            await migration.up({
                payload
            });
            await payload.create({
                collection: 'payload-migrations',
                data: {
                    name: migration.name,
                    executed: true
                },
                req: {
                    transactionID
                }
            });
            await this.commitTransaction(transactionID);
            payload.logger.info({
                msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)`
            });
        } catch (err) {
            await this.rollbackTransaction(transactionID);
            let msg = `Error running migration ${migration.name}. Rolling back.`;
            if (err instanceof Error) {
                msg += ` ${err.message}`;
            }
            payload.logger.error({
                err,
                msg
            });
            process.exit(1);
        }
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kYXRhYmFzZS9taWdyYXRpb25zL21pZ3JhdGVSZWZyZXNoLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1hd2FpdC1pbi1sb29wICovXG5pbXBvcnQgdHlwZSB7IFBheWxvYWRSZXF1ZXN0IH0gZnJvbSAnLi4vLi4vZXhwcmVzcy90eXBlcydcbmltcG9ydCB0eXBlIHsgQmFzZURhdGFiYXNlQWRhcHRlciB9IGZyb20gJy4uL3R5cGVzJ1xuXG5pbXBvcnQgeyBnZXRNaWdyYXRpb25zIH0gZnJvbSAnLi9nZXRNaWdyYXRpb25zJ1xuaW1wb3J0IHsgcmVhZE1pZ3JhdGlvbkZpbGVzIH0gZnJvbSAnLi9yZWFkTWlncmF0aW9uRmlsZXMnXG5cbi8qKlxuICogUnVuIGFsbCBtaWdyYXRpb24gZG93biBmdW5jdGlvbnMgYmVmb3JlIHJ1bm5pbmcgdXBcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGVSZWZyZXNoKHRoaXM6IEJhc2VEYXRhYmFzZUFkYXB0ZXIpIHtcbiAgY29uc3QgeyBwYXlsb2FkIH0gPSB0aGlzXG4gIGNvbnN0IG1pZ3JhdGlvbkZpbGVzID0gYXdhaXQgcmVhZE1pZ3JhdGlvbkZpbGVzKHsgcGF5bG9hZCB9KVxuXG4gIGNvbnN0IHsgZXhpc3RpbmdNaWdyYXRpb25zLCBsYXRlc3RCYXRjaCB9ID0gYXdhaXQgZ2V0TWlncmF0aW9ucyh7XG4gICAgcGF5bG9hZCxcbiAgfSlcblxuICBpZiAoIWV4aXN0aW5nTWlncmF0aW9ucz8ubGVuZ3RoKSB7XG4gICAgcGF5bG9hZC5sb2dnZXIuaW5mbyh7IG1zZzogJ05vIG1pZ3JhdGlvbnMgdG8gcm9sbGJhY2suJyB9KVxuICAgIHJldHVyblxuICB9XG5cbiAgcGF5bG9hZC5sb2dnZXIuaW5mbyh7XG4gICAgbXNnOiBgUm9sbGluZyBiYWNrIGJhdGNoICR7bGF0ZXN0QmF0Y2h9IGNvbnNpc3Rpbmcgb2YgJHtleGlzdGluZ01pZ3JhdGlvbnMubGVuZ3RofSBtaWdyYXRpb24ocykuYCxcbiAgfSlcblxuICBsZXQgdHJhbnNhY3Rpb25JRFxuXG4gIC8vIFJldmVyc2Ugb3JkZXIgb2YgbWlncmF0aW9ucyB0byByb2xsYmFja1xuICBleGlzdGluZ01pZ3JhdGlvbnMucmV2ZXJzZSgpXG5cbiAgZm9yIChjb25zdCBtaWdyYXRpb24gb2YgZXhpc3RpbmdNaWdyYXRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG1pZ3JhdGlvbkZpbGUgPSBtaWdyYXRpb25GaWxlcy5maW5kKChtKSA9PiBtLm5hbWUgPT09IG1pZ3JhdGlvbi5uYW1lKVxuICAgICAgaWYgKCFtaWdyYXRpb25GaWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlncmF0aW9uICR7bWlncmF0aW9uLm5hbWV9IG5vdCBmb3VuZCBsb2NhbGx5LmApXG4gICAgICB9XG5cbiAgICAgIHBheWxvYWQubG9nZ2VyLmluZm8oeyBtc2c6IGBNaWdyYXRpbmcgZG93bjogJHttaWdyYXRpb24ubmFtZX1gIH0pXG4gICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KClcbiAgICAgIHRyYW5zYWN0aW9uSUQgPSBhd2FpdCB0aGlzLmJlZ2luVHJhbnNhY3Rpb24oKVxuICAgICAgYXdhaXQgbWlncmF0aW9uRmlsZS5kb3duKHsgcGF5bG9hZCB9KVxuICAgICAgcGF5bG9hZC5sb2dnZXIuaW5mbyh7XG4gICAgICAgIG1zZzogYE1pZ3JhdGVkIGRvd246ICAke21pZ3JhdGlvbi5uYW1lfSAoJHtEYXRlLm5vdygpIC0gc3RhcnR9bXMpYCxcbiAgICAgIH0pXG4gICAgICBhd2FpdCBwYXlsb2FkLmRlbGV0ZSh7XG4gICAgICAgIGNvbGxlY3Rpb246ICdwYXlsb2FkLW1pZ3JhdGlvbnMnLFxuICAgICAgICByZXE6IHtcbiAgICAgICAgICB0cmFuc2FjdGlvbklELFxuICAgICAgICB9IGFzIFBheWxvYWRSZXF1ZXN0LFxuICAgICAgICB3aGVyZToge1xuICAgICAgICAgIG5hbWU6IHtcbiAgICAgICAgICAgIGVxdWFsczogbWlncmF0aW9uLm5hbWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSBjYXRjaCAoZXJyOiB1bmtub3duKSB7XG4gICAgICBhd2FpdCB0aGlzLnJvbGxiYWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25JRClcbiAgICAgIGxldCBtc2cgPSBgRXJyb3IgcnVubmluZyBtaWdyYXRpb24gJHttaWdyYXRpb24ubmFtZX0uIFJvbGxpbmcgYmFjay5gXG4gICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgbXNnICs9IGAgJHtlcnIubWVzc2FnZX1gXG4gICAgICB9XG4gICAgICBwYXlsb2FkLmxvZ2dlci5lcnJvcih7XG4gICAgICAgIGVycixcbiAgICAgICAgbXNnLFxuICAgICAgfSlcbiAgICAgIHByb2Nlc3MuZXhpdCgxKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJ1biBhbGwgbWlncmF0ZSB1cFxuICBmb3IgKGNvbnN0IG1pZ3JhdGlvbiBvZiBtaWdyYXRpb25GaWxlcykge1xuICAgIHBheWxvYWQubG9nZ2VyLmluZm8oeyBtc2c6IGBNaWdyYXRpbmc6ICR7bWlncmF0aW9uLm5hbWV9YCB9KVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdGFydCA9IERhdGUubm93KClcbiAgICAgIHRyYW5zYWN0aW9uSUQgPSBhd2FpdCB0aGlzLmJlZ2luVHJhbnNhY3Rpb24oKVxuICAgICAgYXdhaXQgbWlncmF0aW9uLnVwKHsgcGF5bG9hZCB9KVxuICAgICAgYXdhaXQgcGF5bG9hZC5jcmVhdGUoe1xuICAgICAgICBjb2xsZWN0aW9uOiAncGF5bG9hZC1taWdyYXRpb25zJyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIG5hbWU6IG1pZ3JhdGlvbi5uYW1lLFxuICAgICAgICAgIGV4ZWN1dGVkOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICByZXE6IHtcbiAgICAgICAgICB0cmFuc2FjdGlvbklELFxuICAgICAgICB9IGFzIFBheWxvYWRSZXF1ZXN0LFxuICAgICAgfSlcbiAgICAgIGF3YWl0IHRoaXMuY29tbWl0VHJhbnNhY3Rpb24odHJhbnNhY3Rpb25JRClcblxuICAgICAgcGF5bG9hZC5sb2dnZXIuaW5mbyh7IG1zZzogYE1pZ3JhdGVkOiAgJHttaWdyYXRpb24ubmFtZX0gKCR7RGF0ZS5ub3coKSAtIHN0YXJ0fW1zKWAgfSlcbiAgICB9IGNhdGNoIChlcnI6IHVua25vd24pIHtcbiAgICAgIGF3YWl0IHRoaXMucm9sbGJhY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklEKVxuICAgICAgbGV0IG1zZyA9IGBFcnJvciBydW5uaW5nIG1pZ3JhdGlvbiAke21pZ3JhdGlvbi5uYW1lfS4gUm9sbGluZyBiYWNrLmBcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBtc2cgKz0gYCAke2Vyci5tZXNzYWdlfWBcbiAgICAgIH1cbiAgICAgIHBheWxvYWQubG9nZ2VyLmVycm9yKHtcbiAgICAgICAgZXJyLFxuICAgICAgICBtc2csXG4gICAgICB9KVxuICAgICAgcHJvY2Vzcy5leGl0KDEpXG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOlsibWlncmF0ZVJlZnJlc2giLCJwYXlsb2FkIiwibWlncmF0aW9uRmlsZXMiLCJyZWFkTWlncmF0aW9uRmlsZXMiLCJleGlzdGluZ01pZ3JhdGlvbnMiLCJsYXRlc3RCYXRjaCIsImdldE1pZ3JhdGlvbnMiLCJsZW5ndGgiLCJsb2dnZXIiLCJpbmZvIiwibXNnIiwidHJhbnNhY3Rpb25JRCIsInJldmVyc2UiLCJtaWdyYXRpb24iLCJtaWdyYXRpb25GaWxlIiwiZmluZCIsIm0iLCJuYW1lIiwiRXJyb3IiLCJzdGFydCIsIkRhdGUiLCJub3ciLCJiZWdpblRyYW5zYWN0aW9uIiwiZG93biIsImRlbGV0ZSIsImNvbGxlY3Rpb24iLCJyZXEiLCJ3aGVyZSIsImVxdWFscyIsImVyciIsInJvbGxiYWNrVHJhbnNhY3Rpb24iLCJtZXNzYWdlIiwiZXJyb3IiLCJwcm9jZXNzIiwiZXhpdCIsInVwIiwiY3JlYXRlIiwiZGF0YSIsImV4ZWN1dGVkIiwiY29tbWl0VHJhbnNhY3Rpb24iXSwibWFwcGluZ3MiOiJBQUFBLHlEQUF5RDs7OzsrQkFVbkNBOzs7ZUFBQUE7OzsrQkFOUTtvQ0FDSztBQUs1QixlQUFlQTtJQUNwQixNQUFNLEVBQUVDLE9BQU8sRUFBRSxHQUFHLElBQUk7SUFDeEIsTUFBTUMsaUJBQWlCLE1BQU1DLElBQUFBLHNDQUFrQixFQUFDO1FBQUVGO0lBQVE7SUFFMUQsTUFBTSxFQUFFRyxrQkFBa0IsRUFBRUMsV0FBVyxFQUFFLEdBQUcsTUFBTUMsSUFBQUEsNEJBQWEsRUFBQztRQUM5REw7SUFDRjtJQUVBLElBQUksQ0FBQ0csb0JBQW9CRyxRQUFRO1FBQy9CTixRQUFRTyxNQUFNLENBQUNDLElBQUksQ0FBQztZQUFFQyxLQUFLO1FBQTZCO1FBQ3hEO0lBQ0Y7SUFFQVQsUUFBUU8sTUFBTSxDQUFDQyxJQUFJLENBQUM7UUFDbEJDLEtBQUssQ0FBQyxtQkFBbUIsRUFBRUwsWUFBWSxlQUFlLEVBQUVELG1CQUFtQkcsTUFBTSxDQUFDLGNBQWMsQ0FBQztJQUNuRztJQUVBLElBQUlJO0lBRUosMENBQTBDO0lBQzFDUCxtQkFBbUJRLE9BQU87SUFFMUIsS0FBSyxNQUFNQyxhQUFhVCxtQkFBb0I7UUFDMUMsSUFBSTtZQUNGLE1BQU1VLGdCQUFnQlosZUFBZWEsSUFBSSxDQUFDLENBQUNDLElBQU1BLEVBQUVDLElBQUksS0FBS0osVUFBVUksSUFBSTtZQUMxRSxJQUFJLENBQUNILGVBQWU7Z0JBQ2xCLE1BQU0sSUFBSUksTUFBTSxDQUFDLFVBQVUsRUFBRUwsVUFBVUksSUFBSSxDQUFDLG1CQUFtQixDQUFDO1lBQ2xFO1lBRUFoQixRQUFRTyxNQUFNLENBQUNDLElBQUksQ0FBQztnQkFBRUMsS0FBSyxDQUFDLGdCQUFnQixFQUFFRyxVQUFVSSxJQUFJLENBQUMsQ0FBQztZQUFDO1lBQy9ELE1BQU1FLFFBQVFDLEtBQUtDLEdBQUc7WUFDdEJWLGdCQUFnQixNQUFNLElBQUksQ0FBQ1csZ0JBQWdCO1lBQzNDLE1BQU1SLGNBQWNTLElBQUksQ0FBQztnQkFBRXRCO1lBQVE7WUFDbkNBLFFBQVFPLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDO2dCQUNsQkMsS0FBSyxDQUFDLGdCQUFnQixFQUFFRyxVQUFVSSxJQUFJLENBQUMsRUFBRSxFQUFFRyxLQUFLQyxHQUFHLEtBQUtGLE1BQU0sR0FBRyxDQUFDO1lBQ3BFO1lBQ0EsTUFBTWxCLFFBQVF1QixNQUFNLENBQUM7Z0JBQ25CQyxZQUFZO2dCQUNaQyxLQUFLO29CQUNIZjtnQkFDRjtnQkFDQWdCLE9BQU87b0JBQ0xWLE1BQU07d0JBQ0pXLFFBQVFmLFVBQVVJLElBQUk7b0JBQ3hCO2dCQUNGO1lBQ0Y7UUFDRixFQUFFLE9BQU9ZLEtBQWM7WUFDckIsTUFBTSxJQUFJLENBQUNDLG1CQUFtQixDQUFDbkI7WUFDL0IsSUFBSUQsTUFBTSxDQUFDLHdCQUF3QixFQUFFRyxVQUFVSSxJQUFJLENBQUMsZUFBZSxDQUFDO1lBQ3BFLElBQUlZLGVBQWVYLE9BQU87Z0JBQ3hCUixPQUFPLENBQUMsQ0FBQyxFQUFFbUIsSUFBSUUsT0FBTyxDQUFDLENBQUM7WUFDMUI7WUFDQTlCLFFBQVFPLE1BQU0sQ0FBQ3dCLEtBQUssQ0FBQztnQkFDbkJIO2dCQUNBbkI7WUFDRjtZQUNBdUIsUUFBUUMsSUFBSSxDQUFDO1FBQ2Y7SUFDRjtJQUVBLHFCQUFxQjtJQUNyQixLQUFLLE1BQU1yQixhQUFhWCxlQUFnQjtRQUN0Q0QsUUFBUU8sTUFBTSxDQUFDQyxJQUFJLENBQUM7WUFBRUMsS0FBSyxDQUFDLFdBQVcsRUFBRUcsVUFBVUksSUFBSSxDQUFDLENBQUM7UUFBQztRQUMxRCxJQUFJO1lBQ0YsTUFBTUUsUUFBUUMsS0FBS0MsR0FBRztZQUN0QlYsZ0JBQWdCLE1BQU0sSUFBSSxDQUFDVyxnQkFBZ0I7WUFDM0MsTUFBTVQsVUFBVXNCLEVBQUUsQ0FBQztnQkFBRWxDO1lBQVE7WUFDN0IsTUFBTUEsUUFBUW1DLE1BQU0sQ0FBQztnQkFDbkJYLFlBQVk7Z0JBQ1pZLE1BQU07b0JBQ0pwQixNQUFNSixVQUFVSSxJQUFJO29CQUNwQnFCLFVBQVU7Z0JBQ1o7Z0JBQ0FaLEtBQUs7b0JBQ0hmO2dCQUNGO1lBQ0Y7WUFDQSxNQUFNLElBQUksQ0FBQzRCLGlCQUFpQixDQUFDNUI7WUFFN0JWLFFBQVFPLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDO2dCQUFFQyxLQUFLLENBQUMsV0FBVyxFQUFFRyxVQUFVSSxJQUFJLENBQUMsRUFBRSxFQUFFRyxLQUFLQyxHQUFHLEtBQUtGLE1BQU0sR0FBRyxDQUFDO1lBQUM7UUFDdEYsRUFBRSxPQUFPVSxLQUFjO1lBQ3JCLE1BQU0sSUFBSSxDQUFDQyxtQkFBbUIsQ0FBQ25CO1lBQy9CLElBQUlELE1BQU0sQ0FBQyx3QkFBd0IsRUFBRUcsVUFBVUksSUFBSSxDQUFDLGVBQWUsQ0FBQztZQUNwRSxJQUFJWSxlQUFlWCxPQUFPO2dCQUN4QlIsT0FBTyxDQUFDLENBQUMsRUFBRW1CLElBQUlFLE9BQU8sQ0FBQyxDQUFDO1lBQzFCO1lBQ0E5QixRQUFRTyxNQUFNLENBQUN3QixLQUFLLENBQUM7Z0JBQ25CSDtnQkFDQW5CO1lBQ0Y7WUFDQXVCLFFBQVFDLElBQUksQ0FBQztRQUNmO0lBQ0Y7QUFDRiJ9