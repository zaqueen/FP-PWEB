/* eslint-disable no-restricted-syntax, no-await-in-loop */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "migrate", {
    enumerable: true,
    get: function() {
        return migrate;
    }
});
const _getMigrations = require("./getMigrations");
const _readMigrationFiles = require("./readMigrationFiles");
async function migrate() {
    const { payload } = this;
    const migrationFiles = await (0, _readMigrationFiles.readMigrationFiles)({
        payload
    });
    const { existingMigrations, latestBatch } = await (0, _getMigrations.getMigrations)({
        payload
    });
    const newBatch = latestBatch + 1;
    // Execute 'up' function for each migration sequentially
    for (const migration of migrationFiles){
        const existingMigration = existingMigrations.find((existing)=>existing.name === migration.name);
        // Run migration if not found in database
        if (existingMigration) {
            continue; // eslint-disable-line no-continue
        }
        const start = Date.now();
        let transactionID;
        payload.logger.info({
            msg: `Migrating: ${migration.name}`
        });
        try {
            transactionID = await this.beginTransaction();
            await migration.up({
                payload
            });
            payload.logger.info({
                msg: `Migrated:  ${migration.name} (${Date.now() - start}ms)`
            });
            await payload.create({
                collection: 'payload-migrations',
                data: {
                    name: migration.name,
                    batch: newBatch
                },
                ...transactionID && {
                    req: {
                        transactionID
                    }
                }
            });
            await this.commitTransaction(transactionID);
        } catch (err) {
            await this.rollbackTransaction(transactionID);
            payload.logger.error({
                err,
                msg: `Error running migration ${migration.name}`
            });
            throw err;
        }
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9kYXRhYmFzZS9taWdyYXRpb25zL21pZ3JhdGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWF3YWl0LWluLWxvb3AgKi9cbmltcG9ydCB0eXBlIHsgUGF5bG9hZFJlcXVlc3QgfSBmcm9tICcuLi8uLi9leHByZXNzL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBCYXNlRGF0YWJhc2VBZGFwdGVyIH0gZnJvbSAnLi4vdHlwZXMnXG5cbmltcG9ydCB7IGdldE1pZ3JhdGlvbnMgfSBmcm9tICcuL2dldE1pZ3JhdGlvbnMnXG5pbXBvcnQgeyByZWFkTWlncmF0aW9uRmlsZXMgfSBmcm9tICcuL3JlYWRNaWdyYXRpb25GaWxlcydcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1pZ3JhdGUodGhpczogQmFzZURhdGFiYXNlQWRhcHRlcik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCB7IHBheWxvYWQgfSA9IHRoaXNcbiAgY29uc3QgbWlncmF0aW9uRmlsZXMgPSBhd2FpdCByZWFkTWlncmF0aW9uRmlsZXMoeyBwYXlsb2FkIH0pXG4gIGNvbnN0IHsgZXhpc3RpbmdNaWdyYXRpb25zLCBsYXRlc3RCYXRjaCB9ID0gYXdhaXQgZ2V0TWlncmF0aW9ucyh7IHBheWxvYWQgfSlcblxuICBjb25zdCBuZXdCYXRjaCA9IGxhdGVzdEJhdGNoICsgMVxuXG4gIC8vIEV4ZWN1dGUgJ3VwJyBmdW5jdGlvbiBmb3IgZWFjaCBtaWdyYXRpb24gc2VxdWVudGlhbGx5XG4gIGZvciAoY29uc3QgbWlncmF0aW9uIG9mIG1pZ3JhdGlvbkZpbGVzKSB7XG4gICAgY29uc3QgZXhpc3RpbmdNaWdyYXRpb24gPSBleGlzdGluZ01pZ3JhdGlvbnMuZmluZChcbiAgICAgIChleGlzdGluZykgPT4gZXhpc3RpbmcubmFtZSA9PT0gbWlncmF0aW9uLm5hbWUsXG4gICAgKVxuXG4gICAgLy8gUnVuIG1pZ3JhdGlvbiBpZiBub3QgZm91bmQgaW4gZGF0YWJhc2VcbiAgICBpZiAoZXhpc3RpbmdNaWdyYXRpb24pIHtcbiAgICAgIGNvbnRpbnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydCA9IERhdGUubm93KClcbiAgICBsZXQgdHJhbnNhY3Rpb25JRDogbnVtYmVyIHwgc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgICBwYXlsb2FkLmxvZ2dlci5pbmZvKHsgbXNnOiBgTWlncmF0aW5nOiAke21pZ3JhdGlvbi5uYW1lfWAgfSlcblxuICAgIHRyeSB7XG4gICAgICB0cmFuc2FjdGlvbklEID0gYXdhaXQgdGhpcy5iZWdpblRyYW5zYWN0aW9uKClcbiAgICAgIGF3YWl0IG1pZ3JhdGlvbi51cCh7IHBheWxvYWQgfSlcbiAgICAgIHBheWxvYWQubG9nZ2VyLmluZm8oeyBtc2c6IGBNaWdyYXRlZDogICR7bWlncmF0aW9uLm5hbWV9ICgke0RhdGUubm93KCkgLSBzdGFydH1tcylgIH0pXG4gICAgICBhd2FpdCBwYXlsb2FkLmNyZWF0ZSh7XG4gICAgICAgIGNvbGxlY3Rpb246ICdwYXlsb2FkLW1pZ3JhdGlvbnMnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgbmFtZTogbWlncmF0aW9uLm5hbWUsXG4gICAgICAgICAgYmF0Y2g6IG5ld0JhdGNoLFxuICAgICAgICB9LFxuICAgICAgICAuLi4odHJhbnNhY3Rpb25JRCAmJiB7IHJlcTogeyB0cmFuc2FjdGlvbklEIH0gYXMgUGF5bG9hZFJlcXVlc3QgfSksXG4gICAgICB9KVxuICAgICAgYXdhaXQgdGhpcy5jb21taXRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbklEKVxuICAgIH0gY2F0Y2ggKGVycjogdW5rbm93bikge1xuICAgICAgYXdhaXQgdGhpcy5yb2xsYmFja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSUQpXG4gICAgICBwYXlsb2FkLmxvZ2dlci5lcnJvcih7IGVyciwgbXNnOiBgRXJyb3IgcnVubmluZyBtaWdyYXRpb24gJHttaWdyYXRpb24ubmFtZX1gIH0pXG4gICAgICB0aHJvdyBlcnJcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJtaWdyYXRlIiwicGF5bG9hZCIsIm1pZ3JhdGlvbkZpbGVzIiwicmVhZE1pZ3JhdGlvbkZpbGVzIiwiZXhpc3RpbmdNaWdyYXRpb25zIiwibGF0ZXN0QmF0Y2giLCJnZXRNaWdyYXRpb25zIiwibmV3QmF0Y2giLCJtaWdyYXRpb24iLCJleGlzdGluZ01pZ3JhdGlvbiIsImZpbmQiLCJleGlzdGluZyIsIm5hbWUiLCJzdGFydCIsIkRhdGUiLCJub3ciLCJ0cmFuc2FjdGlvbklEIiwibG9nZ2VyIiwiaW5mbyIsIm1zZyIsImJlZ2luVHJhbnNhY3Rpb24iLCJ1cCIsImNyZWF0ZSIsImNvbGxlY3Rpb24iLCJkYXRhIiwiYmF0Y2giLCJyZXEiLCJjb21taXRUcmFuc2FjdGlvbiIsImVyciIsInJvbGxiYWNrVHJhbnNhY3Rpb24iLCJlcnJvciJdLCJtYXBwaW5ncyI6IkFBQUEseURBQXlEOzs7OytCQU9uQ0E7OztlQUFBQTs7OytCQUhRO29DQUNLO0FBRTVCLGVBQWVBO0lBQ3BCLE1BQU0sRUFBRUMsT0FBTyxFQUFFLEdBQUcsSUFBSTtJQUN4QixNQUFNQyxpQkFBaUIsTUFBTUMsSUFBQUEsc0NBQWtCLEVBQUM7UUFBRUY7SUFBUTtJQUMxRCxNQUFNLEVBQUVHLGtCQUFrQixFQUFFQyxXQUFXLEVBQUUsR0FBRyxNQUFNQyxJQUFBQSw0QkFBYSxFQUFDO1FBQUVMO0lBQVE7SUFFMUUsTUFBTU0sV0FBV0YsY0FBYztJQUUvQix3REFBd0Q7SUFDeEQsS0FBSyxNQUFNRyxhQUFhTixlQUFnQjtRQUN0QyxNQUFNTyxvQkFBb0JMLG1CQUFtQk0sSUFBSSxDQUMvQyxDQUFDQyxXQUFhQSxTQUFTQyxJQUFJLEtBQUtKLFVBQVVJLElBQUk7UUFHaEQseUNBQXlDO1FBQ3pDLElBQUlILG1CQUFtQjtZQUNyQixVQUFTLGtDQUFrQztRQUM3QztRQUVBLE1BQU1JLFFBQVFDLEtBQUtDLEdBQUc7UUFDdEIsSUFBSUM7UUFFSmYsUUFBUWdCLE1BQU0sQ0FBQ0MsSUFBSSxDQUFDO1lBQUVDLEtBQUssQ0FBQyxXQUFXLEVBQUVYLFVBQVVJLElBQUksQ0FBQyxDQUFDO1FBQUM7UUFFMUQsSUFBSTtZQUNGSSxnQkFBZ0IsTUFBTSxJQUFJLENBQUNJLGdCQUFnQjtZQUMzQyxNQUFNWixVQUFVYSxFQUFFLENBQUM7Z0JBQUVwQjtZQUFRO1lBQzdCQSxRQUFRZ0IsTUFBTSxDQUFDQyxJQUFJLENBQUM7Z0JBQUVDLEtBQUssQ0FBQyxXQUFXLEVBQUVYLFVBQVVJLElBQUksQ0FBQyxFQUFFLEVBQUVFLEtBQUtDLEdBQUcsS0FBS0YsTUFBTSxHQUFHLENBQUM7WUFBQztZQUNwRixNQUFNWixRQUFRcUIsTUFBTSxDQUFDO2dCQUNuQkMsWUFBWTtnQkFDWkMsTUFBTTtvQkFDSlosTUFBTUosVUFBVUksSUFBSTtvQkFDcEJhLE9BQU9sQjtnQkFDVDtnQkFDQSxHQUFJUyxpQkFBaUI7b0JBQUVVLEtBQUs7d0JBQUVWO29CQUFjO2dCQUFvQixDQUFDO1lBQ25FO1lBQ0EsTUFBTSxJQUFJLENBQUNXLGlCQUFpQixDQUFDWDtRQUMvQixFQUFFLE9BQU9ZLEtBQWM7WUFDckIsTUFBTSxJQUFJLENBQUNDLG1CQUFtQixDQUFDYjtZQUMvQmYsUUFBUWdCLE1BQU0sQ0FBQ2EsS0FBSyxDQUFDO2dCQUFFRjtnQkFBS1QsS0FBSyxDQUFDLHdCQUF3QixFQUFFWCxVQUFVSSxJQUFJLENBQUMsQ0FBQztZQUFDO1lBQzdFLE1BQU1nQjtRQUNSO0lBQ0Y7QUFDRiJ9