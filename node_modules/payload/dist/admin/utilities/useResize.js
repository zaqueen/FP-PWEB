"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useResize", {
    enumerable: true,
    get: function() {
        return useResize;
    }
});
const _react = require("react");
const useResize = (ref)=>{
    const [size, setSize] = (0, _react.useState)();
    (0, _react.useEffect)(()=>{
        let observer// eslint-disable-line
        ;
        const { current: currentRef } = ref;
        if (currentRef) {
            observer = new ResizeObserver((entries)=>{
                entries.forEach((entry)=>{
                    const { contentBoxSize, contentRect } = entry;
                    let newWidth = 0;
                    let newHeight = 0;
                    if (contentBoxSize) {
                        const newSize = Array.isArray(contentBoxSize) ? contentBoxSize[0] : contentBoxSize;
                        if (newSize) {
                            const { blockSize, inlineSize } = newSize;
                            newWidth = inlineSize;
                            newHeight = blockSize;
                        }
                    } else if (contentRect) {
                        // see note above for why this block is needed
                        const { height, width } = contentRect;
                        newWidth = width;
                        newHeight = height;
                    }
                    setSize({
                        height: newHeight,
                        width: newWidth
                    });
                });
            });
            observer.observe(currentRef);
        }
        return ()=>{
            if (observer) {
                observer.unobserve(currentRef);
            }
        };
    }, [
        ref
    ]);
    return {
        size
    };
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hZG1pbi91dGlsaXRpZXMvdXNlUmVzaXplLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIFJlYWN0IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5cbmludGVyZmFjZSBTaXplIHtcbiAgaGVpZ2h0OiBudW1iZXJcbiAgd2lkdGg6IG51bWJlclxufVxuXG5pbnRlcmZhY2UgUmVzaXplIHtcbiAgc2l6ZT86IFNpemVcbn1cblxuZXhwb3J0IGNvbnN0IHVzZVJlc2l6ZSA9IChyZWY6IFJlYWN0Lk11dGFibGVSZWZPYmplY3Q8SFRNTEVsZW1lbnQ+KTogUmVzaXplID0+IHtcbiAgY29uc3QgW3NpemUsIHNldFNpemVdID0gdXNlU3RhdGU8U2l6ZT4oKVxuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG9ic2VydmVyOiBhbnkgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4gICAgY29uc3QgeyBjdXJyZW50OiBjdXJyZW50UmVmIH0gPSByZWZcblxuICAgIGlmIChjdXJyZW50UmVmKSB7XG4gICAgICBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29udGVudEJveFNpemUsXG4gICAgICAgICAgICBjb250ZW50UmVjdCwgLy8gZm9yIFNhZmFyaSBpT1MgY29tcGF0aWJpbGl0eSwgd2lsbCBiZSBkZXByZWNhdGVkIGV2ZW50dWFsbHkgKHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUmVzaXplT2JzZXJ2ZXJFbnRyeS9jb250ZW50UmVjdClcbiAgICAgICAgICB9ID0gZW50cnlcblxuICAgICAgICAgIGxldCBuZXdXaWR0aCA9IDBcbiAgICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gMFxuXG4gICAgICAgICAgaWYgKGNvbnRlbnRCb3hTaXplKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTaXplID0gQXJyYXkuaXNBcnJheShjb250ZW50Qm94U2l6ZSkgPyBjb250ZW50Qm94U2l6ZVswXSA6IGNvbnRlbnRCb3hTaXplXG5cbiAgICAgICAgICAgIGlmIChuZXdTaXplKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgYmxvY2tTaXplLCBpbmxpbmVTaXplIH0gPSBuZXdTaXplXG4gICAgICAgICAgICAgIG5ld1dpZHRoID0gaW5saW5lU2l6ZVxuICAgICAgICAgICAgICBuZXdIZWlnaHQgPSBibG9ja1NpemVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbnRlbnRSZWN0KSB7XG4gICAgICAgICAgICAvLyBzZWUgbm90ZSBhYm92ZSBmb3Igd2h5IHRoaXMgYmxvY2sgaXMgbmVlZGVkXG4gICAgICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IGNvbnRlbnRSZWN0XG4gICAgICAgICAgICBuZXdXaWR0aCA9IHdpZHRoXG4gICAgICAgICAgICBuZXdIZWlnaHQgPSBoZWlnaHRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRTaXplKHtcbiAgICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IG5ld1dpZHRoLFxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9KVxuXG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGN1cnJlbnRSZWYpXG4gICAgfVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoY3VycmVudFJlZilcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtyZWZdKVxuXG4gIHJldHVybiB7XG4gICAgc2l6ZSxcbiAgfVxufVxuIl0sIm5hbWVzIjpbInVzZVJlc2l6ZSIsInJlZiIsInNpemUiLCJzZXRTaXplIiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJvYnNlcnZlciIsImN1cnJlbnQiLCJjdXJyZW50UmVmIiwiUmVzaXplT2JzZXJ2ZXIiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImVudHJ5IiwiY29udGVudEJveFNpemUiLCJjb250ZW50UmVjdCIsIm5ld1dpZHRoIiwibmV3SGVpZ2h0IiwibmV3U2l6ZSIsIkFycmF5IiwiaXNBcnJheSIsImJsb2NrU2l6ZSIsImlubGluZVNpemUiLCJoZWlnaHQiLCJ3aWR0aCIsIm9ic2VydmUiLCJ1bm9ic2VydmUiXSwibWFwcGluZ3MiOiI7Ozs7K0JBYWFBOzs7ZUFBQUE7Ozt1QkFYdUI7QUFXN0IsTUFBTUEsWUFBWSxDQUFDQztJQUN4QixNQUFNLENBQUNDLE1BQU1DLFFBQVEsR0FBR0MsSUFBQUEsZUFBUTtJQUVoQ0MsSUFBQUEsZ0JBQVMsRUFBQztRQUNSLElBQUlDLFFBQWMsc0JBQXNCOztRQUV4QyxNQUFNLEVBQUVDLFNBQVNDLFVBQVUsRUFBRSxHQUFHUDtRQUVoQyxJQUFJTyxZQUFZO1lBQ2RGLFdBQVcsSUFBSUcsZUFBZSxDQUFDQztnQkFDN0JBLFFBQVFDLE9BQU8sQ0FBQyxDQUFDQztvQkFDZixNQUFNLEVBQ0pDLGNBQWMsRUFDZEMsV0FBVyxFQUNaLEdBQUdGO29CQUVKLElBQUlHLFdBQVc7b0JBQ2YsSUFBSUMsWUFBWTtvQkFFaEIsSUFBSUgsZ0JBQWdCO3dCQUNsQixNQUFNSSxVQUFVQyxNQUFNQyxPQUFPLENBQUNOLGtCQUFrQkEsY0FBYyxDQUFDLEVBQUUsR0FBR0E7d0JBRXBFLElBQUlJLFNBQVM7NEJBQ1gsTUFBTSxFQUFFRyxTQUFTLEVBQUVDLFVBQVUsRUFBRSxHQUFHSjs0QkFDbENGLFdBQVdNOzRCQUNYTCxZQUFZSTt3QkFDZDtvQkFDRixPQUFPLElBQUlOLGFBQWE7d0JBQ3RCLDhDQUE4Qzt3QkFDOUMsTUFBTSxFQUFFUSxNQUFNLEVBQUVDLEtBQUssRUFBRSxHQUFHVDt3QkFDMUJDLFdBQVdRO3dCQUNYUCxZQUFZTTtvQkFDZDtvQkFFQW5CLFFBQVE7d0JBQ05tQixRQUFRTjt3QkFDUk8sT0FBT1I7b0JBQ1Q7Z0JBQ0Y7WUFDRjtZQUVBVCxTQUFTa0IsT0FBTyxDQUFDaEI7UUFDbkI7UUFFQSxPQUFPO1lBQ0wsSUFBSUYsVUFBVTtnQkFDWkEsU0FBU21CLFNBQVMsQ0FBQ2pCO1lBQ3JCO1FBQ0Y7SUFDRixHQUFHO1FBQUNQO0tBQUk7SUFFUixPQUFPO1FBQ0xDO0lBQ0Y7QUFDRiJ9