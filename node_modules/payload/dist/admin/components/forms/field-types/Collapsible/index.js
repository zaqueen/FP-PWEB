"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _Collapsible = require("../../../elements/Collapsible");
const _ErrorPill = require("../../../elements/ErrorPill");
const _DocumentInfo = require("../../../utilities/DocumentInfo");
const _Preferences = require("../../../utilities/Preferences");
const _FieldDescription = /*#__PURE__*/ _interop_require_default(require("../../FieldDescription"));
const _context = require("../../Form/context");
const _createNestedFieldPath = require("../../Form/createNestedFieldPath");
const _RenderFields = /*#__PURE__*/ _interop_require_default(require("../../RenderFields"));
const _RowLabel = require("../../RowLabel");
const _WatchChildErrors = require("../../WatchChildErrors");
const _withCondition = /*#__PURE__*/ _interop_require_default(require("../../withCondition"));
require("./index.scss");
const _shared = require("../shared");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'collapsible-field';
const CollapsibleField = (props)=>{
    const { admin: { className, description, initCollapsed, readOnly }, fieldTypes, fields, indexPath, label, path, permissions } = props;
    const { getPreference, setPreference } = (0, _Preferences.usePreferences)();
    const { preferencesKey } = (0, _DocumentInfo.useDocumentInfo)();
    const [collapsedOnMount, setCollapsedOnMount] = (0, _react.useState)();
    const fieldPreferencesKey = `collapsible-${indexPath.replace(/\./g, '__')}`;
    const [errorCount, setErrorCount] = (0, _react.useState)(0);
    const submitted = (0, _context.useFormSubmitted)();
    const onToggle = (0, _react.useCallback)(async (newCollapsedState)=>{
        const existingPreferences = await getPreference(preferencesKey);
        setPreference(preferencesKey, {
            ...existingPreferences,
            ...path ? {
                fields: {
                    ...existingPreferences?.fields || {},
                    [path]: {
                        ...existingPreferences?.fields?.[path],
                        collapsed: newCollapsedState
                    }
                }
            } : {
                fields: {
                    ...existingPreferences?.fields || {},
                    [fieldPreferencesKey]: {
                        ...existingPreferences?.fields?.[fieldPreferencesKey],
                        collapsed: newCollapsedState
                    }
                }
            }
        });
    }, [
        preferencesKey,
        fieldPreferencesKey,
        getPreference,
        setPreference,
        path
    ]);
    (0, _react.useEffect)(()=>{
        const fetchInitialState = async ()=>{
            const preferences = await getPreference(preferencesKey);
            if (preferences) {
                const initCollapsedFromPref = path ? preferences?.fields?.[path]?.collapsed : preferences?.fields?.[fieldPreferencesKey]?.collapsed;
                setCollapsedOnMount(Boolean(initCollapsedFromPref));
            } else {
                setCollapsedOnMount(typeof initCollapsed === 'boolean' ? initCollapsed : false);
            }
        };
        fetchInitialState();
    }, [
        getPreference,
        preferencesKey,
        fieldPreferencesKey,
        initCollapsed,
        path
    ]);
    if (typeof collapsedOnMount !== 'boolean') return null;
    const fieldHasErrors = submitted && errorCount > 0;
    return /*#__PURE__*/ _react.default.createElement("div", {
        id: `field-${fieldPreferencesKey}${path ? `-${path.replace(/\./g, '__')}` : ''}`,
        className: [
            _shared.fieldBaseClass,
            baseClass,
            className,
            fieldHasErrors ? `${baseClass}--has-error` : `${baseClass}--has-no-error`
        ].filter(Boolean).join(' ')
    }, /*#__PURE__*/ _react.default.createElement(_WatchChildErrors.WatchChildErrors, {
        fieldSchema: fields,
        path: path,
        setErrorCount: setErrorCount
    }), /*#__PURE__*/ _react.default.createElement(_Collapsible.Collapsible, {
        className: `${baseClass}__collapsible`,
        collapsibleStyle: errorCount > 0 ? 'error' : 'default',
        header: /*#__PURE__*/ _react.default.createElement("div", {
            className: `${baseClass}__row-label-wrap`
        }, /*#__PURE__*/ _react.default.createElement(_RowLabel.RowLabel, {
            label: label,
            path: path
        }), errorCount > 0 && /*#__PURE__*/ _react.default.createElement(_ErrorPill.ErrorPill, {
            count: errorCount,
            withMessage: true
        })),
        initCollapsed: collapsedOnMount,
        onToggle: onToggle
    }, /*#__PURE__*/ _react.default.createElement(_RenderFields.default, {
        fieldSchema: fields.map((field)=>({
                ...field,
                path: (0, _createNestedFieldPath.createNestedFieldPath)(path, field)
            })),
        fieldTypes: fieldTypes,
        forceRender: true,
        indexPath: indexPath,
        margins: "small",
        permissions: permissions,
        readOnly: readOnly
    })), /*#__PURE__*/ _react.default.createElement(_FieldDescription.default, {
        description: description
    }));
};
const _default = (0, _withCondition.default)(CollapsibleField);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2Zvcm1zL2ZpZWxkLXR5cGVzL0NvbGxhcHNpYmxlL2luZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcblxuaW1wb3J0IHR5cGUgeyBEb2N1bWVudFByZWZlcmVuY2VzIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vcHJlZmVyZW5jZXMvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFByb3BzIH0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IHsgQ29sbGFwc2libGUgfSBmcm9tICcuLi8uLi8uLi9lbGVtZW50cy9Db2xsYXBzaWJsZSdcbmltcG9ydCB7IEVycm9yUGlsbCB9IGZyb20gJy4uLy4uLy4uL2VsZW1lbnRzL0Vycm9yUGlsbCdcbmltcG9ydCB7IHVzZURvY3VtZW50SW5mbyB9IGZyb20gJy4uLy4uLy4uL3V0aWxpdGllcy9Eb2N1bWVudEluZm8nXG5pbXBvcnQgeyB1c2VQcmVmZXJlbmNlcyB9IGZyb20gJy4uLy4uLy4uL3V0aWxpdGllcy9QcmVmZXJlbmNlcydcbmltcG9ydCBGaWVsZERlc2NyaXB0aW9uIGZyb20gJy4uLy4uL0ZpZWxkRGVzY3JpcHRpb24nXG5pbXBvcnQgeyB1c2VGb3JtU3VibWl0dGVkIH0gZnJvbSAnLi4vLi4vRm9ybS9jb250ZXh0J1xuaW1wb3J0IHsgY3JlYXRlTmVzdGVkRmllbGRQYXRoIH0gZnJvbSAnLi4vLi4vRm9ybS9jcmVhdGVOZXN0ZWRGaWVsZFBhdGgnXG5pbXBvcnQgUmVuZGVyRmllbGRzIGZyb20gJy4uLy4uL1JlbmRlckZpZWxkcydcbmltcG9ydCB7IFJvd0xhYmVsIH0gZnJvbSAnLi4vLi4vUm93TGFiZWwnXG5pbXBvcnQgeyBXYXRjaENoaWxkRXJyb3JzIH0gZnJvbSAnLi4vLi4vV2F0Y2hDaGlsZEVycm9ycydcbmltcG9ydCB3aXRoQ29uZGl0aW9uIGZyb20gJy4uLy4uL3dpdGhDb25kaXRpb24nXG5pbXBvcnQgJy4vaW5kZXguc2NzcydcbmltcG9ydCB7IGZpZWxkQmFzZUNsYXNzIH0gZnJvbSAnLi4vc2hhcmVkJ1xuXG5jb25zdCBiYXNlQ2xhc3MgPSAnY29sbGFwc2libGUtZmllbGQnXG5cbmNvbnN0IENvbGxhcHNpYmxlRmllbGQ6IFJlYWN0LkZDPFByb3BzPiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgYWRtaW46IHsgY2xhc3NOYW1lLCBkZXNjcmlwdGlvbiwgaW5pdENvbGxhcHNlZCwgcmVhZE9ubHkgfSxcbiAgICBmaWVsZFR5cGVzLFxuICAgIGZpZWxkcyxcbiAgICBpbmRleFBhdGgsXG4gICAgbGFiZWwsXG4gICAgcGF0aCxcbiAgICBwZXJtaXNzaW9ucyxcbiAgfSA9IHByb3BzXG5cbiAgY29uc3QgeyBnZXRQcmVmZXJlbmNlLCBzZXRQcmVmZXJlbmNlIH0gPSB1c2VQcmVmZXJlbmNlcygpXG4gIGNvbnN0IHsgcHJlZmVyZW5jZXNLZXkgfSA9IHVzZURvY3VtZW50SW5mbygpXG4gIGNvbnN0IFtjb2xsYXBzZWRPbk1vdW50LCBzZXRDb2xsYXBzZWRPbk1vdW50XSA9IHVzZVN0YXRlPGJvb2xlYW4+KClcbiAgY29uc3QgZmllbGRQcmVmZXJlbmNlc0tleSA9IGBjb2xsYXBzaWJsZS0ke2luZGV4UGF0aC5yZXBsYWNlKC9cXC4vZywgJ19fJyl9YFxuICBjb25zdCBbZXJyb3JDb3VudCwgc2V0RXJyb3JDb3VudF0gPSB1c2VTdGF0ZSgwKVxuICBjb25zdCBzdWJtaXR0ZWQgPSB1c2VGb3JtU3VibWl0dGVkKClcblxuICBjb25zdCBvblRvZ2dsZSA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChuZXdDb2xsYXBzZWRTdGF0ZTogYm9vbGVhbikgPT4ge1xuICAgICAgY29uc3QgZXhpc3RpbmdQcmVmZXJlbmNlczogRG9jdW1lbnRQcmVmZXJlbmNlcyA9IGF3YWl0IGdldFByZWZlcmVuY2UocHJlZmVyZW5jZXNLZXkpXG5cbiAgICAgIHNldFByZWZlcmVuY2UocHJlZmVyZW5jZXNLZXksIHtcbiAgICAgICAgLi4uZXhpc3RpbmdQcmVmZXJlbmNlcyxcbiAgICAgICAgLi4uKHBhdGhcbiAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICAgICAgLi4uKGV4aXN0aW5nUHJlZmVyZW5jZXM/LmZpZWxkcyB8fCB7fSksXG4gICAgICAgICAgICAgICAgW3BhdGhdOiB7XG4gICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ1ByZWZlcmVuY2VzPy5maWVsZHM/LltwYXRoXSxcbiAgICAgICAgICAgICAgICAgIGNvbGxhcHNlZDogbmV3Q29sbGFwc2VkU3RhdGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgZmllbGRzOiB7XG4gICAgICAgICAgICAgICAgLi4uKGV4aXN0aW5nUHJlZmVyZW5jZXM/LmZpZWxkcyB8fCB7fSksXG4gICAgICAgICAgICAgICAgW2ZpZWxkUHJlZmVyZW5jZXNLZXldOiB7XG4gICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ1ByZWZlcmVuY2VzPy5maWVsZHM/LltmaWVsZFByZWZlcmVuY2VzS2V5XSxcbiAgICAgICAgICAgICAgICAgIGNvbGxhcHNlZDogbmV3Q29sbGFwc2VkU3RhdGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgfSlcbiAgICB9LFxuICAgIFtwcmVmZXJlbmNlc0tleSwgZmllbGRQcmVmZXJlbmNlc0tleSwgZ2V0UHJlZmVyZW5jZSwgc2V0UHJlZmVyZW5jZSwgcGF0aF0sXG4gIClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGZldGNoSW5pdGlhbFN0YXRlID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcHJlZmVyZW5jZXMgPSBhd2FpdCBnZXRQcmVmZXJlbmNlKHByZWZlcmVuY2VzS2V5KVxuICAgICAgaWYgKHByZWZlcmVuY2VzKSB7XG4gICAgICAgIGNvbnN0IGluaXRDb2xsYXBzZWRGcm9tUHJlZiA9IHBhdGhcbiAgICAgICAgICA/IHByZWZlcmVuY2VzPy5maWVsZHM/LltwYXRoXT8uY29sbGFwc2VkXG4gICAgICAgICAgOiBwcmVmZXJlbmNlcz8uZmllbGRzPy5bZmllbGRQcmVmZXJlbmNlc0tleV0/LmNvbGxhcHNlZFxuICAgICAgICBzZXRDb2xsYXBzZWRPbk1vdW50KEJvb2xlYW4oaW5pdENvbGxhcHNlZEZyb21QcmVmKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldENvbGxhcHNlZE9uTW91bnQodHlwZW9mIGluaXRDb2xsYXBzZWQgPT09ICdib29sZWFuJyA/IGluaXRDb2xsYXBzZWQgOiBmYWxzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmZXRjaEluaXRpYWxTdGF0ZSgpXG4gIH0sIFtnZXRQcmVmZXJlbmNlLCBwcmVmZXJlbmNlc0tleSwgZmllbGRQcmVmZXJlbmNlc0tleSwgaW5pdENvbGxhcHNlZCwgcGF0aF0pXG5cbiAgaWYgKHR5cGVvZiBjb2xsYXBzZWRPbk1vdW50ICE9PSAnYm9vbGVhbicpIHJldHVybiBudWxsXG5cbiAgY29uc3QgZmllbGRIYXNFcnJvcnMgPSBzdWJtaXR0ZWQgJiYgZXJyb3JDb3VudCA+IDBcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGlkPXtgZmllbGQtJHtmaWVsZFByZWZlcmVuY2VzS2V5fSR7cGF0aCA/IGAtJHtwYXRoLnJlcGxhY2UoL1xcLi9nLCAnX18nKX1gIDogJyd9YH1cbiAgICAgIGNsYXNzTmFtZT17W1xuICAgICAgICBmaWVsZEJhc2VDbGFzcyxcbiAgICAgICAgYmFzZUNsYXNzLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIGZpZWxkSGFzRXJyb3JzID8gYCR7YmFzZUNsYXNzfS0taGFzLWVycm9yYCA6IGAke2Jhc2VDbGFzc30tLWhhcy1uby1lcnJvcmAsXG4gICAgICBdXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oJyAnKX1cbiAgICA+XG4gICAgICA8V2F0Y2hDaGlsZEVycm9ycyBmaWVsZFNjaGVtYT17ZmllbGRzfSBwYXRoPXtwYXRofSBzZXRFcnJvckNvdW50PXtzZXRFcnJvckNvdW50fSAvPlxuICAgICAgPENvbGxhcHNpYmxlXG4gICAgICAgIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fY29sbGFwc2libGVgfVxuICAgICAgICBjb2xsYXBzaWJsZVN0eWxlPXtlcnJvckNvdW50ID4gMCA/ICdlcnJvcicgOiAnZGVmYXVsdCd9XG4gICAgICAgIGhlYWRlcj17XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX3Jvdy1sYWJlbC13cmFwYH0+XG4gICAgICAgICAgICA8Um93TGFiZWwgbGFiZWw9e2xhYmVsfSBwYXRoPXtwYXRofSAvPlxuICAgICAgICAgICAge2Vycm9yQ291bnQgPiAwICYmIDxFcnJvclBpbGwgY291bnQ9e2Vycm9yQ291bnR9IHdpdGhNZXNzYWdlIC8+fVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICB9XG4gICAgICAgIGluaXRDb2xsYXBzZWQ9e2NvbGxhcHNlZE9uTW91bnR9XG4gICAgICAgIG9uVG9nZ2xlPXtvblRvZ2dsZX1cbiAgICAgID5cbiAgICAgICAgPFJlbmRlckZpZWxkc1xuICAgICAgICAgIGZpZWxkU2NoZW1hPXtmaWVsZHMubWFwKChmaWVsZCkgPT4gKHtcbiAgICAgICAgICAgIC4uLmZpZWxkLFxuICAgICAgICAgICAgcGF0aDogY3JlYXRlTmVzdGVkRmllbGRQYXRoKHBhdGgsIGZpZWxkKSxcbiAgICAgICAgICB9KSl9XG4gICAgICAgICAgZmllbGRUeXBlcz17ZmllbGRUeXBlc31cbiAgICAgICAgICBmb3JjZVJlbmRlclxuICAgICAgICAgIGluZGV4UGF0aD17aW5kZXhQYXRofVxuICAgICAgICAgIG1hcmdpbnM9XCJzbWFsbFwiXG4gICAgICAgICAgcGVybWlzc2lvbnM9e3Blcm1pc3Npb25zfVxuICAgICAgICAgIHJlYWRPbmx5PXtyZWFkT25seX1cbiAgICAgICAgLz5cbiAgICAgIDwvQ29sbGFwc2libGU+XG4gICAgICA8RmllbGREZXNjcmlwdGlvbiBkZXNjcmlwdGlvbj17ZGVzY3JpcHRpb259IC8+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aENvbmRpdGlvbihDb2xsYXBzaWJsZUZpZWxkKVxuIl0sIm5hbWVzIjpbImJhc2VDbGFzcyIsIkNvbGxhcHNpYmxlRmllbGQiLCJwcm9wcyIsImFkbWluIiwiY2xhc3NOYW1lIiwiZGVzY3JpcHRpb24iLCJpbml0Q29sbGFwc2VkIiwicmVhZE9ubHkiLCJmaWVsZFR5cGVzIiwiZmllbGRzIiwiaW5kZXhQYXRoIiwibGFiZWwiLCJwYXRoIiwicGVybWlzc2lvbnMiLCJnZXRQcmVmZXJlbmNlIiwic2V0UHJlZmVyZW5jZSIsInVzZVByZWZlcmVuY2VzIiwicHJlZmVyZW5jZXNLZXkiLCJ1c2VEb2N1bWVudEluZm8iLCJjb2xsYXBzZWRPbk1vdW50Iiwic2V0Q29sbGFwc2VkT25Nb3VudCIsInVzZVN0YXRlIiwiZmllbGRQcmVmZXJlbmNlc0tleSIsInJlcGxhY2UiLCJlcnJvckNvdW50Iiwic2V0RXJyb3JDb3VudCIsInN1Ym1pdHRlZCIsInVzZUZvcm1TdWJtaXR0ZWQiLCJvblRvZ2dsZSIsInVzZUNhbGxiYWNrIiwibmV3Q29sbGFwc2VkU3RhdGUiLCJleGlzdGluZ1ByZWZlcmVuY2VzIiwiY29sbGFwc2VkIiwidXNlRWZmZWN0IiwiZmV0Y2hJbml0aWFsU3RhdGUiLCJwcmVmZXJlbmNlcyIsImluaXRDb2xsYXBzZWRGcm9tUHJlZiIsIkJvb2xlYW4iLCJmaWVsZEhhc0Vycm9ycyIsImRpdiIsImlkIiwiZmllbGRCYXNlQ2xhc3MiLCJmaWx0ZXIiLCJqb2luIiwiV2F0Y2hDaGlsZEVycm9ycyIsImZpZWxkU2NoZW1hIiwiQ29sbGFwc2libGUiLCJjb2xsYXBzaWJsZVN0eWxlIiwiaGVhZGVyIiwiUm93TGFiZWwiLCJFcnJvclBpbGwiLCJjb3VudCIsIndpdGhNZXNzYWdlIiwiUmVuZGVyRmllbGRzIiwibWFwIiwiZmllbGQiLCJjcmVhdGVOZXN0ZWRGaWVsZFBhdGgiLCJmb3JjZVJlbmRlciIsIm1hcmdpbnMiLCJGaWVsZERlc2NyaXB0aW9uIiwid2l0aENvbmRpdGlvbiJdLCJtYXBwaW5ncyI6Ijs7OzsrQkFvSUE7OztlQUFBOzs7K0RBcEl3RDs2QkFLNUI7MkJBQ0Y7OEJBQ007NkJBQ0Q7eUVBQ0Y7eUJBQ0k7dUNBQ0s7cUVBQ2I7MEJBQ0E7a0NBQ1E7c0VBQ1A7UUFDbkI7d0JBQ3dCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFL0IsTUFBTUEsWUFBWTtBQUVsQixNQUFNQyxtQkFBb0MsQ0FBQ0M7SUFDekMsTUFBTSxFQUNKQyxPQUFPLEVBQUVDLFNBQVMsRUFBRUMsV0FBVyxFQUFFQyxhQUFhLEVBQUVDLFFBQVEsRUFBRSxFQUMxREMsVUFBVSxFQUNWQyxNQUFNLEVBQ05DLFNBQVMsRUFDVEMsS0FBSyxFQUNMQyxJQUFJLEVBQ0pDLFdBQVcsRUFDWixHQUFHWDtJQUVKLE1BQU0sRUFBRVksYUFBYSxFQUFFQyxhQUFhLEVBQUUsR0FBR0MsSUFBQUEsMkJBQWM7SUFDdkQsTUFBTSxFQUFFQyxjQUFjLEVBQUUsR0FBR0MsSUFBQUEsNkJBQWU7SUFDMUMsTUFBTSxDQUFDQyxrQkFBa0JDLG9CQUFvQixHQUFHQyxJQUFBQSxlQUFRO0lBQ3hELE1BQU1DLHNCQUFzQixDQUFDLFlBQVksRUFBRVosVUFBVWEsT0FBTyxDQUFDLE9BQU8sTUFBTSxDQUFDO0lBQzNFLE1BQU0sQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHSixJQUFBQSxlQUFRLEVBQUM7SUFDN0MsTUFBTUssWUFBWUMsSUFBQUEseUJBQWdCO0lBRWxDLE1BQU1DLFdBQVdDLElBQUFBLGtCQUFXLEVBQzFCLE9BQU9DO1FBQ0wsTUFBTUMsc0JBQTJDLE1B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