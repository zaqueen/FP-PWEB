"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ArrayRow", {
    enumerable: true,
    get: function() {
        return ArrayRow;
    }
});
const _react = /*#__PURE__*/ _interop_require_default(require("react"));
const _reacti18next = require("react-i18next");
const _getTranslation = require("../../../../../utilities/getTranslation");
const _ArrayAction = require("../../../elements/ArrayAction");
const _Collapsible = require("../../../elements/Collapsible");
const _ErrorPill = require("../../../elements/ErrorPill");
const _context = require("../../Form/context");
const _createNestedFieldPath = require("../../Form/createNestedFieldPath");
const _RenderFields = /*#__PURE__*/ _interop_require_default(require("../../RenderFields"));
const _RowLabel = require("../../RowLabel");
const _HiddenInput = /*#__PURE__*/ _interop_require_default(require("../HiddenInput"));
require("./index.scss");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const baseClass = 'array-field';
const ArrayRow = ({ CustomRowLabel, addRow, attributes, duplicateRow, fieldTypes, fields, forceRender = false, hasMaxRows, indexPath, labels, listeners, moveRow, path: parentPath, permissions, readOnly, removeRow, row, rowCount, rowIndex, setCollapse, setNodeRef, transform })=>{
    const path = `${parentPath}.${rowIndex}`;
    const { i18n } = (0, _reacti18next.useTranslation)();
    const hasSubmitted = (0, _context.useFormSubmitted)();
    const fallbackLabel = `${(0, _getTranslation.getTranslation)(labels.singular, i18n)} ${String(rowIndex + 1).padStart(2, '0')}`;
    const childErrorPathsCount = row.childErrorPaths?.size;
    const fieldHasErrors = hasSubmitted && childErrorPathsCount > 0;
    const classNames = [
        `${baseClass}__row`,
        fieldHasErrors ? `${baseClass}__row--has-errors` : `${baseClass}__row--no-errors`
    ].filter(Boolean).join(' ');
    return /*#__PURE__*/ _react.default.createElement("div", {
        id: `${parentPath.split('.').join('-')}-row-${rowIndex}`,
        key: `${parentPath}-row-${row.id}`,
        ref: setNodeRef,
        style: {
            transform
        }
    }, /*#__PURE__*/ _react.default.createElement(_Collapsible.Collapsible, {
        actions: !readOnly ? /*#__PURE__*/ _react.default.createElement(_ArrayAction.ArrayAction, {
            addRow: addRow,
            duplicateRow: duplicateRow,
            hasMaxRows: hasMaxRows,
            index: rowIndex,
            moveRow: moveRow,
            removeRow: removeRow,
            rowCount: rowCount
        }) : undefined,
        className: classNames,
        collapsed: row.collapsed,
        collapsibleStyle: fieldHasErrors ? 'error' : 'default',
        dragHandleProps: {
            id: row.id,
            attributes,
            listeners
        },
        header: /*#__PURE__*/ _react.default.createElement("div", {
            className: `${baseClass}__row-header`
        }, /*#__PURE__*/ _react.default.createElement(_RowLabel.RowLabel, {
            label: CustomRowLabel || fallbackLabel,
            path: path,
            rowNumber: rowIndex + 1
        }), fieldHasErrors && /*#__PURE__*/ _react.default.createElement(_ErrorPill.ErrorPill, {
            count: childErrorPathsCount,
            withMessage: true
        })),
        onToggle: (collapsed)=>setCollapse(row.id, collapsed)
    }, /*#__PURE__*/ _react.default.createElement(_HiddenInput.default, {
        name: `${path}.id`,
        value: row.id
    }), /*#__PURE__*/ _react.default.createElement(_RenderFields.default, {
        className: `${baseClass}__fields`,
        fieldSchema: fields.map((field)=>({
                ...field,
                path: (0, _createNestedFieldPath.createNestedFieldPath)(path, field)
            })),
        fieldTypes: fieldTypes,
        forceRender: forceRender,
        indexPath: indexPath,
        margins: "small",
        permissions: permissions?.fields,
        readOnly: readOnly
    })));
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2Zvcm1zL2ZpZWxkLXR5cGVzL0FycmF5L0FycmF5Um93LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VUcmFuc2xhdGlvbiB9IGZyb20gJ3JlYWN0LWkxOG5leHQnXG5cbmltcG9ydCB0eXBlIHsgVXNlRHJhZ2dhYmxlU29ydGFibGVSZXR1cm4gfSBmcm9tICcuLi8uLi8uLi9lbGVtZW50cy9EcmFnZ2FibGVTb3J0YWJsZS91c2VEcmFnZ2FibGVTb3J0YWJsZS90eXBlcydcbmltcG9ydCB0eXBlIHsgUm93IH0gZnJvbSAnLi4vLi4vRm9ybS90eXBlcydcbmltcG9ydCB0eXBlIHsgUm93TGFiZWwgYXMgUm93TGFiZWxUeXBlIH0gZnJvbSAnLi4vLi4vUm93TGFiZWwvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFByb3BzIH0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IHsgZ2V0VHJhbnNsYXRpb24gfSBmcm9tICcuLi8uLi8uLi8uLi8uLi91dGlsaXRpZXMvZ2V0VHJhbnNsYXRpb24nXG5pbXBvcnQgeyBBcnJheUFjdGlvbiB9IGZyb20gJy4uLy4uLy4uL2VsZW1lbnRzL0FycmF5QWN0aW9uJ1xuaW1wb3J0IHsgQ29sbGFwc2libGUgfSBmcm9tICcuLi8uLi8uLi9lbGVtZW50cy9Db2xsYXBzaWJsZSdcbmltcG9ydCB7IEVycm9yUGlsbCB9IGZyb20gJy4uLy4uLy4uL2VsZW1lbnRzL0Vycm9yUGlsbCdcbmltcG9ydCB7IHVzZUZvcm1TdWJtaXR0ZWQgfSBmcm9tICcuLi8uLi9Gb3JtL2NvbnRleHQnXG5pbXBvcnQgeyBjcmVhdGVOZXN0ZWRGaWVsZFBhdGggfSBmcm9tICcuLi8uLi9Gb3JtL2NyZWF0ZU5lc3RlZEZpZWxkUGF0aCdcbmltcG9ydCBSZW5kZXJGaWVsZHMgZnJvbSAnLi4vLi4vUmVuZGVyRmllbGRzJ1xuaW1wb3J0IHsgUm93TGFiZWwgfSBmcm9tICcuLi8uLi9Sb3dMYWJlbCdcbmltcG9ydCBIaWRkZW5JbnB1dCBmcm9tICcuLi9IaWRkZW5JbnB1dCdcbmltcG9ydCAnLi9pbmRleC5zY3NzJ1xuXG5jb25zdCBiYXNlQ2xhc3MgPSAnYXJyYXktZmllbGQnXG5cbnR5cGUgQXJyYXlSb3dQcm9wcyA9IFVzZURyYWdnYWJsZVNvcnRhYmxlUmV0dXJuICZcbiAgUGljazxQcm9wcywgJ2ZpZWxkVHlwZXMnIHwgJ2ZpZWxkcycgfCAnaW5kZXhQYXRoJyB8ICdsYWJlbHMnIHwgJ3BhdGgnIHwgJ3Blcm1pc3Npb25zJz4gJiB7XG4gICAgQ3VzdG9tUm93TGFiZWw/OiBSb3dMYWJlbFR5cGVcbiAgICBhZGRSb3c6IChyb3dJbmRleDogbnVtYmVyKSA9PiB2b2lkXG4gICAgZHVwbGljYXRlUm93OiAocm93SW5kZXg6IG51bWJlcikgPT4gdm9pZFxuICAgIGZvcmNlUmVuZGVyPzogYm9vbGVhblxuICAgIGhhc01heFJvd3M/OiBib29sZWFuXG4gICAgbW92ZVJvdzogKGZyb21JbmRleDogbnVtYmVyLCB0b0luZGV4OiBudW1iZXIpID0+IHZvaWRcbiAgICByZWFkT25seT86IGJvb2xlYW5cbiAgICByZW1vdmVSb3c6IChyb3dJbmRleDogbnVtYmVyKSA9PiB2b2lkXG4gICAgcm93OiBSb3dcbiAgICByb3dDb3VudDogbnVtYmVyXG4gICAgcm93SW5kZXg6IG51bWJlclxuICAgIHNldENvbGxhcHNlOiAocm93SUQ6IHN0cmluZywgY29sbGFwc2VkOiBib29sZWFuKSA9PiB2b2lkXG4gIH1cbmV4cG9ydCBjb25zdCBBcnJheVJvdzogUmVhY3QuRkM8QXJyYXlSb3dQcm9wcz4gPSAoe1xuICBDdXN0b21Sb3dMYWJlbCxcbiAgYWRkUm93LFxuICBhdHRyaWJ1dGVzLFxuICBkdXBsaWNhdGVSb3csXG4gIGZpZWxkVHlwZXMsXG4gIGZpZWxkcyxcbiAgZm9yY2VSZW5kZXIgPSBmYWxzZSxcbiAgaGFzTWF4Um93cyxcbiAgaW5kZXhQYXRoLFxuICBsYWJlbHMsXG4gIGxpc3RlbmVycyxcbiAgbW92ZVJvdyxcbiAgcGF0aDogcGFyZW50UGF0aCxcbiAgcGVybWlzc2lvbnMsXG4gIHJlYWRPbmx5LFxuICByZW1vdmVSb3csXG4gIHJvdyxcbiAgcm93Q291bnQsXG4gIHJvd0luZGV4LFxuICBzZXRDb2xsYXBzZSxcbiAgc2V0Tm9kZVJlZixcbiAgdHJhbnNmb3JtLFxufSkgPT4ge1xuICBjb25zdCBwYXRoID0gYCR7cGFyZW50UGF0aH0uJHtyb3dJbmRleH1gXG4gIGNvbnN0IHsgaTE4biB9ID0gdXNlVHJhbnNsYXRpb24oKVxuICBjb25zdCBoYXNTdWJtaXR0ZWQgPSB1c2VGb3JtU3VibWl0dGVkKClcblxuICBjb25zdCBmYWxsYmFja0xhYmVsID0gYCR7Z2V0VHJhbnNsYXRpb24obGFiZWxzLnNpbmd1bGFyLCBpMThuKX0gJHtTdHJpbmcocm93SW5kZXggKyAxKS5wYWRTdGFydChcbiAgICAyLFxuICAgICcwJyxcbiAgKX1gXG5cbiAgY29uc3QgY2hpbGRFcnJvclBhdGhzQ291bnQgPSByb3cuY2hpbGRFcnJvclBhdGhzPy5zaXplXG4gIGNvbnN0IGZpZWxkSGFzRXJyb3JzID0gaGFzU3VibWl0dGVkICYmIGNoaWxkRXJyb3JQYXRoc0NvdW50ID4gMFxuXG4gIGNvbnN0IGNsYXNzTmFtZXMgPSBbXG4gICAgYCR7YmFzZUNsYXNzfV9fcm93YCxcbiAgICBmaWVsZEhhc0Vycm9ycyA/IGAke2Jhc2VDbGFzc31fX3Jvdy0taGFzLWVycm9yc2AgOiBgJHtiYXNlQ2xhc3N9X19yb3ctLW5vLWVycm9yc2AsXG4gIF1cbiAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgLmpvaW4oJyAnKVxuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgaWQ9e2Ake3BhcmVudFBhdGguc3BsaXQoJy4nKS5qb2luKCctJyl9LXJvdy0ke3Jvd0luZGV4fWB9XG4gICAgICBrZXk9e2Ake3BhcmVudFBhdGh9LXJvdy0ke3Jvdy5pZH1gfVxuICAgICAgcmVmPXtzZXROb2RlUmVmfVxuICAgICAgc3R5bGU9e3tcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgfX1cbiAgICA+XG4gICAgICA8Q29sbGFwc2libGVcbiAgICAgICAgYWN0aW9ucz17XG4gICAgICAgICAgIXJlYWRPbmx5ID8gKFxuICAgICAgICAgICAgPEFycmF5QWN0aW9uXG4gICAgICAgICAgICAgIGFkZFJvdz17YWRkUm93fVxuICAgICAgICAgICAgICBkdXBsaWNhdGVSb3c9e2R1cGxpY2F0ZVJvd31cbiAgICAgICAgICAgICAgaGFzTWF4Um93cz17aGFzTWF4Um93c31cbiAgICAgICAgICAgICAgaW5kZXg9e3Jvd0luZGV4fVxuICAgICAgICAgICAgICBtb3ZlUm93PXttb3ZlUm93fVxuICAgICAgICAgICAgICByZW1vdmVSb3c9e3JlbW92ZVJvd31cbiAgICAgICAgICAgICAgcm93Q291bnQ9e3Jvd0NvdW50fVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApIDogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NOYW1lPXtjbGFzc05hbWVzfVxuICAgICAgICBjb2xsYXBzZWQ9e3Jvdy5jb2xsYXBzZWR9XG4gICAgICAgIGNvbGxhcHNpYmxlU3R5bGU9e2ZpZWxkSGFzRXJyb3JzID8gJ2Vycm9yJyA6ICdkZWZhdWx0J31cbiAgICAgICAgZHJhZ0hhbmRsZVByb3BzPXt7XG4gICAgICAgICAgaWQ6IHJvdy5pZCxcbiAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgIGxpc3RlbmVycyxcbiAgICAgICAgfX1cbiAgICAgICAgaGVhZGVyPXtcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fcm93LWhlYWRlcmB9PlxuICAgICAgICAgICAgPFJvd0xhYmVsXG4gICAgICAgICAgICAgIGxhYmVsPXtDdXN0b21Sb3dMYWJlbCB8fCBmYWxsYmFja0xhYmVsfVxuICAgICAgICAgICAgICBwYXRoPXtwYXRofVxuICAgICAgICAgICAgICByb3dOdW1iZXI9e3Jvd0luZGV4ICsgMX1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgICB7ZmllbGRIYXNFcnJvcnMgJiYgPEVycm9yUGlsbCBjb3VudD17Y2hpbGRFcnJvclBhdGhzQ291bnR9IHdpdGhNZXNzYWdlIC8+fVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICB9XG4gICAgICAgIG9uVG9nZ2xlPXsoY29sbGFwc2VkKSA9PiBzZXRDb2xsYXBzZShyb3cuaWQsIGNvbGxhcHNlZCl9XG4gICAgICA+XG4gICAgICAgIDxIaWRkZW5JbnB1dCBuYW1lPXtgJHtwYXRofS5pZGB9IHZhbHVlPXtyb3cuaWR9IC8+XG4gICAgICAgIDxSZW5kZXJGaWVsZHNcbiAgICAgICAgICBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2ZpZWxkc2B9XG4gICAgICAgICAgZmllbGRTY2hlbWE9e2ZpZWxkcy5tYXAoKGZpZWxkKSA9PiAoe1xuICAgICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgICAgICBwYXRoOiBjcmVhdGVOZXN0ZWRGaWVsZFBhdGgocGF0aCwgZmllbGQpLFxuICAgICAgICAgIH0pKX1cbiAgICAgICAgICBmaWVsZFR5cGVzPXtmaWVsZFR5cGVzfVxuICAgICAgICAgIGZvcmNlUmVuZGVyPXtmb3JjZVJlbmRlcn1cbiAgICAgICAgICBpbmRleFBhdGg9e2luZGV4UGF0aH1cbiAgICAgICAgICBtYXJnaW5zPVwic21hbGxcIlxuICAgICAgICAgIHBlcm1pc3Npb25zPXtwZXJtaXNzaW9ucz8uZmllbGRzfVxuICAgICAgICAgIHJlYWRPbmx5PXtyZWFkT25seX1cbiAgICAgICAgLz5cbiAgICAgIDwvQ29sbGFwc2libGU+XG4gICAgPC9kaXY+XG4gIClcbn1cbiJdLCJuYW1lcyI6WyJBcnJheVJvdyIsImJhc2VDbGFzcyIsIkN1c3RvbVJvd0xhYmVsIiwiYWRkUm93IiwiYXR0cmlidXRlcyIsImR1cGxpY2F0ZVJvdyIsImZpZWxkVHlwZXMiLCJmaWVsZHMiLCJmb3JjZVJlbmRlciIsImhhc01heFJvd3MiLCJpbmRleFBhdGgiLCJsYWJlbHMiLCJsaXN0ZW5lcnMiLCJtb3ZlUm93IiwicGF0aCIsInBhcmVudFBhdGgiLCJwZXJtaXNzaW9ucyIsInJlYWRPbmx5IiwicmVtb3ZlUm93Iiwicm93Iiwicm93Q291bnQiLCJyb3dJbmRleCIsInNldENvbGxhcHNlIiwic2V0Tm9kZVJlZiIsInRyYW5zZm9ybSIsImkxOG4iLCJ1c2VUcmFuc2xhdGlvbiIsImhhc1N1Ym1pdHRlZCIsInVzZUZvcm1TdWJtaXR0ZWQiLCJmYWxsYmFja0xhYmVsIiwiZ2V0VHJhbnNsYXRpb24iLCJzaW5ndWxhciIsIlN0cmluZyIsInBhZFN0YXJ0IiwiY2hpbGRFcnJvclBhdGhzQ291bnQiLCJjaGlsZEVycm9yUGF0aHMiLCJzaXplIiwiZmllbGRIYXNFcnJvcnMiLCJjbGFzc05hbWVzIiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJkaXYiLCJpZCIsInNwbGl0Iiwia2V5IiwicmVmIiwic3R5bGUiLCJDb2xsYXBzaWJsZSIsImFjdGlvbnMiLCJBcnJheUFjdGlvbiIsImluZGV4IiwidW5kZWZpbmVkIiwiY2xhc3NOYW1lIiwiY29sbGFwc2VkIiwiY29sbGFwc2libGVTdHlsZSIsImRyYWdIYW5kbGVQcm9wcyIsImhlYWRlciIsIlJvd0xhYmVsIiwibGFiZWwiLCJyb3dOdW1iZXIiLCJFcnJvclBpbGwiLCJjb3VudCIsIndpdGhNZXNzYWdlIiwib25Ub2dnbGUiLCJIaWRkZW5JbnB1dCIsIm5hbWUiLCJ2YWx1ZSIsIlJlbmRlckZpZWxkcyIsImZpZWxkU2NoZW1hIiwibWFwIiwiZmllbGQiLCJjcmVhdGVOZXN0ZWRGaWVsZFBhdGgiLCJtYXJnaW5zIl0sIm1hcHBpbmdzIjoiOzs7OytCQW9DYUE7OztlQUFBQTs7OzhEQXBDSzs4QkFDYTtnQ0FPQTs2QkFDSDs2QkFDQTsyQkFDRjt5QkFDTzt1Q0FDSztxRUFDYjswQkFDQTtvRUFDRDtRQUNqQjs7Ozs7O0FBRVAsTUFBTUMsWUFBWTtBQWlCWCxNQUFNRCxXQUFvQyxDQUFDLEVBQ2hERSxj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