"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _validations = require("../../../../../fields/validations");
const _Config = require("../../../utilities/Config");
const _Locale = require("../../../utilities/Locale");
const _useField = /*#__PURE__*/ _interop_require_default(require("../../useField"));
const _withCondition = /*#__PURE__*/ _interop_require_default(require("../../withCondition"));
const _shared = require("../shared");
const _Input = /*#__PURE__*/ _interop_require_default(require("./Input"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const Text = (props)=>{
    const { name, admin: { className, components: { Error, Label, afterInput, beforeInput } = {}, condition, description, placeholder, readOnly, rtl, style, width } = {}, inputRef, label, localized, maxLength, minLength, path: pathFromProps, required, validate = _validations.text } = props;
    const path = pathFromProps || name;
    const locale = (0, _Locale.useLocale)();
    const { localization } = (0, _Config.useConfig)();
    const isRTL = (0, _shared.isFieldRTL)({
        fieldLocalized: localized,
        fieldRTL: rtl,
        locale,
        localizationConfig: localization || undefined
    });
    const memoizedValidate = (0, _react.useCallback)((value, options)=>{
        return validate(value, {
            ...options,
            maxLength,
            minLength,
            required
        });
    }, [
        validate,
        minLength,
        maxLength,
        required
    ]);
    const { errorMessage, setValue, showError, value } = (0, _useField.default)({
        condition,
        path,
        validate: memoizedValidate
    });
    return /*#__PURE__*/ _react.default.createElement(_Input.default, {
        Error: Error,
        Label: Label,
        afterInput: afterInput,
        beforeInput: beforeInput,
        className: className,
        description: description,
        errorMessage: errorMessage,
        inputRef: inputRef,
        label: label,
        name: name,
        onChange: (e)=>{
            setValue(e.target.value);
        },
        path: path,
        placeholder: placeholder,
        readOnly: readOnly,
        required: required,
        rtl: isRTL,
        showError: showError,
        style: style,
        value: value,
        width: width
    });
};
const _default = (0, _withCondition.default)(Text);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2Zvcm1zL2ZpZWxkLXR5cGVzL1RleHQvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgdHlwZSB7IFByb3BzIH0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IHsgdGV4dCB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2ZpZWxkcy92YWxpZGF0aW9ucydcbmltcG9ydCB7IHVzZUNvbmZpZyB9IGZyb20gJy4uLy4uLy4uL3V0aWxpdGllcy9Db25maWcnXG5pbXBvcnQgeyB1c2VMb2NhbGUgfSBmcm9tICcuLi8uLi8uLi91dGlsaXRpZXMvTG9jYWxlJ1xuaW1wb3J0IHVzZUZpZWxkIGZyb20gJy4uLy4uL3VzZUZpZWxkJ1xuaW1wb3J0IHdpdGhDb25kaXRpb24gZnJvbSAnLi4vLi4vd2l0aENvbmRpdGlvbidcbmltcG9ydCB7IGlzRmllbGRSVEwgfSBmcm9tICcuLi9zaGFyZWQnXG5pbXBvcnQgVGV4dElucHV0IGZyb20gJy4vSW5wdXQnXG5cbmNvbnN0IFRleHQ6IFJlYWN0LkZDPFByb3BzPiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7XG4gICAgbmFtZSxcbiAgICBhZG1pbjoge1xuICAgICAgY2xhc3NOYW1lLFxuICAgICAgY29tcG9uZW50czogeyBFcnJvciwgTGFiZWwsIGFmdGVySW5wdXQsIGJlZm9yZUlucHV0IH0gPSB7fSxcbiAgICAgIGNvbmRpdGlvbixcbiAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICByZWFkT25seSxcbiAgICAgIHJ0bCxcbiAgICAgIHN0eWxlLFxuICAgICAgd2lkdGgsXG4gICAgfSA9IHt9LFxuICAgIGlucHV0UmVmLFxuICAgIGxhYmVsLFxuICAgIGxvY2FsaXplZCxcbiAgICBtYXhMZW5ndGgsXG4gICAgbWluTGVuZ3RoLFxuICAgIHBhdGg6IHBhdGhGcm9tUHJvcHMsXG4gICAgcmVxdWlyZWQsXG4gICAgdmFsaWRhdGUgPSB0ZXh0LFxuICB9ID0gcHJvcHNcblxuICBjb25zdCBwYXRoID0gcGF0aEZyb21Qcm9wcyB8fCBuYW1lXG4gIGNvbnN0IGxvY2FsZSA9IHVzZUxvY2FsZSgpXG5cbiAgY29uc3QgeyBsb2NhbGl6YXRpb24gfSA9IHVzZUNvbmZpZygpXG4gIGNvbnN0IGlzUlRMID0gaXNGaWVsZFJUTCh7XG4gICAgZmllbGRMb2NhbGl6ZWQ6IGxvY2FsaXplZCxcbiAgICBmaWVsZFJUTDogcnRsLFxuICAgIGxvY2FsZSxcbiAgICBsb2NhbGl6YXRpb25Db25maWc6IGxvY2FsaXphdGlvbiB8fCB1bmRlZmluZWQsXG4gIH0pXG5cbiAgY29uc3QgbWVtb2l6ZWRWYWxpZGF0ZSA9IHVzZUNhbGxiYWNrKFxuICAgICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlKHZhbHVlLCB7IC4uLm9wdGlvbnMsIG1heExlbmd0aCwgbWluTGVuZ3RoLCByZXF1aXJlZCB9KVxuICAgIH0sXG4gICAgW3ZhbGlkYXRlLCBtaW5MZW5ndGgsIG1heExlbmd0aCwgcmVxdWlyZWRdLFxuICApXG5cbiAgY29uc3QgeyBlcnJvck1lc3NhZ2UsIHNldFZhbHVlLCBzaG93RXJyb3IsIHZhbHVlIH0gPSB1c2VGaWVsZDxzdHJpbmc+KHtcbiAgICBjb25kaXRpb24sXG4gICAgcGF0aCxcbiAgICB2YWxpZGF0ZTogbWVtb2l6ZWRWYWxpZGF0ZSxcbiAgfSlcblxuICByZXR1cm4gKFxuICAgIDxUZXh0SW5wdXRcbiAgICAgIEVycm9yPXtFcnJvcn1cbiAgICAgIExhYmVsPXtMYWJlbH1cbiAgICAgIGFmdGVySW5wdXQ9e2FmdGVySW5wdXR9XG4gICAgICBiZWZvcmVJbnB1dD17YmVmb3JlSW5wdXR9XG4gICAgICBjbGFzc05hbWU9e2NsYXNzTmFtZX1cbiAgICAgIGRlc2NyaXB0aW9uPXtkZXNjcmlwdGlvbn1cbiAgICAgIGVycm9yTWVzc2FnZT17ZXJyb3JNZXNzYWdlfVxuICAgICAgaW5wdXRSZWY9e2lucHV0UmVmfVxuICAgICAgbGFiZWw9e2xhYmVsfVxuICAgICAgbmFtZT17bmFtZX1cbiAgICAgIG9uQ2hhbmdlPXsoZSkgPT4ge1xuICAgICAgICBzZXRWYWx1ZShlLnRhcmdldC52YWx1ZSlcbiAgICAgIH19XG4gICAgICBwYXRoPXtwYXRofVxuICAgICAgcGxhY2Vob2xkZXI9e3BsYWNlaG9sZGVyfVxuICAgICAgcmVhZE9ubHk9e3JlYWRPbmx5fVxuICAgICAgcmVxdWlyZWQ9e3JlcXVpcmVkfVxuICAgICAgcnRsPXtpc1JUTH1cbiAgICAgIHNob3dFcnJvcj17c2hvd0Vycm9yfVxuICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgdmFsdWU9e3ZhbHVlfVxuICAgICAgd2lkdGg9e3dpZHRofVxuICAgIC8+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgd2l0aENvbmRpdGlvbihUZXh0KVxuIl0sIm5hbWVzIjpbIlRleHQiLCJwcm9wcyIsIm5hbWUiLCJhZG1pbiIsImNsYXNzTmFtZSIsImNvbXBvbmVudHMiLCJFcnJvciIsIkxhYmVsIiwiYWZ0ZXJJbnB1dCIsImJlZm9yZUlucHV0IiwiY29uZGl0aW9uIiwiZGVzY3JpcHRpb24iLCJwbGFjZWhvbGRlciIsInJlYWRPbmx5IiwicnRsIiwic3R5bGUiLCJ3aWR0aCIsImlucHV0UmVmIiwibGFiZWwiLCJsb2NhbGl6ZWQiLCJtYXhMZW5ndGgiLCJtaW5MZW5ndGgiLCJwYXRoIiwicGF0aEZyb21Qcm9wcyIsInJlcXVpcmVkIiwidmFsaWRhdGUiLCJ0ZXh0IiwibG9jYWxlIiwidXNlTG9jYWxlIiwibG9jYWxpemF0aW9uIiwidXNlQ29uZmlnIiwiaXNSVEwiLCJpc0ZpZWxkUlRMIiwiZmllbGRMb2NhbGl6ZWQiLCJmaWVsZFJUTCIsImxvY2FsaXphdGlvbkNvbmZpZyIsInVuZGVmaW5lZCIsIm1lbW9pemVkVmFsaWRhdGUiLCJ1c2VDYWxsYmFjayIsInZhbHVlIiwib3B0aW9ucyIsImVycm9yTWVzc2FnZSIsInNldFZhbHVlIiwic2hvd0Vycm9yIiwidXNlRmllbGQiLCJUZXh0SW5wdXQiLCJvbkNoYW5nZSIsImUiLCJ0YXJnZXQiLCJ3aXRoQ29uZGl0aW9uIl0sIm1hcHBpbmdzIjoiOzs7OytCQXdGQTs7O2VBQUE7OzsrREF4Rm1DOzZCQUlkO3dCQUNLO3dCQUNBO2lFQUNMO3NFQUNLO3dCQUNDOzhEQUNMOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFdEIsTUFBTUEsT0FBd0IsQ0FBQ0M7SUFDN0IsTUFBTSxFQUNKQyxJQUFJLEVBQ0pDLE9BQU8sRUFDTEMsU0FBUyxFQUNUQyxZQUFZLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLFdBQVcsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUMxREMsU0FBUyxFQUNUQyxXQUFXLEVBQ1hDLFdBQVcsRUFDWEMsUUFBUSxFQUNSQyxHQUFHLEVBQ0hDLEtBQUssRUFDTEMsS0FBSyxFQUNOLEdBQUcsQ0FBQyxDQUFDLEVBQ05DLFFBQVEsRUFDUkMsS0FBSyxFQUNMQyxTQUFTLEVBQ1RDLFNBQVMsRUFDVEMsU0FBUyxFQUNUQyxNQUFNQyxhQUFhLEVBQ25CQyxRQUFRLEVBQ1JDLFdBQVdDLGlCQUFJLEVBQ2hCLEdBQUd6QjtJQUVKLE1BQU1xQixPQUFPQyxpQkFBaUJyQjtJQUM5QixNQUFNeUIsU0FBU0MsSUFBQUEsaUJBQVM7SUFFeEIsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBR0MsSUFBQUEsaUJBQVM7SUFDbEMsTUFBTUMsUUFBUUMsSUFBQUEsa0JBQVUsRUFBQztRQUN2QkMsZ0JBQWdCZDtRQUNoQmUsVUFBVXBCO1FBQ1ZhO1FBQ0FRLG9CQUFvQk4sZ0JBQWdCTztJQUN0QztJQUVBLE1BQU1DLG1CQUFtQkMsSUFBQUEsa0JBQVcsRUFDbEMsQ0FBQ0MsT0FBT0M7UUFDTixPQUFPZixTQUFTYyxPQUFPO1lBQUUsR0FBR0MsT0FBTztZQUFFcEI7WUFBV0M7WUFBV0c7UUFBUztJQUN0RSxHQUNBO1FBQUNDO1FBQVVKO1FBQVdEO1FBQVdJO0tBQVM7SUFHNUMsTUFBTSxFQUFFaUIsWUFBWSxFQUFFQyxRQUFRLEVBQUVDLFNBQVMsRUFBRUosS0FBSyxFQUFFLEdBQUdLLElBQUFBLGlCQUFRLEVBQVM7UUFDcEVsQztRQUNBWTtRQUNBRyxVQUFVWTtJQUNaO0lBRUEscUJBQ0UsNkJBQUNRLGNBQVM7UUFDUnZDLE9BQU9BO1FBQ1BDLE9BQU9BO1FBQ1BDLFlBQVlBO1FBQ1pDLGFBQWFBO1FBQ2JMLFdBQVdBO1FBQ1hPLGFBQWFBO1FBQ2I4QixjQUFjQTtRQUNkeEIsVUFBVUE7UUFDVkMsT0FBT0E7UUFDUGhCLE1BQU1BO1FBQ040QyxVQUFVLENBQUNDO1lBQ1RMLFNBQVNLLEVBQUVDLE1BQU0sQ0FBQ1QsS0FBSztRQUN6QjtRQUNBakIsTUFBTUE7UUFDTlYsYUFBYUE7UUFDYkMsVUFBVUE7UUFDVlcsVUFBVUE7UUFDVlYsS0FBS2lCO1FBQ0xZLFdBQVdBO1FBQ1g1QixPQUFPQTtRQUNQd0IsT0FBT0E7UUFDUHZCLE9BQU9BOztBQUdiO01BRUEsV0FBZWlDLElBQUFBLHNCQUFhLEVBQUNqRCJ9