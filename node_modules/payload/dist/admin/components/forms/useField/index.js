"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _react = require("react");
const _reacti18next = require("react-i18next");
const _useThrottledEffect = /*#__PURE__*/ _interop_require_default(require("../../../hooks/useThrottledEffect"));
const _Auth = require("../../utilities/Auth");
const _Config = require("../../utilities/Config");
const _DocumentInfo = require("../../utilities/DocumentInfo");
const _OperationProvider = require("../../utilities/OperationProvider");
const _context = require("../Form/context");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Get and set the value of a form field.
 *
 * @see https://payloadcms.com/docs/admin/hooks#usefield
 */ const useField = (options)=>{
    const { condition, disableFormData = false, hasRows, path, validate } = options;
    const submitted = (0, _context.useFormSubmitted)();
    const processing = (0, _context.useFormProcessing)();
    const { user } = (0, _Auth.useAuth)();
    const { id } = (0, _DocumentInfo.useDocumentInfo)();
    const operation = (0, _OperationProvider.useOperation)();
    const field = (0, _context.useFormFields)(([fields])=>fields[path]);
    const { t } = (0, _reacti18next.useTranslation)();
    const dispatchField = (0, _context.useFormFields)(([_, dispatch])=>dispatch);
    const config = (0, _Config.useConfig)();
    const { getData, getDataByPath, getSiblingData, setModified } = (0, _context.useForm)();
    const value = field?.value;
    const initialValue = field?.initialValue;
    const valid = typeof field?.valid === 'boolean' ? field.valid : true;
    const showError = valid === false && submitted;
    const prevValid = (0, _react.useRef)(valid);
    // Method to return from `useField`, used to
    // update field values from field component(s)
    const setValue = (0, _react.useCallback)((e, disableModifyingForm = false)=>{
        const val = e && e.target ? e.target.value : e;
        if (!disableModifyingForm) {
            if (typeof setModified === 'function') {
                // Update modified state after field value comes back
                // to avoid cursor jump caused by state value / DOM mismatch
                setTimeout(()=>{
                    setModified(true);
                }, 10);
            }
        }
        dispatchField({
            disableFormData: disableFormData || hasRows && val > 0,
            path,
            type: 'UPDATE',
            value: val
        });
    }, [
        setModified,
        path,
        dispatchField,
        disableFormData,
        hasRows
    ]);
    // Store result from hook as ref
    // to prevent unnecessary rerenders
    const result = (0, _react.useMemo)(()=>({
            errorMessage: field?.errorMessage,
            formProcessing: processing,
            formSubmitted: submitted,
            initialValue,
            rows: field?.rows,
            setValue,
            showError,
            valid: field?.valid,
            value
        }), [
        field?.errorMessage,
        field?.rows,
        field?.valid,
        processing,
        setValue,
        showError,
        submitted,
        value,
        initialValue
    ]);
    // Throttle the validate function
    (0, _useThrottledEffect.default)(()=>{
        const validateField = async ()=>{
            let valueToValidate = value;
            if (field?.rows && Array.isArray(field.rows)) {
                valueToValidate = getDataByPath(path);
            }
            let errorMessage;
            let valid = false;
            const validationResult = typeof validate === 'function' ? await validate(valueToValidate, {
                id,
                config,
                data: getData(),
                operation,
                siblingData: getSiblingData(path),
                t,
                user
            }) : true;
            if (typeof validationResult === 'string') {
                errorMessage = validationResult;
                valid = false;
            } else {
                valid = validationResult;
                errorMessage = undefined;
            }
            // Only dispatch if the validation result has changed
            // This will prevent unnecessary rerenders
            if (valid !== prevValid.current) {
                prevValid.current = valid;
                if (typeof dispatchField === 'function') {
                    dispatchField({
                        condition,
                        disableFormData: disableFormData || (hasRows ? typeof value === 'number' && value > 0 : false),
                        errorMessage,
                        path,
                        rows: field?.rows,
                        type: 'UPDATE',
                        valid,
                        validate,
                        value
                    });
                }
            }
        };
        void validateField();
    }, 150, [
        value,
        condition,
        disableFormData,
        dispatchField,
        getData,
        getSiblingData,
        getDataByPath,
        id,
        operation,
        path,
        user,
        validate,
        field?.rows
    ]);
    return result;
};
const _default = useField;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2Zvcm1zL3VzZUZpZWxkL2luZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTWVtbywgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VUcmFuc2xhdGlvbiB9IGZyb20gJ3JlYWN0LWkxOG5leHQnXG5cbmltcG9ydCB0eXBlIHsgRmllbGRUeXBlLCBPcHRpb25zIH0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IHVzZVRocm90dGxlZEVmZmVjdCBmcm9tICcuLi8uLi8uLi9ob29rcy91c2VUaHJvdHRsZWRFZmZlY3QnXG5pbXBvcnQgeyB1c2VBdXRoIH0gZnJvbSAnLi4vLi4vdXRpbGl0aWVzL0F1dGgnXG5pbXBvcnQgeyB1c2VDb25maWcgfSBmcm9tICcuLi8uLi91dGlsaXRpZXMvQ29uZmlnJ1xuaW1wb3J0IHsgdXNlRG9jdW1lbnRJbmZvIH0gZnJvbSAnLi4vLi4vdXRpbGl0aWVzL0RvY3VtZW50SW5mbydcbmltcG9ydCB7IHVzZU9wZXJhdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy9PcGVyYXRpb25Qcm92aWRlcidcbmltcG9ydCB7IHVzZUZvcm0sIHVzZUZvcm1GaWVsZHMsIHVzZUZvcm1Qcm9jZXNzaW5nLCB1c2VGb3JtU3VibWl0dGVkIH0gZnJvbSAnLi4vRm9ybS9jb250ZXh0J1xuXG4vKipcbiAqIEdldCBhbmQgc2V0IHRoZSB2YWx1ZSBvZiBhIGZvcm0gZmllbGQuXG4gKlxuICogQHNlZSBodHRwczovL3BheWxvYWRjbXMuY29tL2RvY3MvYWRtaW4vaG9va3MjdXNlZmllbGRcbiAqL1xuY29uc3QgdXNlRmllbGQgPSA8VCw+KG9wdGlvbnM6IE9wdGlvbnMpOiBGaWVsZFR5cGU8VD4gPT4ge1xuICBjb25zdCB7IGNvbmRpdGlvbiwgZGlzYWJsZUZvcm1EYXRhID0gZmFsc2UsIGhhc1Jvd3MsIHBhdGgsIHZhbGlkYXRlIH0gPSBvcHRpb25zXG5cbiAgY29uc3Qgc3VibWl0dGVkID0gdXNlRm9ybVN1Ym1pdHRlZCgpXG4gIGNvbnN0IHByb2Nlc3NpbmcgPSB1c2VGb3JtUHJvY2Vzc2luZygpXG4gIGNvbnN0IHsgdXNlciB9ID0gdXNlQXV0aCgpXG4gIGNvbnN0IHsgaWQgfSA9IHVzZURvY3VtZW50SW5mbygpXG4gIGNvbnN0IG9wZXJhdGlvbiA9IHVzZU9wZXJhdGlvbigpXG4gIGNvbnN0IGZpZWxkID0gdXNlRm9ybUZpZWxkcygoW2ZpZWxkc10pID0+IGZpZWxkc1twYXRoXSlcbiAgY29uc3QgeyB0IH0gPSB1c2VUcmFuc2xhdGlvbigpXG4gIGNvbnN0IGRpc3BhdGNoRmllbGQgPSB1c2VGb3JtRmllbGRzKChbXywgZGlzcGF0Y2hdKSA9PiBkaXNwYXRjaClcbiAgY29uc3QgY29uZmlnID0gdXNlQ29uZmlnKClcblxuICBjb25zdCB7IGdldERhdGEsIGdldERhdGFCeVBhdGgsIGdldFNpYmxpbmdEYXRhLCBzZXRNb2RpZmllZCB9ID0gdXNlRm9ybSgpXG5cbiAgY29uc3QgdmFsdWUgPSBmaWVsZD8udmFsdWUgYXMgVFxuICBjb25zdCBpbml0aWFsVmFsdWUgPSBmaWVsZD8uaW5pdGlhbFZhbHVlIGFzIFRcbiAgY29uc3QgdmFsaWQgPSB0eXBlb2YgZmllbGQ/LnZhbGlkID09PSAnYm9vbGVhbicgPyBmaWVsZC52YWxpZCA6IHRydWVcbiAgY29uc3Qgc2hvd0Vycm9yID0gdmFsaWQgPT09IGZhbHNlICYmIHN1Ym1pdHRlZFxuXG4gIGNvbnN0IHByZXZWYWxpZCA9IHVzZVJlZih2YWxpZClcblxuICAvLyBNZXRob2QgdG8gcmV0dXJuIGZyb20gYHVzZUZpZWxkYCwgdXNlZCB0b1xuICAvLyB1cGRhdGUgZmllbGQgdmFsdWVzIGZyb20gZmllbGQgY29tcG9uZW50KHMpXG4gIGNvbnN0IHNldFZhbHVlID0gdXNlQ2FsbGJhY2soXG4gICAgKGUsIGRpc2FibGVNb2RpZnlpbmdGb3JtID0gZmFsc2UpID0+IHtcbiAgICAgIGNvbnN0IHZhbCA9IGUgJiYgZS50YXJnZXQgPyBlLnRhcmdldC52YWx1ZSA6IGVcblxuICAgICAgaWYgKCFkaXNhYmxlTW9kaWZ5aW5nRm9ybSkge1xuICAgICAgICBpZiAodHlwZW9mIHNldE1vZGlmaWVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlIG1vZGlmaWVkIHN0YXRlIGFmdGVyIGZpZWxkIHZhbHVlIGNvbWVzIGJhY2tcbiAgICAgICAgICAvLyB0byBhdm9pZCBjdXJzb3IganVtcCBjYXVzZWQgYnkgc3RhdGUgdmFsdWUgLyBET00gbWlzbWF0Y2hcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNldE1vZGlmaWVkKHRydWUpXG4gICAgICAgICAgfSwgMTApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGlzcGF0Y2hGaWVsZCh7XG4gICAgICAgIGRpc2FibGVGb3JtRGF0YTogZGlzYWJsZUZvcm1EYXRhIHx8IChoYXNSb3dzICYmIHZhbCA+IDApLFxuICAgICAgICBwYXRoLFxuICAgICAgICB0eXBlOiAnVVBEQVRFJyxcbiAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgIH0pXG4gICAgfSxcbiAgICBbc2V0TW9kaWZpZWQsIHBhdGgsIGRpc3BhdGNoRmllbGQsIGRpc2FibGVGb3JtRGF0YSwgaGFzUm93c10sXG4gIClcblxuICAvLyBTdG9yZSByZXN1bHQgZnJvbSBob29rIGFzIHJlZlxuICAvLyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHJlcmVuZGVyc1xuICBjb25zdCByZXN1bHQ6IEZpZWxkVHlwZTxUPiA9IHVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIGVycm9yTWVzc2FnZTogZmllbGQ/LmVycm9yTWVzc2FnZSxcbiAgICAgIGZvcm1Qcm9jZXNzaW5nOiBwcm9jZXNzaW5nLFxuICAgICAgZm9ybVN1Ym1pdHRlZDogc3VibWl0dGVkLFxuICAgICAgaW5pdGlhbFZhbHVlLFxuICAgICAgcm93czogZmllbGQ/LnJvd3MsXG4gICAgICBzZXRWYWx1ZSxcbiAgICAgIHNob3dFcnJvcixcbiAgICAgIHZhbGlkOiBmaWVsZD8udmFsaWQsXG4gICAgICB2YWx1ZSxcbiAgICB9KSxcbiAgICBbXG4gICAgICBmaWVsZD8uZXJyb3JNZXNzYWdlLFxuICAgICAgZmllbGQ/LnJvd3MsXG4gICAgICBmaWVsZD8udmFsaWQsXG4gICAgICBwcm9jZXNzaW5nLFxuICAgICAgc2V0VmFsdWUsXG4gICAgICBzaG93RXJyb3IsXG4gICAgICBzdWJtaXR0ZWQsXG4gICAgICB2YWx1ZSxcbiAgICAgIGluaXRpYWxWYWx1ZSxcbiAgICBdLFxuICApXG5cbiAgLy8gVGhyb3R0bGUgdGhlIHZhbGlkYXRlIGZ1bmN0aW9uXG4gIHVzZVRocm90dGxlZEVmZmVjdChcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZGF0ZUZpZWxkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBsZXQgdmFsdWVUb1ZhbGlkYXRlID0gdmFsdWVcblxuICAgICAgICBpZiAoZmllbGQ/LnJvd3MgJiYgQXJyYXkuaXNBcnJheShmaWVsZC5yb3dzKSkge1xuICAgICAgICAgIHZhbHVlVG9WYWxpZGF0ZSA9IGdldERhdGFCeVBhdGgocGF0aClcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgICAgICBsZXQgdmFsaWQ6IGJvb2xlYW4gfCBzdHJpbmcgPSBmYWxzZVxuXG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPVxuICAgICAgICAgIHR5cGVvZiB2YWxpZGF0ZSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBhd2FpdCB2YWxpZGF0ZSh2YWx1ZVRvVmFsaWRhdGUsIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgZGF0YTogZ2V0RGF0YSgpLFxuICAgICAgICAgICAgICAgIG9wZXJhdGlvbixcbiAgICAgICAgICAgICAgICBzaWJsaW5nRGF0YTogZ2V0U2libGluZ0RhdGEocGF0aCksXG4gICAgICAgICAgICAgICAgdCxcbiAgICAgICAgICAgICAgICB1c2VyLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiB0cnVlXG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZGF0aW9uUmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGVycm9yTWVzc2FnZSA9IHZhbGlkYXRpb25SZXN1bHRcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWQgPSB2YWxpZGF0aW9uUmVzdWx0XG4gICAgICAgICAgZXJyb3JNZXNzYWdlID0gdW5kZWZpbmVkXG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IGRpc3BhdGNoIGlmIHRoZSB2YWxpZGF0aW9uIHJlc3VsdCBoYXMgY2hhbmdlZFxuICAgICAgICAvLyBUaGlzIHdpbGwgcHJldmVudCB1bm5lY2Vzc2FyeSByZXJlbmRlcnNcbiAgICAgICAgaWYgKHZhbGlkICE9PSBwcmV2VmFsaWQuY3VycmVudCkge1xuICAgICAgICAgIHByZXZWYWxpZC5jdXJyZW50ID0gdmFsaWRcblxuICAgICAgICAgIGlmICh0eXBlb2YgZGlzcGF0Y2hGaWVsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZGlzcGF0Y2hGaWVsZCh7XG4gICAgICAgICAgICAgIGNvbmRpdGlvbixcbiAgICAgICAgICAgICAgZGlzYWJsZUZvcm1EYXRhOlxuICAgICAgICAgICAgICAgIGRpc2FibGVGb3JtRGF0YSB8fCAoaGFzUm93cyA/IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgPiAwIDogZmFsc2UpLFxuICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIHJvd3M6IGZpZWxkPy5yb3dzLFxuICAgICAgICAgICAgICB0eXBlOiAnVVBEQVRFJyxcbiAgICAgICAgICAgICAgdmFsaWQsXG4gICAgICAgICAgICAgIHZhbGlkYXRlLFxuICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZvaWQgdmFsaWRhdGVGaWVsZCgpXG4gICAgfSxcbiAgICAxNTAsXG4gICAgW1xuICAgICAgdmFsdWUsXG4gICAgICBjb25kaXRpb24sXG4gICAgICBkaXNhYmxlRm9ybURhdGEsXG4gICAgICBkaXNwYXRjaEZpZWxkLFxuICAgICAgZ2V0RGF0YSxcbiAgICAgIGdldFNpYmxpbmdEYXRhLFxuICAgICAgZ2V0RGF0YUJ5UGF0aCxcbiAgICAgIGlkLFxuICAgICAgb3BlcmF0aW9uLFxuICAgICAgcGF0aCxcbiAgICAgIHVzZXIsXG4gICAgICB2YWxpZGF0ZSxcbiAgICAgIGZpZWxkPy5yb3dzLFxuICAgIF0sXG4gIClcblxuICByZXR1cm4gcmVzdWx0XG59XG5cbmV4cG9ydCBkZWZhdWx0IHVzZUZpZWxkXG4iXSwibmFtZXMiOlsidXNlRmllbGQiLCJvcHRpb25zIiwiY29uZGl0aW9uIiwiZGlzYWJsZUZvcm1EYXRhIiwiaGFzUm93cyIsInBhdGgiLCJ2YWxpZGF0ZSIsInN1Ym1pdHRlZCIsInVzZUZvcm1TdWJtaXR0ZWQiLCJwcm9jZXNzaW5nIiwidXNlRm9ybVByb2Nlc3NpbmciLCJ1c2VyIiwidXNlQXV0aCIsImlkIiwidXNlRG9jdW1lbnRJbmZvIiwib3BlcmF0aW9uIiwidXNlT3BlcmF0aW9uIiwiZmllbGQiLCJ1c2VGb3JtRmllbGRzIiwiZmllbGRzIiwidCIsInVzZVRyYW5zbGF0aW9uIiwiZGlzcGF0Y2hGaWVsZCIsIl8iLCJkaXNwYXRjaCIsImNvbmZpZyIsInVzZUNvbmZpZyIsImdldERhdGEiLCJnZXREYXRhQnlQYXRoIiwiZ2V0U2libGluZ0RhdGEiLCJzZXRNb2RpZmllZCIsInVzZUZvcm0iLCJ2YWx1ZSIsImluaXRpYWxWYWx1ZSIsInZhbGlkIiwic2hvd0Vycm9yIiwicHJldlZhbGlkIiwidXNlUmVmIiwic2V0VmFsdWUiLCJ1c2VDYWxsYmFjayIsImUiLCJkaXNhYmxlTW9kaWZ5aW5nRm9ybSIsInZhbCIsInRhcmdldCIsInNldFRpbWVvdXQiLCJ0eXBlIiwicmVzdWx0IiwidXNlTWVtbyIsImVycm9yTWVzc2FnZSIsImZvcm1Qcm9jZXNzaW5nIiwiZm9ybVN1Ym1pdHRlZCIsInJvd3MiLCJ1c2VUaHJvdHRsZWRFZmZlY3QiLCJ2YWxpZGF0ZUZpZWxkIiwidmFsdWVUb1ZhbGlkYXRlIiwiQXJyYXkiLCJpc0FycmF5IiwidmFsaWRhdGlvblJlc3VsdCIsImRhdGEiLCJzaWJsaW5nRGF0YSIsInVuZGVmaW5lZCIsImN1cnJlbnQiXSwibWFwcGluZ3MiOiI7Ozs7K0JBMktBOzs7ZUFBQTs7O3VCQTNLNkM7OEJBQ2Q7MkVBSUE7c0JBQ1A7d0JBQ0U7OEJBQ007bUNBQ0g7eUJBQytDOzs7Ozs7QUFFNUU7Ozs7Q0FJQyxHQUNELE1BQU1BLFdBQVcsQ0FBS0M7SUFDcEIsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLGtCQUFrQixLQUFLLEVBQUVDLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxRQUFRLEVBQUUsR0FBR0w7SUFFeEUsTUFBTU0sWUFBWUMsSUFBQUEseUJBQWdCO0lBQ2xDLE1BQU1DLGFBQWFDLElBQUFBLDBCQUFpQjtJQUNwQyxNQUFNLEVBQUVDLElBQUksRUFBRSxHQUFHQyxJQUFBQSxhQUFPO0lBQ3hCLE1BQU0sRUFBRUMsRUFBRSxFQUFFLEdBQUdDLElBQUFBLDZCQUFlO0lBQzlCLE1BQU1DLFlBQVlDLElBQUFBLCtCQUFZO0lBQzlCLE1BQU1DLFFBQVFDLElBQUFBLHNCQUFhLEVBQUMsQ0FBQyxDQUFDQyxPQUFPLEdBQUtBLE1BQU0sQ0FBQ2QsS0FBSztJQUN0RCxNQUFNLEVBQUVlLENBQUMsRUFBRSxHQUFHQyxJQUFBQSw0QkFBYztJQUM1QixNQUFNQyxnQkFBZ0JKLElBQUFBLHNCQUFhLEVBQUMsQ0FBQyxDQUFDSyxHQUFHQyxTQUFTLEdBQUtBO0lBQ3ZELE1B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