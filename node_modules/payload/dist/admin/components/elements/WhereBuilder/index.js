"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _qs = /*#__PURE__*/ _interop_require_default(require("qs"));
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _reactrouterdom = require("react-router-dom");
const _flattenTopLevelFields = /*#__PURE__*/ _interop_require_default(require("../../../../utilities/flattenTopLevelFields"));
const _getTranslation = require("../../../../utilities/getTranslation");
const _useThrottledEffect = /*#__PURE__*/ _interop_require_default(require("../../../hooks/useThrottledEffect"));
const _SearchParams = require("../../utilities/SearchParams");
const _Button = /*#__PURE__*/ _interop_require_default(require("../Button"));
const _Condition = /*#__PURE__*/ _interop_require_default(require("./Condition"));
const _fieldtypes = /*#__PURE__*/ _interop_require_default(require("./field-types"));
require("./index.scss");
const _reducer = /*#__PURE__*/ _interop_require_default(require("./reducer"));
const _transformWhereQuery = require("./transformWhereQuery");
const _validateWhereQuery = /*#__PURE__*/ _interop_require_default(require("./validateWhereQuery"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'where-builder';
const reduceFields = (fields, i18n)=>(0, _flattenTopLevelFields.default)(fields).reduce((reduced, field)=>{
        if (typeof _fieldtypes.default[field.type] === 'object') {
            const operatorKeys = new Set();
            const operators = _fieldtypes.default[field.type].operators.reduce((acc, operator)=>{
                if (!operatorKeys.has(operator.value)) {
                    operatorKeys.add(operator.value);
                    return [
                        ...acc,
                        {
                            ...operator,
                            label: i18n.t(`operators:${operator.label}`)
                        }
                    ];
                }
                return acc;
            }, []);
            const formattedField = {
                label: (0, _getTranslation.getTranslation)(field.label || field.name, i18n),
                value: field.name,
                ..._fieldtypes.default[field.type],
                operators,
                props: {
                    ...field
                }
            };
            return [
                ...reduced,
                formattedField
            ];
        }
        return reduced;
    }, []);
/**
 * The WhereBuilder component is used to render the filter controls for a collection's list view.
 * It is part of the {@link ListControls} component which is used to render the controls (search, filter, where).
 */ const WhereBuilder = (props)=>{
    const { collection: { labels: { plural } = {} } = {}, collection, handleChange, modifySearchQuery = true } = props;
    const history = (0, _reactrouterdom.useHistory)();
    const params = (0, _SearchParams.useSearchParams)();
    const { i18n, t } = (0, _reacti18next.useTranslation)('general');
    // This handles initializing the where conditions from the search query (URL). That way, if you pass in
    // query params to the URL, the where conditions will be initialized from those and displayed in the UI.
    // Example: /admin/collections/posts?where[or][0][and][0][text][equals]=example%20post
    const [conditions, dispatchConditions] = (0, _react.useReducer)(_reducer.default, params.where, (whereFromSearch)=>{
        if (modifySearchQuery && whereFromSearch) {
            if ((0, _validateWhereQuery.default)(whereFromSearch)) {
                return whereFromSearch.or;
            }
            // Transform the where query to be in the right format. This will transform something simple like [text][equals]=example%20post to the right format
            const transformedWhere = (0, _transformWhereQuery.transformWhereQuery)(whereFromSearch);
            if ((0, _validateWhereQuery.default)(transformedWhere)) {
                return transformedWhere.or;
            }
            console.warn('Invalid where query in URL. Ignoring.');
        }
        return [];
    });
    const [reducedFields] = (0, _react.useState)(()=>reduceFields(collection.fields, i18n));
    // This handles updating the search query (URL) when the where conditions change
    (0, _useThrottledEffect.default)(()=>{
        const currentParams = _qs.default.parse(history.location.search, {
            depth: 10,
            ignoreQueryPrefix: true
        });
        const paramsToKeep = typeof currentParams?.where === 'object' && 'or' in currentParams.where ? currentParams.where.or.reduce((keptParams, param)=>{
            const newParam = {
                ...param
            };
            if (param.and) {
                delete newParam.and;
            }
            return [
                ...keptParams,
                newParam
            ];
        }, []) : [];
        const hasNewWhereConditions = conditions.length > 0;
        const newWhereQuery = {
            ...typeof currentParams?.where === 'object' && ((0, _validateWhereQuery.default)(currentParams?.where) || !hasNewWhereConditions) ? currentParams.where : {},
            or: [
                ...conditions,
                ...paramsToKeep
            ]
        };
        if (handleChange) handleChange(newWhereQuery);
        const hasExistingConditions = typeof currentParams?.where === 'object' && 'or' in currentParams.where;
        if (modifySearchQuery && (hasExistingConditions && !hasNewWhereConditions || hasNewWhereConditions)) {
            history.replace({
                search: _qs.default.stringify({
                    ...currentParams,
                    page: 1,
                    where: newWhereQuery
                }, {
                    addQueryPrefix: true
                })
            });
        }
    }, 500, [
        conditions,
        modifySearchQuery,
        handleChange
    ]);
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: baseClass
    }, conditions.length > 0 && /*#__PURE__*/ _react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__label`
    }, t('filterWhere', {
        label: (0, _getTranslation.getTranslation)(plural, i18n)
    })), /*#__PURE__*/ _react.default.createElement("ul", {
        className: `${baseClass}__or-filters`
    }, conditions.map((or, orIndex)=>/*#__PURE__*/ _react.default.createElement("li", {
            key: orIndex
        }, orIndex !== 0 && /*#__PURE__*/ _react.default.createElement("div", {
            className: `${baseClass}__label`
        }, t('or')), /*#__PURE__*/ _react.default.createElement("ul", {
            className: `${baseClass}__and-filters`
        }, Array.isArray(or?.and) && or.and.map((_, andIndex)=>/*#__PURE__*/ _react.default.createElement("li", {
                key: andIndex
            }, andIndex !== 0 && /*#__PURE__*/ _react.default.createElement("div", {
                className: `${baseClass}__label`
            }, t('and')), /*#__PURE__*/ _react.default.createElement(_Condition.default, {
                andIndex: andIndex,
                dispatch: dispatchConditions,
                fields: reducedFields,
                key: andIndex,
                orIndex: orIndex,
                value: conditions[orIndex].and[andIndex]
            }))))))), /*#__PURE__*/ _react.default.createElement(_Button.default, {
        buttonStyle: "icon-label",
        className: `${baseClass}__add-or`,
        icon: "plus",
        iconPosition: "left",
        iconStyle: "with-border",
        onClick: ()=>{
            if (reducedFields.length > 0) dispatchConditions({
                field: reducedFields[0].value,
                type: 'add'
            });
        }
    }, t('or'))), conditions.length === 0 && /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__no-filters`
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__label`
    }, t('noFiltersSet')), /*#__PURE__*/ _react.default.createElement(_Button.default, {
        buttonStyle: "icon-label",
        className: `${baseClass}__add-first-filter`,
        icon: "plus",
        iconPosition: "left",
        iconStyle: "with-border",
        onClick: ()=>{
            if (reducedFields.length > 0) dispatchConditions({
                field: reducedFields[0].value,
                type: 'add'
            });
        }
    }, t('addFilter'))));
};
const _default = WhereBuilder;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2VsZW1lbnRzL1doZXJlQnVpbGRlci9pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHF1ZXJ5U3RyaW5nIGZyb20gJ3FzJ1xuaW1wb3J0IFJlYWN0LCB7IHVzZVJlZHVjZXIsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VUcmFuc2xhdGlvbiB9IGZyb20gJ3JlYWN0LWkxOG5leHQnXG5pbXBvcnQgeyB1c2VIaXN0b3J5IH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSdcblxuaW1wb3J0IHR5cGUgeyBXaGVyZSB9IGZyb20gJy4uLy4uLy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBQcm9wcyB9IGZyb20gJy4vdHlwZXMnXG5cbmltcG9ydCBmbGF0dGVuVG9wTGV2ZWxGaWVsZHMgZnJvbSAnLi4vLi4vLi4vLi4vdXRpbGl0aWVzL2ZsYXR0ZW5Ub3BMZXZlbEZpZWxkcydcbmltcG9ydCB7IGdldFRyYW5zbGF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbGl0aWVzL2dldFRyYW5zbGF0aW9uJ1xuaW1wb3J0IHVzZVRocm90dGxlZEVmZmVjdCBmcm9tICcuLi8uLi8uLi9ob29rcy91c2VUaHJvdHRsZWRFZmZlY3QnXG5pbXBvcnQgeyB1c2VTZWFyY2hQYXJhbXMgfSBmcm9tICcuLi8uLi91dGlsaXRpZXMvU2VhcmNoUGFyYW1zJ1xuaW1wb3J0IEJ1dHRvbiBmcm9tICcuLi9CdXR0b24nXG5pbXBvcnQgQ29uZGl0aW9uIGZyb20gJy4vQ29uZGl0aW9uJ1xuaW1wb3J0IGZpZWxkVHlwZXMgZnJvbSAnLi9maWVsZC10eXBlcydcbmltcG9ydCAnLi9pbmRleC5zY3NzJ1xuaW1wb3J0IHJlZHVjZXIgZnJvbSAnLi9yZWR1Y2VyJ1xuaW1wb3J0IHsgdHJhbnNmb3JtV2hlcmVRdWVyeSB9IGZyb20gJy4vdHJhbnNmb3JtV2hlcmVRdWVyeSdcbmltcG9ydCB2YWxpZGF0ZVdoZXJlUXVlcnkgZnJvbSAnLi92YWxpZGF0ZVdoZXJlUXVlcnknXG5cbmNvbnN0IGJhc2VDbGFzcyA9ICd3aGVyZS1idWlsZGVyJ1xuXG5jb25zdCByZWR1Y2VGaWVsZHMgPSAoZmllbGRzLCBpMThuKSA9PlxuICBmbGF0dGVuVG9wTGV2ZWxGaWVsZHMoZmllbGRzKS5yZWR1Y2UoKHJlZHVjZWQsIGZpZWxkKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZFR5cGVzW2ZpZWxkLnR5cGVdID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3Qgb3BlcmF0b3JLZXlzID0gbmV3IFNldCgpXG4gICAgICBjb25zdCBvcGVyYXRvcnMgPSBmaWVsZFR5cGVzW2ZpZWxkLnR5cGVdLm9wZXJhdG9ycy5yZWR1Y2UoKGFjYywgb3BlcmF0b3IpID0+IHtcbiAgICAgICAgaWYgKCFvcGVyYXRvcktleXMuaGFzKG9wZXJhdG9yLnZhbHVlKSkge1xuICAgICAgICAgIG9wZXJhdG9yS2V5cy5hZGQob3BlcmF0b3IudmFsdWUpXG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLi4ub3BlcmF0b3IsXG4gICAgICAgICAgICAgIGxhYmVsOiBpMThuLnQoYG9wZXJhdG9yczoke29wZXJhdG9yLmxhYmVsfWApLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY1xuICAgICAgfSwgW10pXG5cbiAgICAgIGNvbnN0IGZvcm1hdHRlZEZpZWxkID0ge1xuICAgICAgICBsYWJlbDogZ2V0VHJhbnNsYXRpb24oZmllbGQubGFiZWwgfHwgZmllbGQubmFtZSwgaTE4biksXG4gICAgICAgIHZhbHVlOiBmaWVsZC5uYW1lLFxuICAgICAgICAuLi5maWVsZFR5cGVzW2ZpZWxkLnR5cGVdLFxuICAgICAgICBvcGVyYXRvcnMsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgIH0sXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbLi4ucmVkdWNlZCwgZm9ybWF0dGVkRmllbGRdXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZHVjZWRcbiAgfSwgW10pXG5cbi8qKlxuICogVGhlIFdoZXJlQnVpbGRlciBjb21wb25lbnQgaXMgdXNlZCB0byByZW5kZXIgdGhlIGZpbHRlciBjb250cm9scyBmb3IgYSBjb2xsZWN0aW9uJ3MgbGlzdCB2aWV3LlxuICogSXQgaXMgcGFydCBvZiB0aGUge0BsaW5rIExpc3RDb250cm9sc30gY29tcG9uZW50IHdoaWNoIGlzIHVzZWQgdG8gcmVuZGVyIHRoZSBjb250cm9scyAoc2VhcmNoLCBmaWx0ZXIsIHdoZXJlKS5cbiAqL1xuY29uc3QgV2hlcmVCdWlsZGVyOiBSZWFjdC5GQzxQcm9wcz4gPSAocHJvcHMpID0+IHtcbiAgY29uc3Qge1xuICAgIGNvbGxlY3Rpb246IHsgbGFiZWxzOiB7IHBsdXJhbCB9ID0ge30gfSA9IHt9LFxuICAgIGNvbGxlY3Rpb24sXG4gICAgaGFuZGxlQ2hhbmdlLFxuICAgIG1vZGlmeVNlYXJjaFF1ZXJ5ID0gdHJ1ZSxcbiAgfSA9IHByb3BzXG5cbiAgY29uc3QgaGlzdG9yeSA9IHVzZUhpc3RvcnkoKVxuICBjb25zdCBwYXJhbXMgPSB1c2VTZWFyY2hQYXJhbXMoKVxuICBjb25zdCB7IGkxOG4sIHQgfSA9IHVzZVRyYW5zbGF0aW9uKCdnZW5lcmFsJylcblxuICAvLyBUaGlzIGhhbmRsZXMgaW5pdGlhbGl6aW5nIHRoZSB3aGVyZSBjb25kaXRpb25zIGZyb20gdGhlIHNlYXJjaCBxdWVyeSAoVVJMKS4gVGhhdCB3YXksIGlmIHlvdSBwYXNzIGluXG4gIC8vIHF1ZXJ5IHBhcmFtcyB0byB0aGUgVVJMLCB0aGUgd2hlcmUgY29uZGl0aW9ucyB3aWxsIGJlIGluaXRpYWxpemVkIGZyb20gdGhvc2UgYW5kIGRpc3BsYXllZCBpbiB0aGUgVUkuXG4gIC8vIEV4YW1wbGU6IC9hZG1pbi9jb2xsZWN0aW9ucy9wb3N0cz93aGVyZVtvcl1bMF1bYW5kXVswXVt0ZXh0XVtlcXVhbHNdPWV4YW1wbGUlMjBwb3N0XG4gIGNvbnN0IFtjb25kaXRpb25zLCBkaXNwYXRjaENvbmRpdGlvbnNdID0gdXNlUmVkdWNlcihyZWR1Y2VyLCBwYXJhbXMud2hlcmUsICh3aGVyZUZyb21TZWFyY2gpID0+IHtcbiAgICBpZiAobW9kaWZ5U2VhcmNoUXVlcnkgJiYgd2hlcmVGcm9tU2VhcmNoKSB7XG4gICAgICBpZiAodmFsaWRhdGVXaGVyZVF1ZXJ5KHdoZXJlRnJvbVNlYXJjaCkpIHtcbiAgICAgICAgcmV0dXJuIHdoZXJlRnJvbVNlYXJjaC5vclxuICAgICAgfVxuXG4gICAgICAvLyBUcmFuc2Zvcm0gdGhlIHdoZXJlIHF1ZXJ5IHRvIGJlIGluIHRoZSByaWdodCBmb3JtYXQuIFRoaXMgd2lsbCB0cmFuc2Zvcm0gc29tZXRoaW5nIHNpbXBsZSBsaWtlIFt0ZXh0XVtlcXVhbHNdPWV4YW1wbGUlMjBwb3N0IHRvIHRoZSByaWdodCBmb3JtYXRcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkV2hlcmUgPSB0cmFuc2Zvcm1XaGVyZVF1ZXJ5KHdoZXJlRnJvbVNlYXJjaClcblxuICAgICAgaWYgKHZhbGlkYXRlV2hlcmVRdWVyeSh0cmFuc2Zvcm1lZFdoZXJlKSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRXaGVyZS5vclxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLndhcm4oJ0ludmFsaWQgd2hlcmUgcXVlcnkgaW4gVVJMLiBJZ25vcmluZy4nKVxuICAgIH1cbiAgICByZXR1cm4gW11cbiAgfSlcblxuICBjb25zdCBbcmVkdWNlZEZpZWxkc10gPSB1c2VTdGF0ZSgoKSA9PiByZWR1Y2VGaWVsZHMoY29sbGVjdGlvbi5maWVsZHMsIGkxOG4pKVxuXG4gIC8vIFRoaXMgaGFuZGxlcyB1cGRhdGluZyB0aGUgc2VhcmNoIHF1ZXJ5IChVUkwpIHdoZW4gdGhlIHdoZXJlIGNvbmRpdGlvbnMgY2hhbmdlXG4gIHVzZVRocm90dGxlZEVmZmVjdChcbiAgICAoKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50UGFyYW1zID0gcXVlcnlTdHJpbmcucGFyc2UoaGlzdG9yeS5sb2NhdGlvbi5zZWFyY2gsIHtcbiAgICAgICAgZGVwdGg6IDEwLFxuICAgICAgICBpZ25vcmVRdWVyeVByZWZpeDogdHJ1ZSxcbiAgICAgIH0pIGFzIHsgd2hlcmU6IFdoZXJlIH1cblxuICAgICAgY29uc3QgcGFyYW1zVG9LZWVwID1cbiAgICAgICAgdHlwZW9mIGN1cnJlbnRQYXJhbXM/LndoZXJlID09PSAnb2JqZWN0JyAmJiAnb3InIGluIGN1cnJlbnRQYXJhbXMud2hlcmVcbiAgICAgICAgICA/IGN1cnJlbnRQYXJhbXMud2hlcmUub3IucmVkdWNlKChrZXB0UGFyYW1zLCBwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBuZXdQYXJhbSA9IHsgLi4ucGFyYW0gfVxuICAgICAgICAgICAgICBpZiAocGFyYW0uYW5kKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld1BhcmFtLmFuZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBbLi4ua2VwdFBhcmFtcywgbmV3UGFyYW1dXG4gICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgICA6IFtdXG5cbiAgICAgIGNvbnN0IGhhc05ld1doZXJlQ29uZGl0aW9ucyA9IGNvbmRpdGlvbnMubGVuZ3RoID4gMFxuXG4gICAgICBjb25zdCBuZXdXaGVyZVF1ZXJ5ID0ge1xuICAgICAgICAuLi4odHlwZW9mIGN1cnJlbnRQYXJhbXM/LndoZXJlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAodmFsaWRhdGVXaGVyZVF1ZXJ5KGN1cnJlbnRQYXJhbXM/LndoZXJlKSB8fCAhaGFzTmV3V2hlcmVDb25kaXRpb25zKVxuICAgICAgICAgID8gY3VycmVudFBhcmFtcy53aGVyZVxuICAgICAgICAgIDoge30pLFxuICAgICAgICBvcjogWy4uLmNvbmRpdGlvbnMsIC4uLnBhcmFtc1RvS2VlcF0sXG4gICAgICB9XG5cbiAgICAgIGlmIChoYW5kbGVDaGFuZ2UpIGhhbmRsZUNoYW5nZShuZXdXaGVyZVF1ZXJ5IGFzIFdoZXJlKVxuXG4gICAgICBjb25zdCBoYXNFeGlzdGluZ0NvbmRpdGlvbnMgPVxuICAgICAgICB0eXBlb2YgY3VycmVudFBhcmFtcz8ud2hlcmUgPT09ICdvYmplY3QnICYmICdvcicgaW4gY3VycmVudFBhcmFtcy53aGVyZVxuXG4gICAgICBpZiAoXG4gICAgICAgIG1vZGlmeVNlYXJjaFF1ZXJ5ICYmXG4gICAgICAgICgoaGFzRXhpc3RpbmdDb25kaXRpb25zICYmICFoYXNOZXdXaGVyZUNvbmRpdGlvbnMpIHx8IGhhc05ld1doZXJlQ29uZGl0aW9ucylcbiAgICAgICkge1xuICAgICAgICBoaXN0b3J5LnJlcGxhY2Uoe1xuICAgICAgICAgIHNlYXJjaDogcXVlcnlTdHJpbmcuc3RyaW5naWZ5KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAuLi5jdXJyZW50UGFyYW1zLFxuICAgICAgICAgICAgICBwYWdlOiAxLFxuICAgICAgICAgICAgICB3aGVyZTogbmV3V2hlcmVRdWVyeSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7IGFkZFF1ZXJ5UHJlZml4OiB0cnVlIH0sXG4gICAgICAgICAgKSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuICAgIDUwMCxcbiAgICBbY29uZGl0aW9ucywgbW9kaWZ5U2VhcmNoUXVlcnksIGhhbmRsZUNoYW5nZV0sXG4gIClcblxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtiYXNlQ2xhc3N9PlxuICAgICAge2NvbmRpdGlvbnMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fbGFiZWxgfT5cbiAgICAgICAgICAgIHt0KCdmaWx0ZXJXaGVyZScsIHsgbGFiZWw6IGdldFRyYW5zbGF0aW9uKHBsdXJhbCwgaTE4bikgfSl9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPHVsIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fb3ItZmlsdGVyc2B9PlxuICAgICAgICAgICAge2NvbmRpdGlvbnMubWFwKChvciwgb3JJbmRleCkgPT4gKFxuICAgICAgICAgICAgICA8bGkga2V5PXtvckluZGV4fT5cbiAgICAgICAgICAgICAgICB7b3JJbmRleCAhPT0gMCAmJiA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fbGFiZWxgfT57dCgnb3InKX08L2Rpdj59XG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fYW5kLWZpbHRlcnNgfT5cbiAgICAgICAgICAgICAgICAgIHtBcnJheS5pc0FycmF5KG9yPy5hbmQpICYmXG4gICAgICAgICAgICAgICAgICAgIG9yLmFuZC5tYXAoKF8sIGFuZEluZGV4KSA9PiAoXG4gICAgICAgICAgICAgICAgICAgICAgPGxpIGtleT17YW5kSW5kZXh9PlxuICAgICAgICAgICAgICAgICAgICAgICAge2FuZEluZGV4ICE9PSAwICYmIDxkaXYgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19sYWJlbGB9Pnt0KCdhbmQnKX08L2Rpdj59XG4gICAgICAgICAgICAgICAgICAgICAgICA8Q29uZGl0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFuZEluZGV4PXthbmRJbmRleH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2g9e2Rpc3BhdGNoQ29uZGl0aW9uc31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzPXtyZWR1Y2VkRmllbGRzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk9e2FuZEluZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICBvckluZGV4PXtvckluZGV4fVxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17Y29uZGl0aW9uc1tvckluZGV4XS5hbmRbYW5kSW5kZXhdfVxuICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgICA8QnV0dG9uXG4gICAgICAgICAgICBidXR0b25TdHlsZT1cImljb24tbGFiZWxcIlxuICAgICAgICAgICAgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19hZGQtb3JgfVxuICAgICAgICAgICAgaWNvbj1cInBsdXNcIlxuICAgICAgICAgICAgaWNvblBvc2l0aW9uPVwibGVmdFwiXG4gICAgICAgICAgICBpY29uU3R5bGU9XCJ3aXRoLWJvcmRlclwiXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZWR1Y2VkRmllbGRzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hDb25kaXRpb25zKHsgZmllbGQ6IHJlZHVjZWRGaWVsZHNbMF0udmFsdWUsIHR5cGU6ICdhZGQnIH0pXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt0KCdvcicpfVxuICAgICAgICAgIDwvQnV0dG9uPlxuICAgICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICAgICAgKX1cbiAgICAgIHtjb25kaXRpb25zLmxlbmd0aCA9PT0gMCAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19uby1maWx0ZXJzYH0+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2xhYmVsYH0+e3QoJ25vRmlsdGVyc1NldCcpfTwvZGl2PlxuICAgICAgICAgIDxCdXR0b25cbiAgICAgICAgICAgIGJ1dHRvblN0eWxlPVwiaWNvbi1sYWJlbFwiXG4gICAgICAgICAgICBjbGFzc05hbWU9e2Ake2Jhc2VDbGFzc31fX2FkZC1maXJzdC1maWx0ZXJgfVxuICAgICAgICAgICAgaWNvbj1cInBsdXNcIlxuICAgICAgICAgICAgaWNvblBvc2l0aW9uPVwibGVmdFwiXG4gICAgICAgICAgICBpY29uU3R5bGU9XCJ3aXRoLWJvcmRlclwiXG4gICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZWR1Y2VkRmllbGRzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hDb25kaXRpb25zKHsgZmllbGQ6IHJlZHVjZWRGaWVsZHNbMF0udmFsdWUsIHR5cGU6ICdhZGQnIH0pXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt0KCdhZGRGaWx0ZXInKX1cbiAgICAgICAgICA8L0J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IFdoZXJlQnVpbGRlclxuIl0sIm5hbWVzIjpbImJhc2VDbGFzcyIsInJlZHVjZUZpZWxkcyIsImZpZWxkcyIsImkxOG4iLCJmbGF0dGVuVG9wTGV2ZWxGaWVsZHMiLCJyZWR1Y2UiLCJyZWR1Y2VkIiwiZmllbGQiLCJmaWVsZFR5cGVzIiwidHlwZSIsIm9wZXJhdG9yS2V5cyIsIlNldCIsIm9wZXJhdG9ycyIsImFjYyIsIm9wZXJhdG9yIiwiaGFzIiwidmFsdWUiLCJhZGQiLCJsYWJlbCIsInQiLCJmb3JtYXR0ZWRGaWVsZCIsImdldFRyYW5zbGF0aW9uIiwibmFtZSIsInByb3BzIiwiV2hlcmVCdWlsZGVyIiwiY29sbGVjdGlvbiIsImxhYmVscyIsInBsdXJhbCIsImhhbmRsZUNoYW5nZSIsIm1vZGlmeVNlYXJjaFF1ZXJ5IiwiaGlzdG9yeSIsInVzZUhpc3RvcnkiLCJwYXJhbXMiLCJ1c2VTZWFyY2hQYXJhbXMiLCJ1c2VUcmFuc2xhdGlvbiIsImNvbmRpdGlvbnMiLCJkaXNwYXRjaENvbmRpdGlvbnMiLCJ1c2VSZWR1Y2VyIiwicmVkdWNlciIsIndoZXJlIiwid2hlcmVGcm9tU2VhcmNoIiwidmFsaWRhdGVXaGVyZVF1ZXJ5Iiwib3IiLCJ0cmFuc2Zvcm1lZFdoZXJlIiwidHJhbnNmb3JtV2hlcmVRdWVyeSIsImNvbnNvbGUiLCJ3YXJuIiwicmVkdWNlZEZpZWxkcyIsInVzZVN0YXRlIiwidXNlVGhyb3R0bGVkRWZmZWN0IiwiY3VycmVudFBhcmFtcyIsInF1ZXJ5U3RyaW5nIiwicGFyc2UiLCJsb2NhdGlvbiIsInNlYXJjaCIsImRlcHRoIiwiaWdub3JlUXVlcnlQcmVmaXgiLCJwYXJhbXNUb0tlZXAiLCJrZXB0UGFyYW1zIiwicGFyYW0iLCJuZXdQYXJhbSIsImFuZCIsImhhc05ld1doZXJlQ29uZGl0aW9ucyIsImxlbmd0aCIsIm5ld1doZXJlUXVlcnkiLCJoYXNFeGlzdGluZ0NvbmRpdGlvbnMiLCJyZXBsYWNlIiwic3RyaW5naWZ5IiwicGFnZSIsImFkZFF1ZXJ5UHJlZml4IiwiZGl2IiwiY2xhc3NOYW1lIiwiUmVhY3QiLCJGcmFnbWVudCIsInVsIiwibWFwIiwib3JJbmRleCIsImxpIiwia2V5IiwiQXJyYXkiLCJpc0FycmF5IiwiXyIsImFuZEluZGV4IiwiQ29uZGl0aW9uIiwiZGlzcGF0Y2giLCJCdXR0b24iLCJidXR0b25TdHlsZSIsImljb24iLCJpY29uUG9zaXRpb24iLCJpY29uU3R5bGUiLCJvbkNsaWNrIl0sIm1hcHBpbmdzIjoiOzs7OytCQXdOQTs7O2VBQUE7OzsyREF4TndCOytEQUNvQjs4QkFDYjtnQ0FDSjs4RUFLTztnQ0FDSDsyRUFDQTs4QkFDQzsrREFDYjtrRUFDRzttRUFDQztRQUNoQjtnRUFDYTtxQ0FDZ0I7MkVBQ0w7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUUvQixNQUFNQSxZQUFZO0FBRWxCLE1BQU1DLGVBQWUsQ0FBQ0MsUUFBUUMsT0FDNUJDLElBQUFBLDhCQUFxQixFQUFDRixRQUFRRyxNQUFNLENBQUMsQ0FBQ0MsU0FBU0M7UUFDN0MsSUFBSSxPQUFPQyxtQkFBVSxDQUFDRCxNQUFNRSxJQUFJLENBQUMsS0FBSyxVQUFVO1lBQzlDLE1BQU1DLGVBQWUsSUFBSUM7WUFDekIsTUFBTUMsWUFBWUosbUJBQVUsQ0FBQ0QsTUFBTUUsSUFBSSxDQUFDLENBQUNHLFNBQVMsQ0FBQ1AsTUFBTSxDQUFDLENBQUNRLEtBQUtDO2dCQUM5RCxJQUFJLENBQUNKLGFBQWFLLEdBQUcsQ0FBQ0QsU0FBU0UsS0FBSyxHQUFHO29CQUNyQ04sYUFBYU8sR0FBRyxDQUFDSCxTQUFTRSxLQUFLO29CQUMvQixPQUFPOzJCQUNGSDt3QkFDSDs0QkFDRSxHQUFHQyxRQUFROzRCQUNYSSxPQUFPZixLQUFLZ0IsQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFTCxTQUFTSSxLQUFLLENBQUMsQ0FBQzt3QkFDN0M7cUJBQ0Q7Z0JBQ0g7Z0JBQ0EsT0FBT0w7WUFDVCxHQUFHLEVBQUU7WUFFTCxNQUFNTyxpQkFBaUI7Z0JBQ3JCRixPQUFPRyxJQUFBQSw4QkFBYyxFQUFDZCxNQUFNVyxLQUFLLElBQUlYLE1BQU1lLElBQUksRUFBRW5CO2dCQUNqRGEsT0FBT1QsTUFBTWUsSUFBSTtnQkFDakIsR0FBR2QsbUJBQVUsQ0FBQ0QsTUFBTUUsSUFBSSxDQUFDO2dCQUN6Qkc7Z0JBQ0FXLE9BQU87b0JBQ0wsR0FBR2hCLEtBQUs7Z0JBQ1Y7WUFDRjtZQUVBLE9BQU87bUJBQUlEO2dCQUFTYzthQUFlO1FBQ3JDO1FBRUEsT0FBT2Q7SUFDVCxHQUFHLEVBQUU7QUFFUDs7O0NBR0MsR0FDRCxNQUFNa0IsZUFBZ0MsQ0FBQ0Q7SUFDckMsTUFBTSxFQUNKRSxZQUFZLEVBQUVDLFFBQVEsRUFBRUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsRUFDNUNGLFVBQVUsRUFDVkcsWUFBWSxFQUNaQyxvQkFBb0IsSUFBSSxFQUN6QixHQUFHTjtJQUVKLE1BQU1PLFVBQVVDLElBQUFBLDBCQUFVO0lBQzFCLE1BQU1DLFNBQVNDLElBQUFBLDZCQUFlO0lBQzlCLE1BQU0sRUFBRTlCLElBQUksRUFBRWdCLENBQUMsRUFBRSxHQUFHZSxJQUFBQSw0QkFBYyxFQUFDO0lBRW5DLHVHQUF1RztJQUN2Ryx3R0FBd0c7SUFDeEcsc0ZBQXNGO0lBQ3RGLE1BQU0sQ0FBQ0MsWUFBWUMsbUJBQW1CLEdBQUdDLElBQUFBLGlCQUFVLEVBQUNDLGdCQUFPLEVBQUVOLE9BQU9PLEtBQUssRUFBRSxDQUFDQztRQUMxRSxJQUFJWCxxQkFBcUJXLGlCQUFpQjtZQUN4QyxJQUFJQyxJQUFBQSwyQkFBa0IsRUFBQ0Qsa0JBQWtCO2dCQUN2QyxPQUFPQSxnQkFBZ0JFLEVBQUU7WUFDM0I7WUFFQSxtSkFBbUo7WUFDbkosTUFBTUMsbUJBQW1CQyxJQUFBQSx3Q0FBbUIsRUFBQ0o7WUFFN0MsSUFBSUMsSUFBQUEsMkJBQWtCLEVBQUNFLG1CQUFtQjtnQkFDeEMsT0FBT0EsaUJBQWlCRCxFQUFFO1lBQzVCO1lBRUFHLFFBQVFDLElBQUksQ0FBQztRQUNmO1FBQ0EsT0FBTyxFQUFFO0lBQ1g7SUFFQSxNQUFNLENBQUNDLGNBQWMsR0FBR0MsSUFBQUEsZUFBUSxFQUFDLElBQU0vQyxhQUFhd0IsV0FBV3ZCLE1BQU0sRUFBRUM7SUFFdkUsZ0ZBQWdGO0lBQ2hGOEMsSUFBQUEsMkJBQWtCLEVBQ2hCO1FBQ0UsTUFBTUMsZ0JBQWdCQyxXQUFXLENBQUNDLEtBQUssQ0FBQ3RCLFFBQVF1QixRQUFRLENBQUNDLE1BQU0sRUFBRTtZQUMvREMsT0FBTztZQUNQQyxtQkFBbUI7UUFDckI7UUFFQSxNQUFNQyxlQUNKLE9BQU9QLGVBQWVYLFVBQVUsWUFBWSxRQUFRVyxjQUFjWCxLQUFLLEdBQ25FVyxjQUFjWCxLQUFLLENBQUNHLEVBQUUsQ0FBQ3JDLE1BQU0sQ0FBQyxDQUFDcUQsWUFBWUM7WUFDekMsTUFBTUMsV0FBVztnQkFBRSxHQUFHRCxLQUFLO1lBQUM7WUFDNUIsSUFBSUEsTUFBTUUsR0FBRyxFQUFFO2dCQUNiLE9BQU9ELFNBQVNDLEdBQUc7WUFDckI7WUFDQSxPQUFPO21CQUFJSDtnQkFBWUU7YUFBUztRQUNsQyxHQUFHLEVBQUUsSUFDTCxFQUFFO1FBRVIsTUFBTUUsd0JBQXdCM0IsV0FBVzRCLE1BQU0sR0FBRztRQUVsRCxNQUFNQyxnQkFBZ0I7WUFDcEIsR0FBSSxPQUFPZCxlQUFlWCxVQUFVLFlBQ25DRSxDQUFBQSxJQUFBQSwyQkFBa0IsRUFBQ1MsZUFBZVgsVUFBVSxDQUFDdUIscUJBQW9CLElBQzlEWixjQUFjWCxLQUFLLEdBQ25CLENBQUMsQ0FBQztZQUNORyxJQUFJO21CQUFJUDttQkFBZXNCO2FBQWE7UUFDdEM7UUFFQSxJQUFJN0IsY0FBY0EsYUFBYW9DO1FBRS9CLE1BQU1DLHdCQUNKLE9BQU9mLGVBQWVYLFVBQVUsWUFBWSxRQUFRVyxjQUFjWCxLQUFLO1FBRXpFLElBQ0VWLHFCQUNDLENBQUEsQUFBQ29DLHlCQUF5QixDQUFDSCx5QkFBMEJBLHFCQUFvQixHQUMxRTtZQUNBaEMsUUFBUW9DLE9BQU8sQ0FBQztnQkFDZFosUUFBUUgsV0FBVyxDQUFDZ0IsU0FBUyxDQUMzQjtvQkFDRSxHQUFHakIsYUFBYTtvQkFDaEJrQixNQUFNO29CQUNON0IsT0FBT3lCO2dCQUNULEdBQ0E7b0JBQUVLLGdCQUFnQjtnQkFBSztZQUUzQjtRQUNGO0lBQ0YsR0FDQSxLQUNBO1FBQUNsQztRQUFZTjtRQUFtQkQ7S0FBYTtJQUcvQyxxQkFDRSw2QkFBQzBDO1FBQUlDLFdBQVd2RTtPQUNibUMsV0FBVzRCLE1BQU0sR0FBRyxtQkFDbkIsNkJBQUNTLGNBQUssQ0FBQ0MsUUFBUSxzQkFDYiw2QkFBQ0g7UUFBSUMsV0FBVyxDQUFDLEVBQUV2RSxVQUFVLE9BQU8sQ0FBQztPQUNsQ21CLEVBQUUsZUFBZTtRQUFFRCxPQUFPRyxJQUFBQSw4QkFBYyxFQUFDTSxRQUFReEI7SUFBTSxtQkFFMUQsNkJBQUN1RTtRQUFHSCxXQUFXLENBQUMsRUFBRXZFLFVBQVUsWUFBWSxDQUFDO09BQ3RDbUMsV0FBV3dDLEdBQUcsQ0FBQyxDQUFDakMsSUFBSWtDLHdCQUNuQiw2QkFBQ0M7WUFBR0MsS0FBS0Y7V0FDTkEsWUFBWSxtQkFBSyw2QkFBQ047WUFBSUMsV0FBVyxDQUFDLEVBQUV2RSxVQUFVLE9BQU8sQ0FBQztXQUFHbUIsRUFBRSxzQkFDNUQsNkJBQUN1RDtZQUFHSCxXQUFXLENBQUMsRUFBRXZFLFVBQVUsYUFBYSxDQUFDO1dBQ3ZDK0UsTUFBTUMsT0FBTyxDQUFDdEMsSUFBSW1CLFFBQ2pCbkIsR0FBR21CLEdBQUcsQ0FBQ2MsR0FBRyxDQUFDLENBQUNNLEdBQUdDLHlCQUNiLDZCQUFDTDtnQkFBR0MsS0FBS0k7ZUFDTkEsYUFBYSxtQkFBSyw2QkFBQ1o7Z0JBQUlDLFdBQVcsQ0FBQyxFQUFFdkUsVUFBVSxPQUFPLENBQUM7ZUFBR21CLEVBQUUsdUJBQzdELDZCQUFDZ0Usa0JBQVM7Z0JBQ1JELFVBQVVBO2dCQUNWRSxVQUFVaEQ7Z0JBQ1ZsQyxRQUFRNkM7Z0JBQ1IrQixLQUFLSTtnQkFDTE4sU0FBU0E7Z0JBQ1Q1RCxPQUFPbUIsVUFBVSxDQUFDeUMsUUFBUSxDQUFDZixHQUFHLENBQUNxQixTQUFTO29DQVF4RCw2QkFBQ0csZUFBTTtRQUNMQyxhQUFZO1FBQ1pmLFdBQVcsQ0FBQyxFQUFFdkUsVUFBVSxRQUFRLENBQUM7UUFDakN1RixNQUFLO1FBQ0xDLGNBQWE7UUFDYkMsV0FBVTtRQUNWQyxTQUFTO1lBQ1AsSUFBSTNDLGNBQWNnQixNQUFNLEdBQUcsR0FDekIzQixtQkFBbUI7Z0JBQUU3QixPQUFPd0MsYUFBYSxDQUFDLEVBQUUsQ0FBQy9CLEtBQUs7Z0JBQUVQLE1BQU07WUFBTTtRQUNwRTtPQUVDVSxFQUFFLFNBSVJnQixXQUFXNEIsTUFBTSxLQUFLLG1CQUNyQiw2QkFBQ087UUFBSUMsV0FBVyxDQUFDLEVBQUV2RSxVQUFVLFlBQVksQ0FBQztxQkFDeEMsNkJBQUNzRTtRQUFJQyxXQUFXLENBQUMsRUFBRXZFLFVBQVUsT0FBTyxDQUFDO09BQUdtQixFQUFFLGdDQUMxQyw2QkFBQ2tFLGVBQU07UUFDTEMsYUFBWTtRQUNaZixXQUFXLENBQUMsRUFBRXZFLFVBQVUsa0JBQWtCLENBQUM7UUFDM0N1RixNQUFLO1FBQ0xDLGNBQWE7UUFDYkMsV0FBVTtRQUNWQyxTQUFTO1lBQ1AsSUFBSTNDLGNBQWNnQixNQUFNLEdBQUcsR0FDekIzQixtQkFBbUI7Z0JBQUU3QixPQUFPd0MsYUFBYSxDQUFDLEVBQUUsQ0FBQy9CLEtBQUs7Z0JBQUVQLE1BQU07WUFBTTtRQUNwRTtPQUVDVSxFQUFFO0FBTWY7TUFFQSxXQUFlSyJ9