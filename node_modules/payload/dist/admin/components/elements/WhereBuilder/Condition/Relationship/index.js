"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _useDebounce = /*#__PURE__*/ _interop_require_default(require("../../../../../hooks/useDebounce"));
const _Config = require("../../../../utilities/Config");
const _ReactSelect = /*#__PURE__*/ _interop_require_default(require("../../../ReactSelect"));
require("./index.scss");
const _optionsReducer = /*#__PURE__*/ _interop_require_default(require("./optionsReducer"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'condition-value-relationship';
const maxResultsPerRequest = 10;
const RelationshipField = (props)=>{
    const { admin: { isSortable } = {}, disabled, hasMany, onChange, relationTo, value } = props;
    const { collections, routes: { api }, serverURL } = (0, _Config.useConfig)();
    const hasMultipleRelations = Array.isArray(relationTo);
    const [options, dispatchOptions] = (0, _react.useReducer)(_optionsReducer.default, []);
    const [lastFullyLoadedRelation, setLastFullyLoadedRelation] = (0, _react.useState)(-1);
    const [lastLoadedPage, setLastLoadedPage] = (0, _react.useState)(1);
    const [search, setSearch] = (0, _react.useState)('');
    const [errorLoading, setErrorLoading] = (0, _react.useState)('');
    const [hasLoadedFirstOptions, setHasLoadedFirstOptions] = (0, _react.useState)(false);
    const debouncedSearch = (0, _useDebounce.default)(search, 300);
    const { i18n, t } = (0, _reacti18next.useTranslation)('general');
    const addOptions = (0, _react.useCallback)((data, relation)=>{
        const collection = collections.find((coll)=>coll.slug === relation);
        dispatchOptions({
            collection,
            data,
            hasMultipleRelations,
            i18n,
            relation,
            type: 'ADD'
        });
    }, [
        collections,
        hasMultipleRelations,
        i18n
    ]);
    const getResults = (0, _react.useCallback)(async ({ lastFullyLoadedRelation: lastFullyLoadedRelationArg, lastLoadedPage: lastLoadedPageArg, search: searchArg })=>{
        let lastLoadedPageToUse = typeof lastLoadedPageArg !== 'undefined' ? lastLoadedPageArg : 1;
        const lastFullyLoadedRelationToUse = typeof lastFullyLoadedRelationArg !== 'undefined' ? lastFullyLoadedRelationArg : -1;
        const relations = Array.isArray(relationTo) ? relationTo : [
            relationTo
        ];
        const relationsToFetch = lastFullyLoadedRelationToUse === -1 ? relations : relations.slice(lastFullyLoadedRelationToUse + 1);
        let resultsFetched = 0;
        if (!errorLoading) {
            relationsToFetch.reduce(async (priorRelation, relation)=>{
                await priorRelation;
                if (resultsFetched < 10) {
                    const collection = collections.find((coll)=>coll.slug === relation);
                    const fieldToSearch = collection?.admin?.useAsTitle || 'id';
                    const searchParam = searchArg ? `&where[${fieldToSearch}][like]=${searchArg}` : '';
                    const response = await fetch(`${serverURL}${api}/${relation}?limit=${maxResultsPerRequest}&page=${lastLoadedPageToUse}&depth=0${searchParam}`, {
                        credentials: 'include',
                        headers: {
                            'Accept-Language': i18n.language
                        }
                    });
                    if (response.ok) {
                        const data = await response.json();
                        if (data.docs.length > 0) {
                            resultsFetched += data.docs.length;
                            addOptions(data, relation);
                            setLastLoadedPage(data.page);
                            if (!data.nextPage) {
                                setLastFullyLoadedRelation(relations.indexOf(relation));
                                // If there are more relations to search, need to reset lastLoadedPage to 1
                                // both locally within function and state
                                if (relations.indexOf(relation) + 1 < relations.length) {
                                    lastLoadedPageToUse = 1;
                                }
                            }
                        }
                    } else {
                        setErrorLoading(t('errors:unspecific'));
                    }
                }
            }, Promise.resolve());
        }
    }, [
        i18n,
        relationTo,
        errorLoading,
        collections,
        serverURL,
        api,
        addOptions,
        t
    ]);
    const findOptionsByValue = (0, _react.useCallback)(()=>{
        if (value) {
            if (hasMany) {
                if (Array.isArray(value)) {
                    return value.map((val)=>{
                        if (hasMultipleRelations) {
                            let matchedOption;
                            options.forEach((opt)=>{
                                if (opt.options) {
                                    opt.options.some((subOpt)=>{
                                        if (subOpt?.value === val.value) {
                                            matchedOption = subOpt;
                                            return true;
                                        }
                                        return false;
                                    });
                                }
                            });
                            return matchedOption;
                        }
                        return options.find((opt)=>opt.value === val);
                    });
                }
                return undefined;
            }
            if (hasMultipleRelations) {
                let matchedOption;
                const valueWithRelation = value;
                options.forEach((opt)=>{
                    if (opt?.options) {
                        opt.options.some((subOpt)=>{
                            if (subOpt?.value === valueWithRelation.value) {
                                matchedOption = subOpt;
                                return true;
                            }
                            return false;
                        });
                    }
                });
                return matchedOption;
            }
            return options.find((opt)=>opt.value === value);
        }
        return undefined;
    }, [
        hasMany,
        hasMultipleRelations,
        value,
        options
    ]);
    const handleInputChange = (0, _react.useCallback)((newSearch)=>{
        if (search !== newSearch) {
            setSearch(newSearch);
        }
    }, [
        search
    ]);
    const addOptionByID = (0, _react.useCallback)(async (id, relation)=>{
        if (!errorLoading && id !== 'null') {
            const response = await fetch(`${serverURL}${api}/${relation}/${id}?depth=0`, {
                credentials: 'include',
                headers: {
                    'Accept-Language': i18n.language
                }
            });
            if (response.ok) {
                const data = await response.json();
                addOptions({
                    docs: [
                        data
                    ]
                }, relation);
            } else {
                console.error(t('error:loadingDocument', {
                    id
                }));
            }
        }
    }, [
        i18n,
        addOptions,
        api,
        errorLoading,
        serverURL,
        t
    ]);
    // ///////////////////////////
    // Get results when search input changes
    // ///////////////////////////
    (0, _react.useEffect)(()=>{
        dispatchOptions({
            i18n,
            required: true,
            type: 'CLEAR'
        });
        setHasLoadedFirstOptions(true);
        setLastLoadedPage(1);
        setLastFullyLoadedRelation(-1);
        getResults({
            search: debouncedSearch
        });
    }, [
        getResults,
        debouncedSearch,
        relationTo,
        i18n
    ]);
    // ///////////////////////////
    // Format options once first options have been retrieved
    // ///////////////////////////
    (0, _react.useEffect)(()=>{
        if (value && hasLoadedFirstOptions) {
            if (hasMany) {
                const matchedOptions = findOptionsByValue();
                (matchedOptions || []).forEach((option, i)=>{
                    if (!option) {
                        if (hasMultipleRelations) {
                            addOptionByID(value[i].value, value[i].relationTo);
                        } else {
                            addOptionByID(value[i], relationTo);
                        }
                    }
                });
            } else {
                const matchedOption = findOptionsByValue();
                if (!matchedOption) {
                    if (hasMultipleRelations) {
                        const valueWithRelation = value;
                        addOptionByID(valueWithRelation.value, valueWithRelation.relationTo);
                    } else {
                        addOptionByID(value, relationTo);
                    }
                }
            }
        }
    }, [
        addOptionByID,
        findOptionsByValue,
        hasMany,
        hasMultipleRelations,
        relationTo,
        value,
        hasLoadedFirstOptions
    ]);
    const classes = [
        'field-type',
        baseClass,
        errorLoading && 'error-loading'
    ].filter(Boolean).join(' ');
    const valueToRender = findOptionsByValue() || value;
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: classes
    }, !errorLoading && /*#__PURE__*/ _react.default.createElement(_ReactSelect.default, {
        disabled: disabled,
        isMulti: hasMany,
        isSortable: isSortable,
        onChange: (selected)=>{
            if (hasMany) {
                onChange(selected ? selected.map((option)=>{
                    if (hasMultipleRelations) {
                        return {
                            relationTo: option.relationTo,
                            value: option.value
                        };
                    }
                    return option.value;
                }) : null);
            } else if (hasMultipleRelations) {
                onChange({
                    relationTo: selected.relationTo,
                    value: selected.value
                });
            } else {
                onChange(selected.value);
            }
        },
        onInputChange: handleInputChange,
        onMenuScrollToBottom: ()=>{
            getResults({
                lastFullyLoadedRelation,
                lastLoadedPage: lastLoadedPage + 1
            });
        },
        options: options,
        placeholder: t('selectValue'),
        value: valueToRender
    }), errorLoading && /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__error-loading`
    }, errorLoading));
};
const _default = RelationshipField;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2VsZW1lbnRzL1doZXJlQnVpbGRlci9Db25kaXRpb24vUmVsYXRpb25zaGlwL2luZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVkdWNlciwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVRyYW5zbGF0aW9uIH0gZnJvbSAncmVhY3QtaTE4bmV4dCdcblxuaW1wb3J0IHR5cGUgeyBQYWdpbmF0ZWREb2NzIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vZGF0YWJhc2UvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IE9wdGlvbiB9IGZyb20gJy4uLy4uLy4uL1JlYWN0U2VsZWN0L3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBHZXRSZXN1bHRzLCBQcm9wcywgVmFsdWVXaXRoUmVsYXRpb24gfSBmcm9tICcuL3R5cGVzJ1xuXG5pbXBvcnQgdXNlRGVib3VuY2UgZnJvbSAnLi4vLi4vLi4vLi4vLi4vaG9va3MvdXNlRGVib3VuY2UnXG5pbXBvcnQgeyB1c2VDb25maWcgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlsaXRpZXMvQ29uZmlnJ1xuaW1wb3J0IFJlYWN0U2VsZWN0IGZyb20gJy4uLy4uLy4uL1JlYWN0U2VsZWN0J1xuaW1wb3J0ICcuL2luZGV4LnNjc3MnXG5pbXBvcnQgb3B0aW9uc1JlZHVjZXIgZnJvbSAnLi9vcHRpb25zUmVkdWNlcidcblxuY29uc3QgYmFzZUNsYXNzID0gJ2NvbmRpdGlvbi12YWx1ZS1yZWxhdGlvbnNoaXAnXG5cbmNvbnN0IG1heFJlc3VsdHNQZXJSZXF1ZXN0ID0gMTBcblxuY29uc3QgUmVsYXRpb25zaGlwRmllbGQ6IFJlYWN0LkZDPFByb3BzPiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB7IGFkbWluOiB7IGlzU29ydGFibGUgfSA9IHt9LCBkaXNhYmxlZCwgaGFzTWFueSwgb25DaGFuZ2UsIHJlbGF0aW9uVG8sIHZhbHVlIH0gPSBwcm9wc1xuXG4gIGNvbnN0IHtcbiAgICBjb2xsZWN0aW9ucyxcbiAgICByb3V0ZXM6IHsgYXBpIH0sXG4gICAgc2VydmVyVVJMLFxuICB9ID0gdXNlQ29uZmlnKClcblxuICBjb25zdCBoYXNNdWx0aXBsZVJlbGF0aW9ucyA9IEFycmF5LmlzQXJyYXkocmVsYXRpb25UbylcbiAgY29uc3QgW29wdGlvbnMsIGRpc3BhdGNoT3B0aW9uc10gPSB1c2VSZWR1Y2VyKG9wdGlvbnNSZWR1Y2VyLCBbXSlcbiAgY29uc3QgW2xhc3RGdWxseUxvYWRlZFJlbGF0aW9uLCBzZXRMYXN0RnVsbHlMb2FkZWRSZWxhdGlvbl0gPSB1c2VTdGF0ZSgtMSlcbiAgY29uc3QgW2xhc3RMb2FkZWRQYWdlLCBzZXRMYXN0TG9hZGVkUGFnZV0gPSB1c2VTdGF0ZSgxKVxuICBjb25zdCBbc2VhcmNoLCBzZXRTZWFyY2hdID0gdXNlU3RhdGUoJycpXG4gIGNvbnN0IFtlcnJvckxvYWRpbmcsIHNldEVycm9yTG9hZGluZ10gPSB1c2VTdGF0ZSgnJylcbiAgY29uc3QgW2hhc0xvYWRlZEZpcnN0T3B0aW9ucywgc2V0SGFzTG9hZGVkRmlyc3RPcHRpb25zXSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBkZWJvdW5jZWRTZWFyY2ggPSB1c2VEZWJvdW5jZShzZWFyY2gsIDMwMClcbiAgY29uc3QgeyBpMThuLCB0IH0gPSB1c2VUcmFuc2xhdGlvbignZ2VuZXJhbCcpXG5cbiAgY29uc3QgYWRkT3B0aW9ucyA9IHVzZUNhbGxiYWNrKFxuICAgIChkYXRhLCByZWxhdGlvbikgPT4ge1xuICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25zLmZpbmQoKGNvbGwpID0+IGNvbGwuc2x1ZyA9PT0gcmVsYXRpb24pXG4gICAgICBkaXNwYXRjaE9wdGlvbnMoeyBjb2xsZWN0aW9uLCBkYXRhLCBoYXNNdWx0aXBsZVJlbGF0aW9ucywgaTE4biwgcmVsYXRpb24sIHR5cGU6ICdBREQnIH0pXG4gICAgfSxcbiAgICBbY29sbGVjdGlvbnMsIGhhc011bHRpcGxlUmVsYXRpb25zLCBpMThuXSxcbiAgKVxuXG4gIGNvbnN0IGdldFJlc3VsdHMgPSB1c2VDYWxsYmFjazxHZXRSZXN1bHRzPihcbiAgICBhc3luYyAoe1xuICAgICAgbGFzdEZ1bGx5TG9hZGVkUmVsYXRpb246IGxhc3RGdWxseUxvYWRlZFJlbGF0aW9uQXJnLFxuICAgICAgbGFzdExvYWRlZFBhZ2U6IGxhc3RMb2FkZWRQYWdlQXJnLFxuICAgICAgc2VhcmNoOiBzZWFyY2hBcmcsXG4gICAgfSkgPT4ge1xuICAgICAgbGV0IGxhc3RMb2FkZWRQYWdlVG9Vc2UgPSB0eXBlb2YgbGFzdExvYWRlZFBhZ2VBcmcgIT09ICd1bmRlZmluZWQnID8gbGFzdExvYWRlZFBhZ2VBcmcgOiAxXG4gICAgICBjb25zdCBsYXN0RnVsbHlMb2FkZWRSZWxhdGlvblRvVXNlID1cbiAgICAgICAgdHlwZW9mIGxhc3RGdWxseUxvYWRlZFJlbGF0aW9uQXJnICE9PSAndW5kZWZpbmVkJyA/IGxhc3RGdWxseUxvYWRlZFJlbGF0aW9uQXJnIDogLTFcblxuICAgICAgY29uc3QgcmVsYXRpb25zID0gQXJyYXkuaXNBcnJheShyZWxhdGlvblRvKSA/IHJlbGF0aW9uVG8gOiBbcmVsYXRpb25Ub11cbiAgICAgIGNvbnN0IHJlbGF0aW9uc1RvRmV0Y2ggPVxuICAgICAgICBsYXN0RnVsbHlMb2FkZWRSZWxhdGlvblRvVXNlID09PSAtMVxuICAgICAgICAgID8gcmVsYXRpb25zXG4gICAgICAgICAgOiByZWxhdGlvbnMuc2xpY2UobGFzdEZ1bGx5TG9hZGVkUmVsYXRpb25Ub1VzZSArIDEpXG5cbiAgICAgIGxldCByZXN1bHRzRmV0Y2hlZCA9IDBcblxuICAgICAgaWYgKCFlcnJvckxvYWRpbmcpIHtcbiAgICAgICAgcmVsYXRpb25zVG9GZXRjaC5yZWR1Y2UoYXN5bmMgKHByaW9yUmVsYXRpb24sIHJlbGF0aW9uKSA9PiB7XG4gICAgICAgICAgYXdhaXQgcHJpb3JSZWxhdGlvblxuXG4gICAgICAgICAgaWYgKHJlc3VsdHNGZXRjaGVkIDwgMTApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9ucy5maW5kKChjb2xsKSA9PiBjb2xsLnNsdWcgPT09IHJlbGF0aW9uKVxuICAgICAgICAgICAgY29uc3QgZmllbGRUb1NlYXJjaCA9IGNvbGxlY3Rpb24/LmFkbWluPy51c2VBc1RpdGxlIHx8ICdpZCdcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtID0gc2VhcmNoQXJnID8gYCZ3aGVyZVske2ZpZWxkVG9TZWFyY2h9XVtsaWtlXT0ke3NlYXJjaEFyZ31gIDogJydcblxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgICAgICAgYCR7c2VydmVyVVJMfSR7YXBpfS8ke3JlbGF0aW9ufT9saW1pdD0ke21heFJlc3VsdHNQZXJSZXF1ZXN0fSZwYWdlPSR7bGFzdExvYWRlZFBhZ2VUb1VzZX0mZGVwdGg9MCR7c2VhcmNoUGFyYW19YCxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgJ0FjY2VwdC1MYW5ndWFnZSc6IGkxOG4ubGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGE6IFBhZ2luYXRlZERvY3MgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgICAgICAgaWYgKGRhdGEuZG9jcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c0ZldGNoZWQgKz0gZGF0YS5kb2NzLmxlbmd0aFxuICAgICAgICAgICAgICAgIGFkZE9wdGlvbnMoZGF0YSwgcmVsYXRpb24pXG4gICAgICAgICAgICAgICAgc2V0TGFzdExvYWRlZFBhZ2UoZGF0YS5wYWdlKVxuXG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLm5leHRQYWdlKSB7XG4gICAgICAgICAgICAgICAgICBzZXRMYXN0RnVsbHlMb2FkZWRSZWxhdGlvbihyZWxhdGlvbnMuaW5kZXhPZihyZWxhdGlvbikpXG5cbiAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBtb3JlIHJlbGF0aW9ucyB0byBzZWFyY2gsIG5lZWQgdG8gcmVzZXQgbGFzdExvYWRlZFBhZ2UgdG8gMVxuICAgICAgICAgICAgICAgICAgLy8gYm90aCBsb2NhbGx5IHdpdGhpbiBmdW5jdGlvbiBhbmQgc3RhdGVcbiAgICAgICAgICAgICAgICAgIGlmIChyZWxhdGlvbnMuaW5kZXhPZihyZWxhdGlvbikgKyAxIDwgcmVsYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsYXN0TG9hZGVkUGFnZVRvVXNlID0gMVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0RXJyb3JMb2FkaW5nKHQoJ2Vycm9yczp1bnNwZWNpZmljJykpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBQcm9taXNlLnJlc29sdmUoKSlcbiAgICAgIH1cbiAgICB9LFxuICAgIFtpMThuLCByZWxhdGlvblRvLCBlcnJvckxvYWRpbmcsIGNvbGxlY3Rpb25zLCBzZXJ2ZXJVUkwsIGFwaSwgYWRkT3B0aW9ucywgdF0sXG4gIClcblxuICBjb25zdCBmaW5kT3B0aW9uc0J5VmFsdWUgPSB1c2VDYWxsYmFjaygoKTogT3B0aW9uIHwgT3B0aW9uW10gPT4ge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgaWYgKGhhc01hbnkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAoaGFzTXVsdGlwbGVSZWxhdGlvbnMpIHtcbiAgICAgICAgICAgICAgbGV0IG1hdGNoZWRPcHRpb246IE9wdGlvblxuXG4gICAgICAgICAgICAgIG9wdGlvbnMuZm9yRWFjaCgob3B0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICBvcHQub3B0aW9ucy5zb21lKChzdWJPcHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1Yk9wdD8udmFsdWUgPT09IHZhbC52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRPcHRpb24gPSBzdWJPcHRcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlZE9wdGlvblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5maW5kKChvcHQpID0+IG9wdC52YWx1ZSA9PT0gdmFsKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNNdWx0aXBsZVJlbGF0aW9ucykge1xuICAgICAgICBsZXQgbWF0Y2hlZE9wdGlvbjogT3B0aW9uXG5cbiAgICAgICAgY29uc3QgdmFsdWVXaXRoUmVsYXRpb24gPSB2YWx1ZSBhcyBWYWx1ZVdpdGhSZWxhdGlvblxuXG4gICAgICAgIG9wdGlvbnMuZm9yRWFjaCgob3B0KSA9PiB7XG4gICAgICAgICAgaWYgKG9wdD8ub3B0aW9ucykge1xuICAgICAgICAgICAgb3B0Lm9wdGlvbnMuc29tZSgoc3ViT3B0KSA9PiB7XG4gICAgICAgICAgICAgIGlmIChzdWJPcHQ/LnZhbHVlID09PSB2YWx1ZVdpdGhSZWxhdGlvbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRPcHRpb24gPSBzdWJPcHRcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIG1hdGNoZWRPcHRpb25cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9wdGlvbnMuZmluZCgob3B0KSA9PiBvcHQudmFsdWUgPT09IHZhbHVlKVxuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfSwgW2hhc01hbnksIGhhc011bHRpcGxlUmVsYXRpb25zLCB2YWx1ZSwgb3B0aW9uc10pXG5cbiAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAgICAobmV3U2VhcmNoKSA9PiB7XG4gICAgICBpZiAoc2VhcmNoICE9PSBuZXdTZWFyY2gpIHtcbiAgICAgICAgc2V0U2VhcmNoKG5ld1NlYXJjaClcbiAgICAgIH1cbiAgICB9LFxuICAgIFtzZWFyY2hdLFxuICApXG5cbiAgY29uc3QgYWRkT3B0aW9uQnlJRCA9IHVzZUNhbGxiYWNrKFxuICAgIGFzeW5jIChpZCwgcmVsYXRpb24pID0+IHtcbiAgICAgIGlmICghZXJyb3JMb2FkaW5nICYmIGlkICE9PSAnbnVsbCcpIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtzZXJ2ZXJVUkx9JHthcGl9LyR7cmVsYXRpb259LyR7aWR9P2RlcHRoPTBgLCB7XG4gICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzogaTE4bi5sYW5ndWFnZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgICAgICBhZGRPcHRpb25zKHsgZG9jczogW2RhdGFdIH0sIHJlbGF0aW9uKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IodCgnZXJyb3I6bG9hZGluZ0RvY3VtZW50JywgeyBpZCB9KSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW2kxOG4sIGFkZE9wdGlvbnMsIGFwaSwgZXJyb3JMb2FkaW5nLCBzZXJ2ZXJVUkwsIHRdLFxuICApXG5cbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIEdldCByZXN1bHRzIHdoZW4gc2VhcmNoIGlucHV0IGNoYW5nZXNcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBkaXNwYXRjaE9wdGlvbnMoe1xuICAgICAgaTE4bixcbiAgICAgIHJlcXVpcmVkOiB0cnVlLFxuICAgICAgdHlwZTogJ0NMRUFSJyxcbiAgICB9KVxuXG4gICAgc2V0SGFzTG9hZGVkRmlyc3RPcHRpb25zKHRydWUpXG4gICAgc2V0TGFzdExvYWRlZFBhZ2UoMSlcbiAgICBzZXRMYXN0RnVsbHlMb2FkZWRSZWxhdGlvbigtMSlcbiAgICBnZXRSZXN1bHRzKHsgc2VhcmNoOiBkZWJvdW5jZWRTZWFyY2ggfSlcbiAgfSwgW2dldFJlc3VsdHMsIGRlYm91bmNlZFNlYXJjaCwgcmVsYXRpb25UbywgaTE4bl0pXG5cbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vIEZvcm1hdCBvcHRpb25zIG9uY2UgZmlyc3Qgb3B0aW9ucyBoYXZlIGJlZW4gcmV0cmlldmVkXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHZhbHVlICYmIGhhc0xvYWRlZEZpcnN0T3B0aW9ucykge1xuICAgICAgaWYgKGhhc01hbnkpIHtcbiAgICAgICAgY29uc3QgbWF0Y2hlZE9wdGlvbnMgPSBmaW5kT3B0aW9uc0J5VmFsdWUoKVxuXG4gICAgICAgIDsoKG1hdGNoZWRPcHRpb25zIGFzIE9wdGlvbltdKSB8fCBbXSkuZm9yRWFjaCgob3B0aW9uLCBpKSA9PiB7XG4gICAgICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgICAgIGlmIChoYXNNdWx0aXBsZVJlbGF0aW9ucykge1xuICAgICAgICAgICAgICBhZGRPcHRpb25CeUlEKHZhbHVlW2ldLnZhbHVlLCB2YWx1ZVtpXS5yZWxhdGlvblRvKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRkT3B0aW9uQnlJRCh2YWx1ZVtpXSwgcmVsYXRpb25UbylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBtYXRjaGVkT3B0aW9uID0gZmluZE9wdGlvbnNCeVZhbHVlKClcblxuICAgICAgICBpZiAoIW1hdGNoZWRPcHRpb24pIHtcbiAgICAgICAgICBpZiAoaGFzTXVsdGlwbGVSZWxhdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlV2l0aFJlbGF0aW9uID0gdmFsdWUgYXMgVmFsdWVXaXRoUmVsYXRpb25cbiAgICAgICAgICAgIGFkZE9wdGlvbkJ5SUQodmFsdWVXaXRoUmVsYXRpb24udmFsdWUsIHZhbHVlV2l0aFJlbGF0aW9uLnJlbGF0aW9uVG8pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFkZE9wdGlvbkJ5SUQodmFsdWUsIHJlbGF0aW9uVG8pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCBbXG4gICAgYWRkT3B0aW9uQnlJRCxcbiAgICBmaW5kT3B0aW9uc0J5VmFsdWUsXG4gICAgaGFzTWFueSxcbiAgICBoYXNNdWx0aXBsZVJlbGF0aW9ucyxcbiAgICByZWxhdGlvblRvLFxuICAgIHZhbHVlLFxuICAgIGhhc0xvYWRlZEZpcnN0T3B0aW9ucyxcbiAgXSlcblxuICBjb25zdCBjbGFzc2VzID0gWydmaWVsZC10eXBlJywgYmFzZUNsYXNzLCBlcnJvckxvYWRpbmcgJiYgJ2Vycm9yLWxvYWRpbmcnXVxuICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAuam9pbignICcpXG5cbiAgY29uc3QgdmFsdWVUb1JlbmRlciA9IChmaW5kT3B0aW9uc0J5VmFsdWUoKSB8fCB2YWx1ZSkgYXMgT3B0aW9uXG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlc30+XG4gICAgICB7IWVycm9yTG9hZGluZyAmJiAoXG4gICAgICAgIDxSZWFjdFNlbGVjdFxuICAgICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgICBpc011bHRpPXtoYXNNYW55fVxuICAgICAgICAgIGlzU29ydGFibGU9e2lzU29ydGFibGV9XG4gICAgICAgICAgb25DaGFuZ2U9eyhzZWxlY3RlZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGhhc01hbnkpIHtcbiAgICAgICAgICAgICAgb25DaGFuZ2UoXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICAgID8gc2VsZWN0ZWQubWFwKChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzTXVsdGlwbGVSZWxhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aW9uVG86IG9wdGlvbi5yZWxhdGlvblRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb3B0aW9uLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb24udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNNdWx0aXBsZVJlbGF0aW9ucykge1xuICAgICAgICAgICAgICBvbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgcmVsYXRpb25Ubzogc2VsZWN0ZWQucmVsYXRpb25UbyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc2VsZWN0ZWQudmFsdWUsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvbkNoYW5nZShzZWxlY3RlZC52YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9fVxuICAgICAgICAgIG9uSW5wdXRDaGFuZ2U9e2hhbmRsZUlucHV0Q2hhbmdlfVxuICAgICAgICAgIG9uTWVudVNjcm9sbFRvQm90dG9tPXsoKSA9PiB7XG4gICAgICAgICAgICBnZXRSZXN1bHRzKHsgbGFzdEZ1bGx5TG9hZGVkUmVsYXRpb24sIGxhc3RMb2FkZWRQYWdlOiBsYXN0TG9hZGVkUGFnZSArIDEgfSlcbiAgICAgICAgICB9fVxuICAgICAgICAgIG9wdGlvbnM9e29wdGlvbnN9XG4gICAgICAgICAgcGxhY2Vob2xkZXI9e3QoJ3NlbGVjdFZhbHVlJyl9XG4gICAgICAgICAgdmFsdWU9e3ZhbHVlVG9SZW5kZXJ9XG4gICAgICAgIC8+XG4gICAgICApfVxuICAgICAge2Vycm9yTG9hZGluZyAmJiA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fZXJyb3ItbG9hZGluZ2B9PntlcnJvckxvYWRpbmd9PC9kaXY+fVxuICAgIDwvZGl2PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IFJlbGF0aW9uc2hpcEZpZWxkXG4iXSwibmFtZXMiOlsiYmFzZUNsYXNzIiwibWF4UmVzdWx0c1BlclJlcXVlc3QiLCJSZWxhdGlvbnNoaXBGaWVsZCIsInByb3BzIiwiYWRtaW4iLCJpc1NvcnRhYmxlIiwiZGlzYWJsZWQiLCJoYXNNYW55Iiwib25DaGFuZ2UiLCJyZWxhdGlvblRvIiwidmFsdWUiLCJjb2xsZWN0aW9ucyIsInJvdXRlcyIsImFwaSIsInNlcnZlclVSTCIsInVzZUNvbmZpZyIsImhhc011bHRpcGxlUmVsYXRpb25zIiwiQXJyYXkiLCJpc0FycmF5Iiwib3B0aW9ucyIsImRpc3BhdGNoT3B0aW9ucyIsInVzZVJlZHVjZXIiLCJvcHRpb25zUmVkdWNlciIsImxhc3RGdWxseUxvYWRlZFJlbGF0aW9uIiwic2V0TGFzdEZ1bGx5TG9hZGVkUmVsYXRpb24iLCJ1c2VTdGF0ZSIsImxhc3RMb2FkZWRQYWdlIiwic2V0TGFzdExvYWRlZFBhZ2UiLCJzZWFyY2giLCJzZXRTZWFyY2giLCJlcnJvckxvYWRpbmciLCJzZXRFcnJvckxvYWRpbmciLCJoYXNMb2FkZWRGaXJzdE9wdGlvbnMiLCJzZXRIYXNMb2FkZWRGaXJzdE9wdGlvbnMiLCJkZWJvdW5jZWRTZWFyY2giLCJ1c2VEZWJvdW5jZSIsImkxOG4iLCJ0IiwidXNlVHJhbnNsYXRpb24iLCJhZGRPcHRpb25zIiwidXNlQ2FsbGJhY2siLCJkYXRhIiwicmVsYXRpb24iLCJjb2xsZWN0aW9uIiwiZmluZCIsImNvbGwiLCJzbHVnIiwidHlwZSIsImdldFJlc3VsdHMiLCJsYXN0RnVsbHlMb2FkZWRSZWxhdGlvbkFyZyIsImxhc3RMb2FkZWRQYWdlQXJnIiwic2VhcmNoQXJnIiwibGFzdExvYWRlZFBhZ2VUb1VzZSIsImxhc3RGdWxseUxvYWRlZFJlbGF0aW9uVG9Vc2UiLCJyZWxhdGlvbnMiLCJyZWxhdGlvbnNUb0ZldGNoIiwic2xpY2UiLCJyZXN1bHRzRmV0Y2hlZCIsInJlZHVjZSIsInByaW9yUmVsYXRpb24iLCJmaWVsZFRvU2VhcmNoIiwidXNlQXNUaXRsZSIsInNlYXJjaFBhcmFtIiwicmVzcG9uc2UiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsImxhbmd1YWdlIiwib2siLCJqc29uIiwiZG9jcyIsImxlbmd0aCIsInBhZ2UiLCJuZXh0UGFnZSIsImluZGV4T2YiLCJQcm9taXNlIiwicmVzb2x2ZSIsImZpbmRPcHRpb25zQnlWYWx1ZSIsIm1hcCIsInZhbCIsIm1hdGNoZWRPcHRpb24iLCJmb3JFYWNoIiwib3B0Iiwic29tZSIsInN1Yk9wdCIsInVuZGVmaW5lZCIsInZhbHVlV2l0aFJlbGF0aW9uIiwiaGFuZGxlSW5wdXRDaGFuZ2UiLCJuZXdTZWFyY2giLCJhZGRPcHRpb25CeUlEIiwiaWQiLCJjb25zb2xlIiwiZXJyb3IiLCJ1c2VFZmZlY3QiLCJyZXF1aXJlZCIsIm1hdGNoZWRPcHRpb25zIiwib3B0aW9uIiwiaSIsImNsYXNzZXMiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsInZhbHVlVG9SZW5kZXIiLCJkaXYiLCJjbGFzc05hbWUiLCJSZWFjdFNlbGVjdCIsImlzTXVsdGkiLCJzZWxlY3RlZCIsIm9uSW5wdXRDaGFuZ2UiLCJvbk1lbnVTY3JvbGxUb0JvdHRvbSIsInBsYWNlaG9sZGVyIl0sIm1hcHBpbmdzIjoiOzs7OytCQWlUQTs7O2VBQUE7OzsrREFqVG9FOzhCQUNyQztvRUFNUDt3QkFDRTtvRUFDRjtRQUNqQjt1RUFDb0I7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUUzQixNQUFNQSxZQUFZO0FBRWxCLE1BQU1DLHVCQUF1QjtBQUU3QixNQUFNQyxvQkFBcUMsQ0FBQ0M7SUFDMUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLFVBQVUsRUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFQyxRQUFRLEVBQUVDLE9BQU8sRUFBRUMsUUFBUSxFQUFFQyxVQUFVLEVBQUVDLEtBQUssRUFBRSxHQUFHUDtJQUV2RixNQUFNLEVBQ0pRLFdBQVcsRUFDWEMsUUFBUSxFQUFFQyxHQUFHLEVBQUUsRUFDZkMsU0FBUyxFQUNWLEdBQUdDLElBQUFBLGlCQUFTO0lBRWIsTUFBTUMsdUJBQXVCQyxNQUFNQyxPQUFPLENBQUNUO0lB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