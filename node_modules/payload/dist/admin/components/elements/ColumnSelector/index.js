"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _getTranslation = require("../../../../utilities/getTranslation");
const _Plus = /*#__PURE__*/ _interop_require_default(require("../../icons/Plus"));
const _X = /*#__PURE__*/ _interop_require_default(require("../../icons/X"));
const _EditDepth = require("../../utilities/EditDepth");
const _DraggableSortable = /*#__PURE__*/ _interop_require_default(require("../DraggableSortable"));
const _Pill = /*#__PURE__*/ _interop_require_default(require("../Pill"));
const _TableColumns = require("../TableColumns");
require("./index.scss");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'column-selector';
const ColumnSelector = (props)=>{
    const { collection } = props;
    const { columns, moveColumn, toggleColumn } = (0, _TableColumns.useTableColumns)();
    const { i18n } = (0, _reacti18next.useTranslation)();
    const uuid = (0, _react.useId)();
    const editDepth = (0, _EditDepth.useEditDepth)();
    if (!columns) {
        return null;
    }
    return /*#__PURE__*/ _react.default.createElement(_DraggableSortable.default, {
        className: baseClass,
        ids: columns.map((col)=>col.accessor),
        onDragEnd: ({ moveFromIndex, moveToIndex })=>{
            moveColumn({
                fromIndex: moveFromIndex,
                toIndex: moveToIndex
            });
        }
    }, columns.map((col, i)=>{
        const { name, accessor, active, label } = col;
        if (col.accessor === '_select') return null;
        return /*#__PURE__*/ _react.default.createElement(_Pill.default, {
            alignIcon: "left",
            "aria-checked": active,
            className: [
                `${baseClass}__column`,
                active && `${baseClass}__column--active`
            ].filter(Boolean).join(' '),
            draggable: true,
            icon: active ? /*#__PURE__*/ _react.default.createElement(_X.default, null) : /*#__PURE__*/ _react.default.createElement(_Plus.default, null),
            id: accessor,
            key: `${collection.slug}-${col.name || i}${editDepth ? `-${editDepth}-` : ''}${uuid}`,
            onClick: ()=>{
                toggleColumn(accessor);
            }
        }, (0, _getTranslation.getTranslation)(label || name, i18n));
    }));
};
const _default = ColumnSelector;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2VsZW1lbnRzL0NvbHVtblNlbGVjdG9yL2luZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlSWQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVRyYW5zbGF0aW9uIH0gZnJvbSAncmVhY3QtaTE4bmV4dCdcblxuaW1wb3J0IHR5cGUgeyBQcm9wcyB9IGZyb20gJy4vdHlwZXMnXG5cbmltcG9ydCB7IGdldFRyYW5zbGF0aW9uIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbGl0aWVzL2dldFRyYW5zbGF0aW9uJ1xuaW1wb3J0IFBsdXMgZnJvbSAnLi4vLi4vaWNvbnMvUGx1cydcbmltcG9ydCBYIGZyb20gJy4uLy4uL2ljb25zL1gnXG5pbXBvcnQgeyB1c2VFZGl0RGVwdGggfSBmcm9tICcuLi8uLi91dGlsaXRpZXMvRWRpdERlcHRoJ1xuaW1wb3J0IERyYWdnYWJsZVNvcnRhYmxlIGZyb20gJy4uL0RyYWdnYWJsZVNvcnRhYmxlJ1xuaW1wb3J0IFBpbGwgZnJvbSAnLi4vUGlsbCdcbmltcG9ydCB7IHVzZVRhYmxlQ29sdW1ucyB9IGZyb20gJy4uL1RhYmxlQ29sdW1ucydcbmltcG9ydCAnLi9pbmRleC5zY3NzJ1xuXG5jb25zdCBiYXNlQ2xhc3MgPSAnY29sdW1uLXNlbGVjdG9yJ1xuXG5jb25zdCBDb2x1bW5TZWxlY3RvcjogUmVhY3QuRkM8UHJvcHM+ID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHsgY29sbGVjdGlvbiB9ID0gcHJvcHNcblxuICBjb25zdCB7IGNvbHVtbnMsIG1vdmVDb2x1bW4sIHRvZ2dsZUNvbHVtbiB9ID0gdXNlVGFibGVDb2x1bW5zKClcblxuICBjb25zdCB7IGkxOG4gfSA9IHVzZVRyYW5zbGF0aW9uKClcbiAgY29uc3QgdXVpZCA9IHVzZUlkKClcbiAgY29uc3QgZWRpdERlcHRoID0gdXNlRWRpdERlcHRoKClcblxuICBpZiAoIWNvbHVtbnMpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8RHJhZ2dhYmxlU29ydGFibGVcbiAgICAgIGNsYXNzTmFtZT17YmFzZUNsYXNzfVxuICAgICAgaWRzPXtjb2x1bW5zLm1hcCgoY29sKSA9PiBjb2wuYWNjZXNzb3IpfVxuICAgICAgb25EcmFnRW5kPXsoeyBtb3ZlRnJvbUluZGV4LCBtb3ZlVG9JbmRleCB9KSA9PiB7XG4gICAgICAgIG1vdmVDb2x1bW4oe1xuICAgICAgICAgIGZyb21JbmRleDogbW92ZUZyb21JbmRleCxcbiAgICAgICAgICB0b0luZGV4OiBtb3ZlVG9JbmRleCxcbiAgICAgICAgfSlcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NvbHVtbnMubWFwKChjb2wsIGkpID0+IHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBhY2Nlc3NvciwgYWN0aXZlLCBsYWJlbCB9ID0gY29sXG5cbiAgICAgICAgaWYgKGNvbC5hY2Nlc3NvciA9PT0gJ19zZWxlY3QnKSByZXR1cm4gbnVsbFxuXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgPFBpbGxcbiAgICAgICAgICAgIGFsaWduSWNvbj1cImxlZnRcIlxuICAgICAgICAgICAgYXJpYS1jaGVja2VkPXthY3RpdmV9XG4gICAgICAgICAgICBjbGFzc05hbWU9e1tgJHtiYXNlQ2xhc3N9X19jb2x1bW5gLCBhY3RpdmUgJiYgYCR7YmFzZUNsYXNzfV9fY29sdW1uLS1hY3RpdmVgXVxuICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAgIC5qb2luKCcgJyl9XG4gICAgICAgICAgICBkcmFnZ2FibGVcbiAgICAgICAgICAgIGljb249e2FjdGl2ZSA/IDxYIC8+IDogPFBsdXMgLz59XG4gICAgICAgICAgICBpZD17YWNjZXNzb3J9XG4gICAgICAgICAgICBrZXk9e2Ake2NvbGxlY3Rpb24uc2x1Z30tJHtjb2wubmFtZSB8fCBpfSR7ZWRpdERlcHRoID8gYC0ke2VkaXREZXB0aH0tYCA6ICcnfSR7dXVpZH1gfVxuICAgICAgICAgICAgb25DbGljaz17KCkgPT4ge1xuICAgICAgICAgICAgICB0b2dnbGVDb2x1bW4oYWNjZXNzb3IpXG4gICAgICAgICAgICB9fVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtnZXRUcmFuc2xhdGlvbihsYWJlbCB8fCBuYW1lLCBpMThuKX1cbiAgICAgICAgICA8L1BpbGw+XG4gICAgICAgIClcbiAgICAgIH0pfVxuICAgIDwvRHJhZ2dhYmxlU29ydGFibGU+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29sdW1uU2VsZWN0b3JcbiJdLCJuYW1lcyI6WyJiYXNlQ2xhc3MiLCJDb2x1bW5TZWxlY3RvciIsInByb3BzIiwiY29sbGVjdGlvbiIsImNvbHVtbnMiLCJtb3ZlQ29sdW1uIiwidG9nZ2xlQ29sdW1uIiwidXNlVGFibGVDb2x1bW5zIiwiaTE4biIsInVzZVRyYW5zbGF0aW9uIiwidXVpZCIsInVzZUlkIiwiZWRpdERlcHRoIiwidXNlRWRpdERlcHRoIiwiRHJhZ2dhYmxlU29ydGFibGUiLCJjbGFzc05hbWUiLCJpZHMiLCJtYXAiLCJjb2wiLCJhY2Nlc3NvciIsIm9uRHJhZ0VuZCIsIm1vdmVGcm9tSW5kZXgiLCJtb3ZlVG9JbmRleCIsImZyb21JbmRleCIsInRvSW5kZXgiLCJpIiwibmFtZSIsImFjdGl2ZSIsImxhYmVsIiwiUGlsbCIsImFsaWduSWNvbiIsImFyaWEtY2hlY2tlZCIsImZpbHRlciIsIkJvb2xlYW4iLCJqb2luIiwiZHJhZ2dhYmxlIiwiaWNvbiIsIlgiLCJQbHVzIiwiaWQiLCJrZXkiLCJzbHVnIiwib25DbGljayIsImdldFRyYW5zbGF0aW9uIl0sIm1hcHBpbmdzIjoiOzs7OytCQW9FQTs7O2VBQUE7OzsrREFwRTZCOzhCQUNFO2dDQUlBOzZEQUNkOzBEQUNIOzJCQUNlOzBFQUNDOzZEQUNiOzhCQUNlO1FBQ3pCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFUCxNQUFNQSxZQUFZO0FBRWxCLE1BQU1DLGlCQUFrQyxDQUFDQztJQUN2QyxNQUFNLEVBQUVDLFVBQVUsRUFBRSxHQUFHRDtJQUV2QixNQUFNLEVBQUVFLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxZQUFZLEVBQUUsR0FBR0MsSUFBQUEsNkJBQWU7SUFFN0QsTUFBTSxFQUFFQyxJQUFJLEVBQUUsR0FBR0MsSUFBQUEsNEJBQWM7SUFDL0IsTUFBTUMsT0FBT0MsSUFBQUEsWUFBSztJQUNsQixNQUFNQyxZQUFZQyxJQUFBQSx1QkFBWTtJQUU5QixJQUFJLENBQUNULFNBQVM7UUFDWixPQUFPO0lBQ1Q7SUFFQSxxQkFDRSw2QkFBQ1UsMEJBQWlCO1FBQ2hCQyxXQUFXZjtRQUNYZ0IsS0FBS1osUUFBUWEsR0FBRyxDQUFDLENBQUNDLE1BQVFBLElBQUlDLFFBQVE7UUFDdENDLFdBQVcsQ0FBQyxFQUFFQyxhQUFhLEVBQUVDLFdBQVcsRUFBRTtZQUN4Q2pCLFdBQVc7Z0JBQ1RrQixXQUFXRjtnQkFDWEcsU0FBU0Y7WUFDWDtRQUNGO09BRUNsQixRQUFRYSxHQUFHLENBQUMsQ0FBQ0MsS0FBS087UUFDakIsTUFBTSxFQUFFQyxJQUFJLEVBQUVQLFFBQVEsRUFBRVEsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBR1Y7UUFFMUMsSUFBSUEsSUFBSUMsUUFBUSxLQUFLLFdBQVcsT0FBTztRQUV2QyxxQkFDRSw2QkFBQ1UsYUFBSTtZQUNIQyxXQUFVO1lBQ1ZDLGdCQUFjSjtZQUNkWixXQUFXO2dCQUFDLENBQUMsRUFBRWYsVUFBVSxRQUFRLENBQUM7Z0JBQUUyQixVQUFVLENBQUMsRUFBRTNCLFVBQVUsZ0JBQWdCLENBQUM7YUFBQyxDQUMxRWdDLE1BQU0sQ0FBQ0MsU0FDUEMsSUFBSSxDQUFDO1lBQ1JDLFdBQUFBO1lBQ0FDLE1BQU1ULHVCQUFTLDZCQUFDVSxVQUFDLHdCQUFNLDZCQUFDQyxhQUFJO1lBQzVCQyxJQUFJcEI7WUFDSnFCLEtBQUssQ0FBQyxFQUFFckMsV0FBV3NDLElBQUksQ0FBQyxDQUFDLEVBQUV2QixJQUFJUSxJQUFJLElBQUlELEVBQUUsRUFBRWIsWUFBWSxDQUFDLENBQUMsRUFBRUEsVUFBVSxDQUFDLENBQUMsR0FBRyxHQUFHLEVBQUVGLEtBQUssQ0FBQztZQUNyRmdDLFNBQVM7Z0JBQ1BwQyxhQUFhYTtZQUNmO1dBRUN3QixJQUFBQSw4QkFBYyxFQUFDZixTQUFTRixNQUFNbEI7SUFHckM7QUFHTjtNQUVBLFdBQWVQIn0=