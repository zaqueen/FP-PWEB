"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    TableColumnContext: function() {
        return TableColumnContext;
    },
    useTableColumns: function() {
        return useTableColumns;
    },
    TableColumnsProvider: function() {
        return TableColumnsProvider;
    }
});
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _Preferences = require("../../utilities/Preferences");
const _formatFields = /*#__PURE__*/ _interop_require_default(require("../../views/collections/List/formatFields"));
const _buildColumns = /*#__PURE__*/ _interop_require_default(require("./buildColumns"));
const _columnReducer = require("./columnReducer");
const _getInitialColumns = /*#__PURE__*/ _interop_require_default(require("./getInitialColumns"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const TableColumnContext = /*#__PURE__*/ (0, _react.createContext)({});
const useTableColumns = ()=>(0, _react.useContext)(TableColumnContext);
const TableColumnsProvider = ({ cellProps, children, collection: { admin: { defaultColumns, useAsTitle } }, collection })=>{
    const preferenceKey = `${collection.slug}-list`;
    const prevCollection = (0, _react.useRef)();
    const hasInitialized = (0, _react.useRef)(false);
    const { getPreference, setPreference } = (0, _Preferences.usePreferences)();
    const [formattedFields] = (0, _react.useState)(()=>(0, _formatFields.default)(collection));
    const [tableColumns, dispatchTableColumns] = (0, _react.useReducer)(_columnReducer.columnReducer, {}, ()=>{
        const initialColumns = (0, _getInitialColumns.default)(formattedFields, useAsTitle, defaultColumns);
        return (0, _buildColumns.default)({
            cellProps,
            collection,
            columns: initialColumns.map((column)=>({
                    accessor: column,
                    active: true
                }))
        });
    });
    // /////////////////////////////////////
    // Sync preferences on collection change
    // /////////////////////////////////////
    (0, _react.useEffect)(()=>{
        const sync = async ()=>{
            const collectionHasChanged = prevCollection.current !== collection.slug;
            if (collectionHasChanged) {
                hasInitialized.current = false;
                const currentPreferences = await getPreference(preferenceKey);
                prevCollection.current = collection.slug;
                const initialColumns = (0, _getInitialColumns.default)(formattedFields, useAsTitle, defaultColumns);
                const newCols = currentPreferences?.columns || initialColumns;
                dispatchTableColumns({
                    payload: {
                        cellProps,
                        collection: {
                            ...collection,
                            fields: (0, _formatFields.default)(collection)
                        },
                        columns: newCols.map((column)=>{
                            // 'string' is for backwards compatibility
                            // the preference used to be stored as an array of strings
                            if (typeof column === 'string') {
                                return {
                                    accessor: column,
                                    active: true
                                };
                            }
                            return column;
                        })
                    },
                    type: 'set'
                });
                hasInitialized.current = true;
            }
        };
        sync();
    }, [
        preferenceKey,
        setPreference,
        tableColumns,
        getPreference,
        useAsTitle,
        defaultColumns,
        collection,
        cellProps,
        formattedFields
    ]);
    // /////////////////////////////////////
    // Set preferences on column change
    // /////////////////////////////////////
    (0, _react.useEffect)(()=>{
        if (!hasInitialized.current) return;
        const columns = tableColumns.map((c)=>({
                accessor: c.accessor,
                active: c.active
            }));
        void setPreference(preferenceKey, {
            columns
        }, true);
    }, [
        tableColumns,
        preferenceKey,
        setPreference,
        getPreference
    ]);
    const setActiveColumns = (0, _react.useCallback)((columns)=>{
        dispatchTableColumns({
            payload: {
                // onSelect,
                cellProps,
                collection: {
                    ...collection,
                    fields: (0, _formatFields.default)(collection)
                },
                columns: columns.map((column)=>({
                        accessor: column,
                        active: true
                    }))
            },
            type: 'set'
        });
    }, [
        collection,
        cellProps
    ]);
    const moveColumn = (0, _react.useCallback)((args)=>{
        const { fromIndex, toIndex } = args;
        dispatchTableColumns({
            payload: {
                cellProps,
                collection: {
                    ...collection,
                    fields: (0, _formatFields.default)(collection)
                },
                fromIndex,
                toIndex
            },
            type: 'move'
        });
    }, [
        collection,
        cellProps
    ]);
    const toggleColumn = (0, _react.useCallback)((column)=>{
        dispatchTableColumns({
            payload: {
                cellProps,
                collection: {
                    ...collection,
                    fields: (0, _formatFields.default)(collection)
                },
                column
            },
            type: 'toggle'
        });
    }, [
        collection,
        cellProps
    ]);
    return /*#__PURE__*/ _react.default.createElement(TableColumnContext.Provider, {
        value: {
            columns: tableColumns,
            dispatchTableColumns,
            moveColumn,
            setActiveColumns,
            toggleColumn
        }
    }, children);
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL2VsZW1lbnRzL1RhYmxlQ29sdW1ucy9pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7XG4gIGNyZWF0ZUNvbnRleHQsXG4gIHVzZUNhbGxiYWNrLFxuICB1c2VDb250ZXh0LFxuICB1c2VFZmZlY3QsXG4gIHVzZVJlZHVjZXIsXG4gIHVzZVJlZixcbiAgdXNlU3RhdGUsXG59IGZyb20gJ3JlYWN0J1xuXG5pbXBvcnQgdHlwZSB7IFNhbml0aXplZENvbGxlY3Rpb25Db25maWcgfSBmcm9tICcuLi8uLi8uLi8uLi9jb2xsZWN0aW9ucy9jb25maWcvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEZpZWxkIH0gZnJvbSAnLi4vLi4vLi4vLi4vZmllbGRzL2NvbmZpZy90eXBlcydcbmltcG9ydCB0eXBlIHsgUHJvcHMgYXMgQ2VsbFByb3BzIH0gZnJvbSAnLi4vLi4vdmlld3MvY29sbGVjdGlvbnMvTGlzdC9DZWxsL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBMaXN0UHJlZmVyZW5jZXMgfSBmcm9tICcuLi8uLi92aWV3cy9jb2xsZWN0aW9ucy9MaXN0L3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBDb2x1bW4gfSBmcm9tICcuLi9UYWJsZS90eXBlcydcbmltcG9ydCB0eXBlIHsgQWN0aW9uIH0gZnJvbSAnLi9jb2x1bW5SZWR1Y2VyJ1xuXG5pbXBvcnQgeyB1c2VQcmVmZXJlbmNlcyB9IGZyb20gJy4uLy4uL3V0aWxpdGllcy9QcmVmZXJlbmNlcydcbmltcG9ydCBmb3JtYXRGaWVsZHMgZnJvbSAnLi4vLi4vdmlld3MvY29sbGVjdGlvbnMvTGlzdC9mb3JtYXRGaWVsZHMnXG5pbXBvcnQgYnVpbGRDb2x1bW5zIGZyb20gJy4vYnVpbGRDb2x1bW5zJ1xuaW1wb3J0IHsgY29sdW1uUmVkdWNlciB9IGZyb20gJy4vY29sdW1uUmVkdWNlcidcbmltcG9ydCBnZXRJbml0aWFsQ29sdW1uU3RhdGUgZnJvbSAnLi9nZXRJbml0aWFsQ29sdW1ucydcblxuZXhwb3J0IGludGVyZmFjZSBJVGFibGVDb2x1bW5zIHtcbiAgY29sdW1uczogQ29sdW1uW11cbiAgZGlzcGF0Y2hUYWJsZUNvbHVtbnM6IFJlYWN0LkRpc3BhdGNoPEFjdGlvbj5cbiAgbW92ZUNvbHVtbjogKGFyZ3M6IHsgZnJvbUluZGV4OiBudW1iZXI7IHRvSW5kZXg6IG51bWJlciB9KSA9PiB2b2lkXG4gIHNldEFjdGl2ZUNvbHVtbnM6IChjb2x1bW5zOiBzdHJpbmdbXSkgPT4gdm9pZFxuICB0b2dnbGVDb2x1bW46IChjb2x1bW46IHN0cmluZykgPT4gdm9pZFxufVxuXG5leHBvcnQgY29uc3QgVGFibGVDb2x1bW5Db250ZXh0ID0gY3JlYXRlQ29udGV4dDxJVGFibGVDb2x1bW5zPih7fSBhcyBJVGFibGVDb2x1bW5zKVxuXG5leHBvcnQgY29uc3QgdXNlVGFibGVDb2x1bW5zID0gKCk6IElUYWJsZUNvbHVtbnMgPT4gdXNlQ29udGV4dChUYWJsZUNvbHVtbkNvbnRleHQpXG5cbmV4cG9ydCBjb25zdCBUYWJsZUNvbHVtbnNQcm92aWRlcjogUmVhY3QuRkM8e1xuICBjZWxsUHJvcHM/OiBQYXJ0aWFsPENlbGxQcm9wcz5bXVxuICBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlXG4gIGNvbGxlY3Rpb246IFNhbml0aXplZENvbGxlY3Rpb25Db25maWdcbn0+ID0gKHtcbiAgY2VsbFByb3BzLFxuICBjaGlsZHJlbixcbiAgY29sbGVjdGlvbjoge1xuICAgIGFkbWluOiB7IGRlZmF1bHRDb2x1bW5zLCB1c2VBc1RpdGxlIH0sXG4gIH0sXG4gIGNvbGxlY3Rpb24sXG59KSA9PiB7XG4gIGNvbnN0IHByZWZlcmVuY2VLZXkgPSBgJHtjb2xsZWN0aW9uLnNsdWd9LWxpc3RgXG4gIGNvbnN0IHByZXZDb2xsZWN0aW9uID0gdXNlUmVmPFNhbml0aXplZENvbGxlY3Rpb25Db25maWdbJ3NsdWcnXT4oKVxuICBjb25zdCBoYXNJbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSlcbiAgY29uc3QgeyBnZXRQcmVmZXJlbmNlLCBzZXRQcmVmZXJlbmNlIH0gPSB1c2VQcmVmZXJlbmNlcygpXG4gIGNvbnN0IFtmb3JtYXR0ZWRGaWVsZHNdID0gdXNlU3RhdGU8RmllbGRbXT4oKCkgPT4gZm9ybWF0RmllbGRzKGNvbGxlY3Rpb24pKVxuXG4gIGNvbnN0IFt0YWJsZUNvbHVtbnMsIGRpc3BhdGNoVGFibGVDb2x1bW5zXSA9IHVzZVJlZHVjZXIoY29sdW1uUmVkdWNlciwge30sICgpID0+IHtcbiAgICBjb25zdCBpbml0aWFsQ29sdW1ucyA9IGdldEluaXRpYWxDb2x1bW5TdGF0ZShmb3JtYXR0ZWRGaWVsZHMsIHVzZUFzVGl0bGUsIGRlZmF1bHRDb2x1bW5zKVxuXG4gICAgcmV0dXJuIGJ1aWxkQ29sdW1ucyh7XG4gICAgICBjZWxsUHJvcHMsXG4gICAgICBjb2xsZWN0aW9uLFxuICAgICAgY29sdW1uczogaW5pdGlhbENvbHVtbnMubWFwKChjb2x1bW4pID0+ICh7XG4gICAgICAgIGFjY2Vzc29yOiBjb2x1bW4sXG4gICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgIH0pKSxcbiAgICB9KVxuICB9KVxuXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gU3luYyBwcmVmZXJlbmNlcyBvbiBjb2xsZWN0aW9uIGNoYW5nZVxuICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBzeW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgY29sbGVjdGlvbkhhc0NoYW5nZWQgPSBwcmV2Q29sbGVjdGlvbi5jdXJyZW50ICE9PSBjb2xsZWN0aW9uLnNsdWdcblxuICAgICAgaWYgKGNvbGxlY3Rpb25IYXNDaGFuZ2VkKSB7XG4gICAgICAgIGhhc0luaXRpYWxpemVkLmN1cnJlbnQgPSBmYWxzZVxuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcmVmZXJlbmNlcyA9IGF3YWl0IGdldFByZWZlcmVuY2U8TGlzdFByZWZlcmVuY2VzPihwcmVmZXJlbmNlS2V5KVxuICAgICAgICBwcmV2Q29sbGVjdGlvbi5jdXJyZW50ID0gY29sbGVjdGlvbi5zbHVnXG4gICAgICAgIGNvbnN0IGluaXRpYWxDb2x1bW5zID0gZ2V0SW5pdGlhbENvbHVtblN0YXRlKGZvcm1hdHRlZEZpZWxkcywgdXNlQXNUaXRsZSwgZGVmYXVsdENvbHVtbnMpXG4gICAgICAgIGNvbnN0IG5ld0NvbHMgPSBjdXJyZW50UHJlZmVyZW5jZXM/LmNvbHVtbnMgfHwgaW5pdGlhbENvbHVtbnNcblxuICAgICAgICBkaXNwYXRjaFRhYmxlQ29sdW1ucyh7XG4gICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgY2VsbFByb3BzLFxuICAgICAgICAgICAgY29sbGVjdGlvbjogeyAuLi5jb2xsZWN0aW9uLCBmaWVsZHM6IGZvcm1hdEZpZWxkcyhjb2xsZWN0aW9uKSB9LFxuICAgICAgICAgICAgY29sdW1uczogbmV3Q29scy5tYXAoKGNvbHVtbikgPT4ge1xuICAgICAgICAgICAgICAvLyAnc3RyaW5nJyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgLy8gdGhlIHByZWZlcmVuY2UgdXNlZCB0byBiZSBzdG9yZWQgYXMgYW4gYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgYWNjZXNzb3I6IGNvbHVtbixcbiAgICAgICAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtblxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0eXBlOiAnc2V0JyxcbiAgICAgICAgfSlcblxuICAgICAgICBoYXNJbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHN5bmMoKVxuICB9LCBbXG4gICAgcHJlZmVyZW5jZUtleSxcbiAgICBzZXRQcmVmZXJlbmNlLFxuICAgIHRhYmxlQ29sdW1ucyxcbiAgICBnZXRQcmVmZXJlbmNlLFxuICAgIHVzZUFzVGl0bGUsXG4gICAgZGVmYXVsdENvbHVtbnMsXG4gICAgY29sbGVjdGlvbixcbiAgICBjZWxsUHJvcHMsXG4gICAgZm9ybWF0dGVkRmllbGRzLFxuICBdKVxuXG4gIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgLy8gU2V0IHByZWZlcmVuY2VzIG9uIGNvbHVtbiBjaGFuZ2VcbiAgLy8gLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFoYXNJbml0aWFsaXplZC5jdXJyZW50KSByZXR1cm5cbiAgICBjb25zdCBjb2x1bW5zID0gdGFibGVDb2x1bW5zLm1hcCgoYykgPT4gKHtcbiAgICAgIGFjY2Vzc29yOiBjLmFjY2Vzc29yLFxuICAgICAgYWN0aXZlOiBjLmFjdGl2ZSxcbiAgICB9KSlcblxuICAgIHZvaWQgc2V0UHJlZmVyZW5jZShwcmVmZXJlbmNlS2V5LCB7IGNvbHVtbnMgfSwgdHJ1ZSlcbiAgfSwgW3RhYmxlQ29sdW1ucywgcHJlZmVyZW5jZUtleSwgc2V0UHJlZmVyZW5jZSwgZ2V0UHJlZmVyZW5jZV0pXG5cbiAgY29uc3Qgc2V0QWN0aXZlQ29sdW1ucyA9IHVzZUNhbGxiYWNrKFxuICAgIChjb2x1bW5zOiBzdHJpbmdbXSkgPT4ge1xuICAgICAgZGlzcGF0Y2hUYWJsZUNvbHVtbnMoe1xuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgLy8gb25TZWxlY3QsXG4gICAgICAgICAgY2VsbFByb3BzLFxuICAgICAgICAgIGNvbGxlY3Rpb246IHsgLi4uY29sbGVjdGlvbiwgZmllbGRzOiBmb3JtYXRGaWVsZHMoY29sbGVjdGlvbikgfSxcbiAgICAgICAgICBjb2x1bW5zOiBjb2x1bW5zLm1hcCgoY29sdW1uKSA9PiAoe1xuICAgICAgICAgICAgYWNjZXNzb3I6IGNvbHVtbixcbiAgICAgICAgICAgIGFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICB9KSksXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgfSlcbiAgICB9LFxuICAgIFtjb2xsZWN0aW9uLCBjZWxsUHJvcHNdLFxuICApXG5cbiAgY29uc3QgbW92ZUNvbHVtbiA9IHVzZUNhbGxiYWNrKFxuICAgIChhcmdzOiB7IGZyb21JbmRleDogbnVtYmVyOyB0b0luZGV4OiBudW1iZXIgfSkgPT4ge1xuICAgICAgY29uc3QgeyBmcm9tSW5kZXgsIHRvSW5kZXggfSA9IGFyZ3NcblxuICAgICAgZGlzcGF0Y2hUYWJsZUNvbHVtbnMoe1xuICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgY2VsbFByb3BzLFxuICAgICAgICAgIGNvbGxlY3Rpb246IHsgLi4uY29sbGVjdGlvbiwgZmllbGRzOiBmb3JtYXRGaWVsZHMoY29sbGVjdGlvbikgfSxcbiAgICAgICAgICBmcm9tSW5kZXgsXG4gICAgICAgICAgdG9JbmRleCxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogJ21vdmUnLFxuICAgICAgfSlcbiAgICB9LFxuICAgIFtjb2xsZWN0aW9uLCBjZWxsUHJvcHNdLFxuICApXG5cbiAgY29uc3QgdG9nZ2xlQ29sdW1uID0gdXNlQ2FsbGJhY2soXG4gICAgKGNvbHVtbjogc3RyaW5nKSA9PiB7XG4gICAgICBkaXNwYXRjaFRhYmxlQ29sdW1ucyh7XG4gICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICBjZWxsUHJvcHMsXG4gICAgICAgICAgY29sbGVjdGlvbjogeyAuLi5jb2xsZWN0aW9uLCBmaWVsZHM6IGZvcm1hdEZpZWxkcyhjb2xsZWN0aW9uKSB9LFxuICAgICAgICAgIGNvbHVtbixcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogJ3RvZ2dsZScsXG4gICAgICB9KVxuICAgIH0sXG4gICAgW2NvbGxlY3Rpb24sIGNlbGxQcm9wc10sXG4gIClcblxuICByZXR1cm4gKFxuICAgIDxUYWJsZUNvbHVtbkNvbnRleHQuUHJvdmlkZXJcbiAgICAgIHZhbHVlPXt7XG4gICAgICAgIGNvbHVtbnM6IHRhYmxlQ29sdW1ucyxcbiAgICAgICAgZGlzcGF0Y2hUYWJsZUNvbHVtbnMsXG4gICAgICAgIG1vdmVDb2x1bW4sXG4gICAgICAgIHNldEFjdGl2ZUNvbHVtbnMsXG4gICAgICAgIHRvZ2dsZUNvbHVtbixcbiAgICAgIH19XG4gICAgPlxuICAgICAge2NoaWxkcmVufVxuICAgIDwvVGFibGVDb2x1bW5Db250ZXh0LlByb3ZpZGVyPlxuICApXG59XG4iXSwibmFtZXMiOlsiVGFibGVDb2x1bW5Db250ZXh0IiwidXNlVGFibGVDb2x1bW5zIiwiVGFibGVDb2x1bW5zUHJvdmlkZXIiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsImNlbGxQcm9wcyIsImNoaWxkcmVuIiwiY29sbGVjdGlvbiIsImFkbWluIiwiZGVmYXVsdENvbHVtbnMiLCJ1c2VBc1RpdGxlIiwicHJlZmVyZW5jZUtleSIsInNsdWciLCJwcmV2Q29sbGVjdGlvbiIsInVzZVJlZiIsImhhc0luaXRpYWxpemVkIiwiZ2V0UHJlZmVyZW5jZSIsInNldFByZWZlcmVuY2UiLCJ1c2VQcmVmZXJlbmNlcyIsImZvcm1hdHRlZEZpZWxkcyIsInVzZVN0YXRlIiwiZm9ybWF0RmllbGRzIiwidGFibGVDb2x1bW5zIiwiZGlzcGF0Y2hUYWJsZUNvbHVtbnMiLCJ1c2VSZWR1Y2VyIiwiY29sdW1uUmVkdWNlciIsImluaXRpYWxDb2x1bW5zIiwiZ2V0SW5pdGlhbENvbHVtblN0YXRlIiwiYnVpbGRDb2x1bW5zIiwiY29sdW1ucyIsIm1hcCIsImNvbHVtbiIsImFjY2Vzc29yIiwiYWN0aXZlIiwidXNlRWZmZWN0Iiwic3luYyIsImNvbGxlY3Rpb25IYXNDaGFuZ2VkIiwiY3VycmVudCIsImN1cnJlbnRQcmVmZXJlbmNlcyIsIm5ld0NvbHMiLCJwYXlsb2FkIiwiZmllbGRzIiwidHlwZSIsImMiLCJzZXRBY3RpdmVDb2x1bW5zIiwidXNlQ2FsbGJhY2siLCJtb3ZlQ29sdW1uIiwiYXJncyIsImZyb21JbmRleCIsInRvSW5kZXgiLCJ0b2dnbGVDb2x1bW4iLCJQcm92aWRlciIsInZhbHVlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztJQStCYUEsa0JBQWtCO2VBQWxCQTs7SUFFQUMsZUFBZTtlQUFmQTs7SUFFQUMsb0JBQW9CO2VBQXBCQTs7OytEQTNCTjs2QkFTd0I7cUVBQ047cUVBQ0E7K0JBQ0s7MEVBQ0k7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVUzQixNQUFNRixtQ0FBcUJHLElBQUFBLG9CQUFhLEVBQWdCLENBQUM7QUFFekQsTUFBTUYsa0JBQWtCLElBQXFCRyxJQUFBQSxpQkFBVSxFQUFDSjtBQUV4RCxNQUFNRSx1QkFJUixDQUFDLEVBQ0pHLFNBQVMsRUFDVEMsUUFBUSxFQUNSQyxZQUFZLEVBQ1ZDLE9BQU8sRUFBRUMsY0FBYyxFQUFFQyxVQUFVLEVBQUUsRUFDdEMsRUFDREgsVUFBVSxFQUNYO0lBQ0MsTUFBTUksZ0JBQWdCLENBQUMsRUFBRUosV0FBV0ssSUFBSSxDQUFDLEtBQUssQ0FBQztJQUMvQyxNQUFNQyxpQkFBaUJDLElBQUFBLGFBQU07SUFDN0IsTUFBTUMsaUJBQWlCRCxJQUFBQSxhQUFNLEVBQUM7SUFDOUIsTUFBTSxFQUFFRSxhQUFhLEVBQUVDLGFBQWEsRUFBRSxHQUFHQyxJQUFBQSwyQkFBYztJQUN2RCxNQUFNLENBQUNDLGdCQUFnQixHQUFHQyxJQUFBQSxlQUFRLEVBQVUsSUFBTUMsSUFBQUEscUJBQVksRUFBQ2Q7SUFFL0QsTUFBTSxDQUFDZSxjQUFjQyxxQkFBcUIsR0FBR0MsSUFBQUEsaUJBQVUsRUFBQ0MsNEJBQWEsRUFBRSxDQUFDLEdBQUc7UUFDekUsTUFBTUMsaUJBQWlCQyxJQUFBQSwwQkFBcUIsRUFBQ1IsaUJBQWlCVCxZQUFZRDtRQUUxRSxPQUFPbUIsSUFBQUEscUJBQVksRUFBQztZQUNsQnZCO1lBQ0FFO1lBQ0FzQixTQUFTSCxlQUFlSSxHQUFHLENBQUMsQ0FBQ0MsU0FBWSxDQUFBO29CQUN2Q0MsVUFBVUQ7b0JBQ1ZFLFFBQVE7Z0JBQ1YsQ0FBQTtRQUNGO0lBQ0Y7SUFFQSx3Q0FBd0M7SUFDeEMsd0NBQXdDO0lBQ3hDLHdDQUF3QztJQUV4Q0MsSUFBQUEsZ0JBQVMsRUFBQztRQUNSLE1BQU1DLE9BQU87WUFDWCxNQUFNQyx1QkFBdUJ2QixlQUFld0IsT0FBTyxLQUFLOUIsV0FBV0ssSUFBSTtZQUV2RSxJQUFJd0Isc0JBQXNCO2dCQUN4QnJCLGVBQWVzQixPQUFPLEdBQUc7Z0JBRXpCLE1BQU1DLHFCQUFxQixNQUFNdEIsY0FBK0JMO2dCQUNoRUUsZUFBZXdCLE9BQU8sR0FBRzlCLFdBQVdLLElBQUk7Z0JBQ3hDLE1BQU1jLGlCQUFpQkMsSUFBQUEsMEJBQXFCLEVBQUNSLGlCQUFpQlQsWUFBWUQ7Z0JBQzFFLE1BQU04QixVQUFVRCxvQkFBb0JULFdBQVdIO2dCQUUvQ0gscUJBQXFCO29CQUNuQmlCLFNBQVM7d0JBQ1BuQzt3QkFDQUUsWUFBWTs0QkFBRSxHQUFHQSxVQUFVOzRCQUFFa0MsUUFBUXBCLElBQUFBLHFCQUFZLEVBQUNkO3dCQUFZO3dCQUM5RHNCLFNBQVNVLFFBQVFULEdBQUcsQ0FBQyxDQUFDQzs0QkFDcEIsMENBQTBDOzRCQUMxQywwREFBMEQ7NEJBQzFELElBQUksT0FBT0EsV0FBVyxVQUFVO2dDQUM5QixPQUFPO29DQUNMQyxVQUFVRDtvQ0FDVkUsUUFBUTtnQ0FDVjs0QkFDRjs0QkFDQSxPQUFPRjt3QkFDVDtvQkFDRjtvQkFDQVcsTUFBTTtnQkFDUjtnQkFFQTNCLGVBQWVzQixPQUFPLEdBQUc7WUFDM0I7UUFDRjtRQUVBRjtJQUNGLEdBQUc7UUFDRHhCO1FBQ0FNO1FBQ0FLO1FBQ0FOO1FBQ0FOO1FBQ0FEO1FBQ0FGO1FBQ0FGO1FBQ0FjO0tBQ0Q7SUFFRCx3Q0FBd0M7SUFDeEMsbUNBQW1DO0lBQ25DLHdDQUF3QztJQUV4Q2UsSUFBQUEsZ0JBQVMsRUFBQztRQUNSLElBQUksQ0FBQ25CLGVBQWVzQixPQUFPLEVBQUU7UUFDN0IsTUFBTVIsVUFBVVAsYUFBYVEsR0FBRyxDQUFDLENBQUNhLElBQU8sQ0FBQTtnQkFDdkNYLFVBQVVXLEVBQUVYLFFBQVE7Z0JBQ3BCQyxRQUFRVSxFQUFFVixNQUFNO1lBQ2xCLENBQUE7UUFFQSxLQUFLaEIsY0FBY04sZUFBZTtZQUFFa0I7UUFBUSxHQUFHO0lBQ2pELEdBQUc7UUFBQ1A7UUFBY1g7UUFBZU07UUFBZUQ7S0FBYztJQUU5RCxNQUFNNEIsbUJBQW1CQyxJQUFBQSxrQkFBVyxFQUNsQyxDQUFDaEI7UUFDQ04scUJBQXFCO1lBQ25CaUIsU0FBUztnQkFDUCxZQUFZO2dCQUNabkM7Z0JBQ0FFLFlBQVk7b0JBQUUsR0FBR0EsVUFBVTtvQkFBRWtDLFFBQVFwQixJQUFBQSxxQkFBWSxFQUFDZDtnQkFBWTtnQkFDOURzQixTQUFTQSxRQUFRQyxHQUFHLENBQUMsQ0FBQ0MsU0FBWSxDQUFBO3dCQUNoQ0MsVUFBVUQ7d0JBQ1ZFLFFBQVE7b0JBQ1YsQ0FBQTtZQUNGO1lBQ0FTLE1BQU07UUFDUjtJQUNGLEdBQ0E7UUFBQ25DO1FBQVlGO0tBQVU7SUFHekIsTUFBTXlDLGFBQWFELElBQUFBLGtCQUFXLEVBQzVCLENBQUNFO1FBQ0MsTUFBTSxFQUFFQyxTQUFTLEVBQUVDLE9BQU8sRUFBRSxHQUFHRjtRQUUvQnhCLHFCQUFxQjtZQUNuQmlCLFNBQVM7Z0JBQ1BuQztnQkFDQUUsWUFBWTtvQkFBRSxHQUFHQSxVQUFVO29CQUFFa0MsUUFBUXBCLElBQUFBLHFCQUFZLEVBQUNkO2dCQUFZO2dCQUM5RHlDO2dCQUNBQztZQUNGO1lBQ0FQLE1BQU07UUFDUjtJQUNGLEdBQ0E7UUFBQ25DO1FBQVlGO0tBQVU7SUFHekIsTUFBTTZDLGVBQWVMLElBQUFBLGtCQUFXLEVBQzlCLENBQUNkO1FBQ0NSLHFCQUFxQjtZQUNuQmlCLFNBQVM7Z0JBQ1BuQztnQkFDQUUsWUFBWTtvQkFBRSxHQUFHQSxVQUFVO29CQUFFa0MsUUFBUXBCLElBQUFBLHFCQUFZLEVBQUNkO2dCQUFZO2dCQUM5RHdCO1lBQ0Y7WUFDQVcsTUFBTTtRQUNSO0lBQ0YsR0FDQTtRQUFDbkM7UUFBWUY7S0FBVTtJQUd6QixxQkFDRSw2QkFBQ0wsbUJBQW1CbUQsUUFBUTtRQUMxQkMsT0FBTztZQUNMdkIsU0FBU1A7WUFDVEM7WUFDQXVCO1lBQ0FGO1lBQ0FNO1FBQ0Y7T0FFQzVDO0FBR1AifQ==