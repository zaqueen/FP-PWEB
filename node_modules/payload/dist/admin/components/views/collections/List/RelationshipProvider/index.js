"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    RelationshipProvider: function() {
        return RelationshipProvider;
    },
    useListRelationships: function() {
        return useListRelationships;
    }
});
const _qs = /*#__PURE__*/ _interop_require_default(require("qs"));
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _useDebounce = /*#__PURE__*/ _interop_require_default(require("../../../../../hooks/useDebounce"));
const _Config = require("../../../../utilities/Config");
const _Locale = require("../../../../utilities/Locale");
const _reducer = require("./reducer");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const Context = /*#__PURE__*/ (0, _react.createContext)({});
const RelationshipProvider = ({ children })=>{
    const [documents, dispatchDocuments] = (0, _react.useReducer)(_reducer.reducer, {});
    const debouncedDocuments = (0, _useDebounce.default)(documents, 100);
    const config = (0, _Config.useConfig)();
    const { i18n } = (0, _reacti18next.useTranslation)();
    const { code: locale } = (0, _Locale.useLocale)();
    const prevLocale = (0, _react.useRef)(locale);
    const { routes: { api }, serverURL } = config;
    const loadRelationshipDocs = (0, _react.useCallback)(async (reloadAll = false)=>{
        Object.entries(debouncedDocuments).forEach(async ([slug, docs])=>{
            const idsToLoad = [];
            Object.entries(docs).forEach(([id, value])=>{
                if (value === null || reloadAll) {
                    idsToLoad.push(id);
                }
            });
            if (idsToLoad.length > 0) {
                const url = `${serverURL}${api}/${slug}`;
                const params = {
                    depth: 0,
                    limit: 250,
                    locale,
                    'where[id][in]': idsToLoad
                };
                const query = _qs.default.stringify(params, {
                    addQueryPrefix: true
                });
                const result = await fetch(`${url}${query}`, {
                    credentials: 'include',
                    headers: {
                        'Accept-Language': i18n.language
                    }
                });
                if (result.ok) {
                    const json = await result.json();
                    if (json.docs) {
                        dispatchDocuments({
                            docs: json.docs,
                            idsToLoad,
                            relationTo: slug,
                            type: 'ADD_LOADED'
                        });
                    }
                } else {
                    dispatchDocuments({
                        docs: [],
                        idsToLoad,
                        relationTo: slug,
                        type: 'ADD_LOADED'
                    });
                }
            }
        });
    }, [
        debouncedDocuments,
        serverURL,
        api,
        i18n,
        locale
    ]);
    (0, _react.useEffect)(()=>{
        loadRelationshipDocs(locale && prevLocale.current !== locale);
        prevLocale.current = locale;
    }, [
        locale,
        loadRelationshipDocs
    ]);
    const getRelationships = (0, _react.useCallback)(async (relationships)=>{
        dispatchDocuments({
            docs: relationships,
            type: 'REQUEST'
        });
    }, []);
    return /*#__PURE__*/ _react.default.createElement(Context.Provider, {
        value: {
            documents,
            getRelationships
        }
    }, children);
};
const useListRelationships = ()=>(0, _react.useContext)(Context);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL3ZpZXdzL2NvbGxlY3Rpb25zL0xpc3QvUmVsYXRpb25zaGlwUHJvdmlkZXIvaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBxdWVyeXN0cmluZyBmcm9tICdxcydcbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VSZWR1Y2VyLCB1c2VSZWYgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHVzZVRyYW5zbGF0aW9uIH0gZnJvbSAncmVhY3QtaTE4bmV4dCdcblxuaW1wb3J0IHR5cGUgeyBUeXBlV2l0aElEIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vY29sbGVjdGlvbnMvY29uZmlnL3R5cGVzJ1xuXG5pbXBvcnQgdXNlRGVib3VuY2UgZnJvbSAnLi4vLi4vLi4vLi4vLi4vaG9va3MvdXNlRGVib3VuY2UnXG5pbXBvcnQgeyB1c2VDb25maWcgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlsaXRpZXMvQ29uZmlnJ1xuaW1wb3J0IHsgdXNlTG9jYWxlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdXRpbGl0aWVzL0xvY2FsZSdcbmltcG9ydCB7IHJlZHVjZXIgfSBmcm9tICcuL3JlZHVjZXInXG5cbi8vIGRvY3VtZW50cyBhcmUgZmlyc3Qgc2V0IHRvIG51bGwgd2hlbiByZXF1ZXN0ZWRcbi8vIHNldCB0byBmYWxzZSB3aGVuIG5vIGRvYyBpcyByZXR1cm5lZFxuLy8gb3Igc2V0IHRvIHRoZSBkb2N1bWVudCByZXR1cm5lZFxuZXhwb3J0IHR5cGUgRG9jdW1lbnRzID0ge1xuICBbc2x1Zzogc3RyaW5nXToge1xuICAgIFtpZDogbnVtYmVyIHwgc3RyaW5nXTogVHlwZVdpdGhJRCB8IGZhbHNlIHwgbnVsbFxuICB9XG59XG5cbnR5cGUgTGlzdFJlbGF0aW9uc2hpcENvbnRleHQgPSB7XG4gIGRvY3VtZW50czogRG9jdW1lbnRzXG4gIGdldFJlbGF0aW9uc2hpcHM6IChcbiAgICBkb2NzOiB7XG4gICAgICByZWxhdGlvblRvOiBzdHJpbmdcbiAgICAgIHZhbHVlOiBudW1iZXIgfCBzdHJpbmdcbiAgICB9W10sXG4gICkgPT4gdm9pZFxufVxuXG5jb25zdCBDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSBhcyBMaXN0UmVsYXRpb25zaGlwQ29udGV4dClcblxuZXhwb3J0IGNvbnN0IFJlbGF0aW9uc2hpcFByb3ZpZGVyOiBSZWFjdC5GQzx7IGNoaWxkcmVuPzogUmVhY3QuUmVhY3ROb2RlIH0+ID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICBjb25zdCBbZG9jdW1lbnRzLCBkaXNwYXRjaERvY3VtZW50c10gPSB1c2VSZWR1Y2VyKHJlZHVjZXIsIHt9KVxuICBjb25zdCBkZWJvdW5jZWREb2N1bWVudHMgPSB1c2VEZWJvdW5jZShkb2N1bWVudHMsIDEwMClcbiAgY29uc3QgY29uZmlnID0gdXNlQ29uZmlnKClcbiAgY29uc3QgeyBpMThuIH0gPSB1c2VUcmFuc2xhdGlvbigpXG4gIGNvbnN0IHsgY29kZTogbG9jYWxlIH0gPSB1c2VMb2NhbGUoKVxuICBjb25zdCBwcmV2TG9jYWxlID0gdXNlUmVmKGxvY2FsZSlcblxuICBjb25zdCB7XG4gICAgcm91dGVzOiB7IGFwaSB9LFxuICAgIHNlcnZlclVSTCxcbiAgfSA9IGNvbmZpZ1xuXG4gIGNvbnN0IGxvYWRSZWxhdGlvbnNoaXBEb2NzID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHJlbG9hZEFsbCA9IGZhbHNlKSA9PiB7XG4gICAgICBPYmplY3QuZW50cmllcyhkZWJvdW5jZWREb2N1bWVudHMpLmZvckVhY2goYXN5bmMgKFtzbHVnLCBkb2NzXSkgPT4ge1xuICAgICAgICBjb25zdCBpZHNUb0xvYWQ6IChudW1iZXIgfCBzdHJpbmcpW10gPSBbXVxuXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGRvY3MpLmZvckVhY2goKFtpZCwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHJlbG9hZEFsbCkge1xuICAgICAgICAgICAgaWRzVG9Mb2FkLnB1c2goaWQpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIGlmIChpZHNUb0xvYWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHVybCA9IGAke3NlcnZlclVSTH0ke2FwaX0vJHtzbHVnfWBcbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgICAgIGxpbWl0OiAyNTAsXG4gICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAnd2hlcmVbaWRdW2luXSc6IGlkc1RvTG9hZCxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeShwYXJhbXMsIHsgYWRkUXVlcnlQcmVmaXg6IHRydWUgfSlcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmZXRjaChgJHt1cmx9JHtxdWVyeX1gLCB7XG4gICAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzogaTE4bi5sYW5ndWFnZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSlcblxuICAgICAgICAgIGlmIChyZXN1bHQub2spIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXN1bHQuanNvbigpXG4gICAgICAgICAgICBpZiAoanNvbi5kb2NzKSB7XG4gICAgICAgICAgICAgIGRpc3BhdGNoRG9jdW1lbnRzKHtcbiAgICAgICAgICAgICAgICBkb2NzOiBqc29uLmRvY3MsXG4gICAgICAgICAgICAgICAgaWRzVG9Mb2FkLFxuICAgICAgICAgICAgICAgIHJlbGF0aW9uVG86IHNsdWcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ0FERF9MT0FERUQnLFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwYXRjaERvY3VtZW50cyh7IGRvY3M6IFtdLCBpZHNUb0xvYWQsIHJlbGF0aW9uVG86IHNsdWcsIHR5cGU6ICdBRERfTE9BREVEJyB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuICAgIFtkZWJvdW5jZWREb2N1bWVudHMsIHNlcnZlclVSTCwgYXBpLCBpMThuLCBsb2NhbGVdLFxuICApXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2FkUmVsYXRpb25zaGlwRG9jcyhsb2NhbGUgJiYgcHJldkxvY2FsZS5jdXJyZW50ICE9PSBsb2NhbGUpXG4gICAgcHJldkxvY2FsZS5jdXJyZW50ID0gbG9jYWxlXG4gIH0sIFtsb2NhbGUsIGxvYWRSZWxhdGlvbnNoaXBEb2NzXSlcblxuICBjb25zdCBnZXRSZWxhdGlvbnNoaXBzID0gdXNlQ2FsbGJhY2soXG4gICAgYXN5bmMgKHJlbGF0aW9uc2hpcHM6IHsgcmVsYXRpb25Ubzogc3RyaW5nOyB2YWx1ZTogbnVtYmVyIHwgc3RyaW5nIH1bXSkgPT4ge1xuICAgICAgZGlzcGF0Y2hEb2N1bWVudHMoeyBkb2NzOiByZWxhdGlvbnNoaXBzLCB0eXBlOiAnUkVRVUVTVCcgfSlcbiAgICB9LFxuICAgIFtdLFxuICApXG5cbiAgcmV0dXJuIDxDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt7IGRvY3VtZW50cywgZ2V0UmVsYXRpb25zaGlwcyB9fT57Y2hpbGRyZW59PC9Db250ZXh0LlByb3ZpZGVyPlxufVxuXG5leHBvcnQgY29uc3QgdXNlTGlzdFJlbGF0aW9uc2hpcHMgPSAoKTogTGlzdFJlbGF0aW9uc2hpcENvbnRleHQgPT4gdXNlQ29udGV4dChDb250ZXh0KVxuIl0sIm5hbWVzIjpbIlJlbGF0aW9uc2hpcFByb3ZpZGVyIiwidXNlTGlzdFJlbGF0aW9uc2hpcHMiLCJDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImNoaWxkcmVuIiwiZG9jdW1lbnRzIiwiZGlzcGF0Y2hEb2N1bWVudHMiLCJ1c2VSZWR1Y2VyIiwicmVkdWNlciIsImRlYm91bmNlZERvY3VtZW50cyIsInVzZURlYm91bmNlIiwiY29uZmlnIiwidXNlQ29uZmlnIiwiaTE4biIsInVzZVRyYW5zbGF0aW9uIiwiY29kZSIsImxvY2FsZSIsInVzZUxvY2FsZSIsInByZXZMb2NhbGUiLCJ1c2VSZWYiLCJyb3V0ZXMiLCJhcGkiLCJzZXJ2ZXJVUkwiLCJsb2FkUmVsYXRpb25zaGlwRG9jcyIsInVzZUNhbGxiYWNrIiwicmVsb2FkQWxsIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJzbHVnIiwiZG9jcyIsImlkc1RvTG9hZCIsImlkIiwidmFsdWUiLCJwdXNoIiwibGVuZ3RoIiwidXJsIiwicGFyYW1zIiwiZGVwdGgiLCJsaW1pdCIsInF1ZXJ5IiwicXVlcnlzdHJpbmciLCJzdHJpbmdpZnkiLCJhZGRRdWVyeVByZWZpeCIsInJlc3VsdCIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJoZWFkZXJzIiwibGFuZ3VhZ2UiLCJvayIsImpzb24iLCJyZWxhdGlvblRvIiwidHlwZSIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJnZXRSZWxhdGlvbnNoaXBzIiwicmVsYXRpb25zaGlwcyIsIlByb3ZpZGVyIiwidXNlQ29udGV4dCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7SUFnQ2FBLG9CQUFvQjtlQUFwQkE7O0lBMkVBQyxvQkFBb0I7ZUFBcEJBOzs7MkRBM0dXOytEQUNxRTs4QkFDOUQ7b0VBSVA7d0JBQ0U7d0JBQ0E7eUJBQ0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCeEIsTUFBTUMsd0JBQVVDLElBQUFBLG9CQUFhLEVBQUMsQ0FBQztBQUV4QixNQUFNSCx1QkFBaUUsQ0FBQyxFQUFFSSxRQUFRLEVBQUU7SUFDekYsTUFBTSxDQUFDQyxXQUFXQyxrQkFBa0IsR0FBR0MsSUFBQUEsaUJBQVUsRUFB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