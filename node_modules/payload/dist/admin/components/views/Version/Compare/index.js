"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return _default;
    }
});
const _qs = /*#__PURE__*/ _interop_require_default(require("qs"));
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _formatDate = require("../../../../utilities/formatDate");
const _ReactSelect = /*#__PURE__*/ _interop_require_default(require("../../../elements/ReactSelect"));
const _shared = require("../../../forms/field-types/shared");
const _Config = require("../../../utilities/Config");
const _shared1 = require("../shared");
require("./index.scss");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const baseClass = 'compare-version';
const maxResultsPerRequest = 10;
const baseOptions = [
    _shared1.mostRecentVersionOption
];
const CompareVersion = (props)=>{
    const { baseURL, onChange, parentID, publishedDoc, value, versionID } = props;
    const { admin: { dateFormat } } = (0, _Config.useConfig)();
    const [options, setOptions] = (0, _react.useState)(baseOptions);
    const [lastLoadedPage, setLastLoadedPage] = (0, _react.useState)(1);
    const [errorLoading, setErrorLoading] = (0, _react.useState)('');
    const { i18n, t } = (0, _reacti18next.useTranslation)('version');
    const getResults = (0, _react.useCallback)(async ({ lastLoadedPage: lastLoadedPageArg })=>{
        const query = {
            depth: 0,
            limit: maxResultsPerRequest,
            page: lastLoadedPageArg,
            where: {
                and: [
                    {
                        id: {
                            not_equals: versionID
                        }
                    }
                ]
            }
        };
        if (parentID) {
            query.where.and.push({
                parent: {
                    equals: parentID
                }
            });
        }
        const search = _qs.default.stringify(query);
        const response = await fetch(`${baseURL}?${search}`, {
            credentials: 'include',
            headers: {
                'Accept-Language': i18n.language
            }
        });
        if (response.ok) {
            const data = await response.json();
            if (data.docs.length > 0) {
                setOptions((existingOptions)=>[
                        ...existingOptions,
                        ...data.docs.map((doc)=>({
                                label: (0, _formatDate.formatDate)(doc.updatedAt, dateFormat, i18n?.language),
                                value: doc.id
                            }))
                    ]);
                setLastLoadedPage(data.page);
            }
        } else {
            setErrorLoading(t('error:unspecific'));
        }
    }, [
        dateFormat,
        baseURL,
        parentID,
        versionID,
        t,
        i18n
    ]);
    (0, _react.useEffect)(()=>{
        getResults({
            lastLoadedPage: 1
        });
    }, [
        getResults
    ]);
    (0, _react.useEffect)(()=>{
        if (publishedDoc?._status === 'published') setOptions((currentOptions)=>[
                _shared1.publishedVersionOption,
                ...currentOptions
            ]);
    }, [
        publishedDoc
    ]);
    return /*#__PURE__*/ _react.default.createElement("div", {
        className: [
            _shared.fieldBaseClass,
            baseClass,
            errorLoading && 'error-loading'
        ].filter(Boolean).join(' ')
    }, /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__label`
    }, t('compareVersion')), !errorLoading && /*#__PURE__*/ _react.default.createElement(_ReactSelect.default, {
        isClearable: false,
        isSearchable: false,
        onChange: onChange,
        onMenuScrollToBottom: ()=>{
            getResults({
                lastLoadedPage: lastLoadedPage + 1
            });
        },
        options: options,
        placeholder: t('selectVersionToCompare'),
        value: value
    }), errorLoading && /*#__PURE__*/ _react.default.createElement("div", {
        className: `${baseClass}__error-loading`
    }, errorLoading));
};
const _default = CompareVersion;

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL3ZpZXdzL1ZlcnNpb24vQ29tcGFyZS9pbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHFzIGZyb20gJ3FzJ1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyB1c2VUcmFuc2xhdGlvbiB9IGZyb20gJ3JlYWN0LWkxOG5leHQnXG5cbmltcG9ydCB0eXBlIHsgUGFnaW5hdGVkRG9jcyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL2RhdGFiYXNlL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBXaGVyZSB9IGZyb20gJy4uLy4uLy4uLy4uLy4uL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBQcm9wcyB9IGZyb20gJy4vdHlwZXMnXG5cbmltcG9ydCB7IGZvcm1hdERhdGUgfSBmcm9tICcuLi8uLi8uLi8uLi91dGlsaXRpZXMvZm9ybWF0RGF0ZSdcbmltcG9ydCBSZWFjdFNlbGVjdCBmcm9tICcuLi8uLi8uLi9lbGVtZW50cy9SZWFjdFNlbGVjdCdcbmltcG9ydCB7IGZpZWxkQmFzZUNsYXNzIH0gZnJvbSAnLi4vLi4vLi4vZm9ybXMvZmllbGQtdHlwZXMvc2hhcmVkJ1xuaW1wb3J0IHsgdXNlQ29uZmlnIH0gZnJvbSAnLi4vLi4vLi4vdXRpbGl0aWVzL0NvbmZpZydcbmltcG9ydCB7IG1vc3RSZWNlbnRWZXJzaW9uT3B0aW9uLCBwdWJsaXNoZWRWZXJzaW9uT3B0aW9uIH0gZnJvbSAnLi4vc2hhcmVkJ1xuaW1wb3J0ICcuL2luZGV4LnNjc3MnXG5cbmNvbnN0IGJhc2VDbGFzcyA9ICdjb21wYXJlLXZlcnNpb24nXG5cbmNvbnN0IG1heFJlc3VsdHNQZXJSZXF1ZXN0ID0gMTBcblxuY29uc3QgYmFzZU9wdGlvbnMgPSBbbW9zdFJlY2VudFZlcnNpb25PcHRpb25dXG5cbmNvbnN0IENvbXBhcmVWZXJzaW9uOiBSZWFjdC5GQzxQcm9wcz4gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgeyBiYXNlVVJMLCBvbkNoYW5nZSwgcGFyZW50SUQsIHB1Ymxpc2hlZERvYywgdmFsdWUsIHZlcnNpb25JRCB9ID0gcHJvcHNcblxuICBjb25zdCB7XG4gICAgYWRtaW46IHsgZGF0ZUZvcm1hdCB9LFxuICB9ID0gdXNlQ29uZmlnKClcblxuICBjb25zdCBbb3B0aW9ucywgc2V0T3B0aW9uc10gPSB1c2VTdGF0ZShiYXNlT3B0aW9ucylcbiAgY29uc3QgW2xhc3RMb2FkZWRQYWdlLCBzZXRMYXN0TG9hZGVkUGFnZV0gPSB1c2VTdGF0ZSgxKVxuICBjb25zdCBbZXJyb3JMb2FkaW5nLCBzZXRFcnJvckxvYWRpbmddID0gdXNlU3RhdGUoJycpXG4gIGNvbnN0IHsgaTE4biwgdCB9ID0gdXNlVHJhbnNsYXRpb24oJ3ZlcnNpb24nKVxuXG4gIGNvbnN0IGdldFJlc3VsdHMgPSB1c2VDYWxsYmFjayhcbiAgICBhc3luYyAoeyBsYXN0TG9hZGVkUGFnZTogbGFzdExvYWRlZFBhZ2VBcmcgfSkgPT4ge1xuICAgICAgY29uc3QgcXVlcnk6IHtcbiAgICAgICAgW2tleTogc3RyaW5nXTogdW5rbm93blxuICAgICAgICB3aGVyZTogV2hlcmVcbiAgICAgIH0gPSB7XG4gICAgICAgIGRlcHRoOiAwLFxuICAgICAgICBsaW1pdDogbWF4UmVzdWx0c1BlclJlcXVlc3QsXG4gICAgICAgIHBhZ2U6IGxhc3RMb2FkZWRQYWdlQXJnLFxuICAgICAgICB3aGVyZToge1xuICAgICAgICAgIGFuZDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZDoge1xuICAgICAgICAgICAgICAgIG5vdF9lcXVhbHM6IHZlcnNpb25JRCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgIH1cblxuICAgICAgaWYgKHBhcmVudElEKSB7XG4gICAgICAgIHF1ZXJ5LndoZXJlLmFuZC5wdXNoKHtcbiAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgIGVxdWFsczogcGFyZW50SUQsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc2VhcmNoID0gcXMuc3RyaW5naWZ5KHF1ZXJ5KVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtiYXNlVVJMfT8ke3NlYXJjaH1gLCB7XG4gICAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzogaTE4bi5sYW5ndWFnZSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBkYXRhOiBQYWdpbmF0ZWREb2NzID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgICAgIGlmIChkYXRhLmRvY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHNldE9wdGlvbnMoKGV4aXN0aW5nT3B0aW9ucykgPT4gW1xuICAgICAgICAgICAgLi4uZXhpc3RpbmdPcHRpb25zLFxuICAgICAgICAgICAgLi4uZGF0YS5kb2NzLm1hcCgoZG9jKSA9PiAoe1xuICAgICAgICAgICAgICBsYWJlbDogZm9ybWF0RGF0ZShkb2MudXBkYXRlZEF0LCBkYXRlRm9ybWF0LCBpMThuPy5sYW5ndWFnZSksXG4gICAgICAgICAgICAgIHZhbHVlOiBkb2MuaWQsXG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgXSlcbiAgICAgICAgICBzZXRMYXN0TG9hZGVkUGFnZShkYXRhLnBhZ2UpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldEVycm9yTG9hZGluZyh0KCdlcnJvcjp1bnNwZWNpZmljJykpXG4gICAgICB9XG4gICAgfSxcbiAgICBbZGF0ZUZvcm1hdCwgYmFzZVVSTCwgcGFyZW50SUQsIHZlcnNpb25JRCwgdCwgaTE4bl0sXG4gIClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGdldFJlc3VsdHMoeyBsYXN0TG9hZGVkUGFnZTogMSB9KVxuICB9LCBbZ2V0UmVzdWx0c10pXG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHVibGlzaGVkRG9jPy5fc3RhdHVzID09PSAncHVibGlzaGVkJylcbiAgICAgIHNldE9wdGlvbnMoKGN1cnJlbnRPcHRpb25zKSA9PiBbcHVibGlzaGVkVmVyc2lvbk9wdGlvbiwgLi4uY3VycmVudE9wdGlvbnNdKVxuICB9LCBbcHVibGlzaGVkRG9jXSlcblxuICByZXR1cm4gKFxuICAgIDxkaXZcbiAgICAgIGNsYXNzTmFtZT17W2ZpZWxkQmFzZUNsYXNzLCBiYXNlQ2xhc3MsIGVycm9yTG9hZGluZyAmJiAnZXJyb3ItbG9hZGluZyddXG4gICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgLmpvaW4oJyAnKX1cbiAgICA+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT17YCR7YmFzZUNsYXNzfV9fbGFiZWxgfT57dCgnY29tcGFyZVZlcnNpb24nKX08L2Rpdj5cbiAgICAgIHshZXJyb3JMb2FkaW5nICYmIChcbiAgICAgICAgPFJlYWN0U2VsZWN0XG4gICAgICAgICAgaXNDbGVhcmFibGU9e2ZhbHNlfVxuICAgICAgICAgIGlzU2VhcmNoYWJsZT17ZmFsc2V9XG4gICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfVxuICAgICAgICAgIG9uTWVudVNjcm9sbFRvQm90dG9tPXsoKSA9PiB7XG4gICAgICAgICAgICBnZXRSZXN1bHRzKHsgbGFzdExvYWRlZFBhZ2U6IGxhc3RMb2FkZWRQYWdlICsgMSB9KVxuICAgICAgICAgIH19XG4gICAgICAgICAgb3B0aW9ucz17b3B0aW9uc31cbiAgICAgICAgICBwbGFjZWhvbGRlcj17dCgnc2VsZWN0VmVyc2lvblRvQ29tcGFyZScpfVxuICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgLz5cbiAgICAgICl9XG4gICAgICB7ZXJyb3JMb2FkaW5nICYmIDxkaXYgY2xhc3NOYW1lPXtgJHtiYXNlQ2xhc3N9X19lcnJvci1sb2FkaW5nYH0+e2Vycm9yTG9hZGluZ308L2Rpdj59XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29tcGFyZVZlcnNpb25cbiJdLCJuYW1lcyI6WyJiYXNlQ2xhc3MiLCJtYXhSZXN1bHRzUGVyUmVxdWVzdCIsImJhc2VPcHRpb25zIiwibW9zdFJlY2VudFZlcnNpb25PcHRpb24iLCJDb21wYXJlVmVyc2lvbiIsInByb3BzIiwiYmFzZVVSTCIsIm9uQ2hhbmdlIiwicGFyZW50SUQiLCJwdWJsaXNoZWREb2MiLCJ2YWx1ZSIsInZlcnNpb25JRCIsImFkbWluIiwiZGF0ZUZvcm1hdCIsInVzZUNvbmZpZyIsIm9wdGlvbnMiLCJzZXRPcHRpb25zIiwidXNlU3RhdGUiLCJsYXN0TG9hZGVkUGFnZSIsInNldExhc3RMb2FkZWRQYWdlIiwiZXJyb3JMb2FkaW5nIiwic2V0RXJyb3JMb2FkaW5nIiwiaTE4biIsInQiLCJ1c2VUcmFuc2xhdGlvbiIsImdldFJlc3VsdHMiLCJ1c2VDYWxsYmFjayIsImxhc3RMb2FkZWRQYWdlQXJnIiwicXVlcnkiLCJkZXB0aCIsImxpbWl0IiwicGFnZSIsIndoZXJlIiwiYW5kIiwiaWQiLCJub3RfZXF1YWxzIiwicHVzaCIsInBhcmVudCIsImVxdWFscyIsInNlYXJjaCIsInFzIiwic3RyaW5naWZ5IiwicmVzcG9uc2UiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwiaGVhZGVycyIsImxhbmd1YWdlIiwib2siLCJkYXRhIiwianNvbiIsImRvY3MiLCJsZW5ndGgiLCJleGlzdGluZ09wdGlvbnMiLCJtYXAiLCJkb2MiLCJsYWJlbCIsImZvcm1hdERhdGUiLCJ1cGRhdGVkQXQiLCJ1c2VFZmZlY3QiLCJfc3RhdHVzIiwiY3VycmVudE9wdGlvbnMiLCJwdWJsaXNoZWRWZXJzaW9uT3B0aW9uIiwiZGl2IiwiY2xhc3NOYW1lIiwiZmllbGRCYXNlQ2xhc3MiLCJmaWx0ZXIiLCJCb29sZWFuIiwiam9pbiIsIlJlYWN0U2VsZWN0IiwiaXNDbGVhcmFibGUiLCJpc1NlYXJjaGFibGUiLCJvbk1lbnVTY3JvbGxUb0JvdHRvbSIsInBsYWNlaG9sZGVyIl0sIm1hcHBpbmdzIjoiOzs7OytCQTBIQTs7O2VBQUE7OzsyREExSGU7K0RBQ3lDOzhCQUN6Qjs0QkFNSjtvRUFDSDt3QkFDTzt3QkFDTDt5QkFDc0M7UUFDekQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVQLE1BQU1BLFlBQVk7QUFFbEIsTUFBTUMsdUJBQXVCO0FBRTdCLE1BQU1DLGNBQWM7SUFBQ0MsZ0NBQXVCO0NBQUM7QUFFN0MsTUFBTUMsaUJBQWtDLENBQUNDO0lBQ3ZDLE1BQU0sRUFBRUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLFFBQVEsRUFBRUMsWUFBWSxFQUFFQyxLQUFLLEVBQUVDLFNBQVMsRUFBRSxHQUFHTjtJQUV4RSxNQUFNLEVBQ0pPLE9BQU8sRUFBRUMsVUFBVSxFQUFFLEVBQ3RCLEdBQUdDLElBQUFBLGlCQUFTO0lBRWIsTUFBTSxDQUFDQyxTQUFTQyxXQUFXLEdBQUdDLElBQUFBLGVBQVEsRUFBQ2Y7SUFDdkMsTUFBTSxDQUFDZ0IsZ0JBQWdCQyxrQkFBa0IsR0FBR0YsSUFBQUEsZUFBUSxFQUFDO0lBQ3JELE1BQU0sQ0FBQ0csY0FBY0MsZ0JBQWdCLEdBQUdKLElBQUFBLGVBQVEsRUFBQztJQUNqRCxNQUFNLEVBQUVLLElBQUksRUFBRUMsQ0FBQyxFQUFFLEdBQUdDLElBQUFBLDRCQUFjLEVBQUM7SUFFbkMsTUFBTUMsYUFBYUMsSUFBQUEsa0JBQVcsRUFDNUIsT0FBTyxFQUFFUixnQkFBZ0JTLGlCQUFpQixFQUFFO1FBQzFDLE1BQU1DLFFBR0Y7WUFDRkMsT0FBTztZQUNQQyxPQUFPN0I7WUFDUDhCLE1BQU1KO1lBQ05LLE9BQU87Z0JBQ0xDLEtBQUs7b0JBQ0g7d0JBQ0VDLElBQUk7NEJBQ0ZDLFlBQVl4Qjt3QkFDZDtvQkFDRjtpQkFDRDtZQUNIO1FBQ0Y7UUFFQSxJQUFJSCxVQUFVO1lBQ1pvQixNQUFNSSxLQUFLLENBQUNDLEdBQUcsQ0FBQ0csSUFBSSxDQUFDO2dCQUNuQkMsUUFBUTtvQkFDTkMsUUFBUTlCO2dCQUNWO1lBQ0Y7UUFDRjtRQUVBLE1BQU0rQixTQUFTQyxXQUFFLENBQUNDLFNBQVMsQ0FBQ2I7UUFDNUIsTUFBTWMsV0FBVyxNQUFNQyxNQUFNLENBQUMsRUFBRXJDLFFBQVEsQ0FBQyxFQUFFaUMsT0FBTyxDQUFDLEVBQUU7WUFDbkRLLGFBQWE7WUFDYkMsU0FBUztnQkFDUCxtQkFBbUJ2QixLQUFLd0IsUUFBUTtZQUNsQztRQUNGO1FBRUEsSUFBSUosU0FBU0ssRUFBRSxFQUFFO1lBQ2YsTUFBTUMsT0FBc0IsTUFBTU4sU0FBU08sSUFBSTtZQUMvQyxJQUFJRCxLQUFLRSxJQUFJLENBQUNDLE1BQU0sR0FBRyxHQUFHO2dCQUN4Qm5DLFdBQVcsQ0FBQ29DLGtCQUFvQjsyQkFDM0JBOzJCQUNBSixLQUFLRSxJQUFJLENBQUNHLEdBQUcsQ0FBQyxDQUFDQyxNQUFTLENBQUE7Z0NBQ3pCQyxPQUFPQyxJQUFBQSxzQkFBVSxFQUFDRixJQUFJRyxTQUFTLEVBQUU1QyxZQUFZUyxNQUFNd0I7Z0NBQ25EcEMsT0FBTzRDLElBQUlwQixFQUFFOzRCQUNmLENBQUE7cUJBQ0Q7Z0JBQ0RmLGtCQUFrQjZCLEtBQUtqQixJQUFJO1lBQzdCO1FBQ0YsT0FBTztZQUNMVixnQkFBZ0JFLEVBQUU7UUFDcEI7SUFDRixHQUNBO1FBQUNWO1FBQVlQO1FBQVNFO1FBQVVHO1FBQVdZO1FBQUdEO0tBQUs7SUFHckRvQyxJQUFBQSxnQkFBUyxFQUFDO1FBQ1JqQyxXQUFXO1lBQUVQLGdCQUFnQjtRQUFFO0lBQ2pDLEdBQUc7UUFBQ087S0FBVztJQUVmaUMsSUFBQUEsZ0JBQVMsRUFBQztRQUNSLElBQUlqRCxjQUFja0QsWUFBWSxhQUM1QjNDLFdBQVcsQ0FBQzRDLGlCQUFtQjtnQkFBQ0MsK0JBQXNCO21CQUFLRDthQUFlO0lBQzlFLEdBQUc7UUFBQ25EO0tBQWE7SUFFakIscUJBQ0UsNkJBQUNxRDtRQUNDQyxXQUFXO1lBQUNDLHNCQUFjO1lBQUVoRTtZQUFXb0IsZ0JBQWdCO1NBQWdCLENBQ3BFNkMsTUFBTSxDQUFDQyxTQUNQQyxJQUFJLENBQUM7cUJBRVIsNkJBQUNMO1FBQUlDLFdBQVcsQ0FBQyxFQUFFL0QsVUFBVSxPQUFPLENBQUM7T0FBR3VCLEVBQUUsb0JBQ3pDLENBQUNILDhCQUNBLDZCQUFDZ0Qsb0JBQVc7UUFDVkMsYUFBYTtRQUNiQyxjQUFjO1FBQ2QvRCxVQUFVQTtRQUNWZ0Usc0JBQXNCO1lBQ3BCOUMsV0FBVztnQkFBRVAsZ0JBQWdCQSxpQkFBaUI7WUFBRTtRQUNsRDtRQUNBSCxTQUFTQTtRQUNUeUQsYUFBYWpELEVBQUU7UUFDZmIsT0FBT0E7UUFHVlUsOEJBQWdCLDZCQUFDMEM7UUFBSUMsV0FBVyxDQUFDLEVBQUUvRCxVQUFVLGVBQWUsQ0FBQztPQUFHb0I7QUFHdkU7TUFFQSxXQUFlaEIifQ==