"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    useDocumentInfo: function() {
        return useDocumentInfo;
    },
    DocumentInfoProvider: function() {
        return DocumentInfoProvider;
    }
});
const _qs = /*#__PURE__*/ _interop_require_default(require("qs"));
const _react = /*#__PURE__*/ _interop_require_wildcard(require("react"));
const _reacti18next = require("react-i18next");
const _reactrouterdom = require("react-router-dom");
const _Auth = require("../Auth");
const _Config = require("../Config");
const _Locale = require("../Locale");
const _Preferences = require("../Preferences");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const Context = /*#__PURE__*/ (0, _react.createContext)({});
const useDocumentInfo = ()=>(0, _react.useContext)(Context);
const DocumentInfoProvider = ({ id: idFromProps, children, collection, global, idFromParams: getIDFromParams })=>{
    const { id: idFromParams } = (0, _reactrouterdom.useParams)();
    const id = idFromProps || (getIDFromParams ? idFromParams : null);
    const { routes: { api }, serverURL } = (0, _Config.useConfig)();
    const { getPreference, setPreference } = (0, _Preferences.usePreferences)();
    const { i18n } = (0, _reacti18next.useTranslation)();
    const { permissions } = (0, _Auth.useAuth)();
    const { code } = (0, _Locale.useLocale)();
    const [publishedDoc, setPublishedDoc] = (0, _react.useState)(null);
    const [versions, setVersions] = (0, _react.useState)(null);
    const [unpublishedVersions, setUnpublishedVersions] = (0, _react.useState)(null);
    const [docPermissions, setDocPermissions] = (0, _react.useState)(null);
    const baseURL = `${serverURL}${api}`;
    let slug;
    let pluralType;
    let preferencesKey;
    if (global) {
        slug = global.slug;
        pluralType = 'globals';
        preferencesKey = `global-${slug}`;
    }
    if (collection) {
        slug = collection.slug;
        pluralType = 'collections';
        if (id) {
            preferencesKey = `collection-${slug}-${id}`;
        }
    }
    const getVersions = (0, _react.useCallback)(async ()=>{
        let versionFetchURL;
        let publishedFetchURL;
        let draftsEnabled = false;
        let shouldFetchVersions = false;
        let unpublishedVersionJSON = null;
        let versionJSON = null;
        let shouldFetch = true;
        const versionParams = {
            depth: 0,
            where: {
                and: []
            }
        };
        const publishedVersionParams = {
            depth: 0,
            locale: code || undefined,
            where: {
                and: [
                    {
                        or: [
                            {
                                _status: {
                                    equals: 'published'
                                }
                            },
                            {
                                _status: {
                                    exists: false
                                }
                            }
                        ]
                    }
                ]
            }
        };
        if (global) {
            draftsEnabled = Boolean(global?.versions?.drafts);
            shouldFetchVersions = Boolean(global?.versions);
            versionFetchURL = `${baseURL}/globals/${global.slug}/versions`;
            publishedFetchURL = `${baseURL}/globals/${global.slug}?${_qs.default.stringify(publishedVersionParams)}`;
        }
        if (collection) {
            draftsEnabled = Boolean(collection?.versions?.drafts);
            shouldFetchVersions = Boolean(collection?.versions);
            versionFetchURL = `${baseURL}/${collection.slug}/versions`;
            publishedVersionParams.where.and.push({
                id: {
                    equals: id
                }
            });
            publishedFetchURL = `${baseURL}/${collection.slug}?${_qs.default.stringify(publishedVersionParams)}`;
            if (!id) {
                shouldFetch = false;
            }
            versionParams.where.and.push({
                parent: {
                    equals: id
                }
            });
        }
        if (shouldFetch) {
            let publishedJSON;
            if (draftsEnabled) {
                publishedJSON = await fetch(publishedFetchURL, {
                    credentials: 'include',
                    headers: {
                        'Accept-Language': i18n.language
                    }
                }).then((res)=>res.json());
                if (collection) {
                    publishedJSON = publishedJSON?.docs?.[0];
                }
            }
            if (shouldFetchVersions) {
                versionJSON = await fetch(`${versionFetchURL}?${_qs.default.stringify(versionParams)}`, {
                    credentials: 'include',
                    headers: {
                        'Accept-Language': i18n.language
                    }
                }).then((res)=>res.json());
                if (publishedJSON?.updatedAt) {
                    const newerVersionParams = {
                        ...versionParams,
                        where: {
                            ...versionParams.where,
                            and: [
                                ...versionParams.where.and,
                                {
                                    updatedAt: {
                                        greater_than: publishedJSON?.updatedAt
                                    }
                                }
                            ]
                        }
                    };
                    // Get any newer versions available
                    const newerVersionRes = await fetch(`${versionFetchURL}?${_qs.default.stringify(newerVersionParams)}`, {
                        credentials: 'include',
                        headers: {
                            'Accept-Language': i18n.language
                        }
                    });
                    if (newerVersionRes.status === 200) {
                        unpublishedVersionJSON = await newerVersionRes.json();
                    }
                }
            }
            setPublishedDoc(publishedJSON);
            setVersions(versionJSON);
            setUnpublishedVersions(unpublishedVersionJSON);
        }
    }, [
        i18n,
        global,
        collection,
        id,
        baseURL,
        code
    ]);
    const getDocPermissions = _react.default.useCallback(async ()=>{
        let docAccessURL;
        const params = {
            locale: code || undefined
        };
        if (pluralType === 'globals') {
            docAccessURL = `/globals/${slug}/access`;
        } else if (pluralType === 'collections' && id) {
            docAccessURL = `/${slug}/access/${id}`;
        }
        if (docAccessURL) {
            const res = await fetch(`${serverURL}${api}${docAccessURL}?${_qs.default.stringify(params)}`, {
                credentials: 'include',
                headers: {
                    'Accept-Language': i18n.language
                }
            });
            const json = await res.json();
            setDocPermissions(json);
        } else {
            // fallback to permissions from the entity type
            // (i.e. create has no id)
            setDocPermissions(permissions[pluralType][slug]);
        }
    }, [
        serverURL,
        api,
        pluralType,
        slug,
        id,
        permissions,
        i18n.language,
        code
    ]);
    const getDocPreferences = (0, _react.useCallback)(async ()=>{
        return getPreference(preferencesKey);
    }, [
        getPreference,
        preferencesKey
    ]);
    const setDocFieldPreferences = (0, _react.useCallback)(async (path, fieldPreferences)=>{
        const allPreferences = await getDocPreferences();
        if (preferencesKey) {
            try {
                await setPreference(preferencesKey, {
                    ...allPreferences,
                    fields: {
                        ...allPreferences?.fields || {},
                        [path]: {
                            ...allPreferences?.fields?.[path],
                            ...fieldPreferences
                        }
                    }
                });
            } catch (e) {
                console.error(e);
            }
        }
    }, [
        setPreference,
        preferencesKey,
        getDocPreferences
    ]);
    (0, _react.useEffect)(()=>{
        getVersions();
    }, [
        getVersions
    ]);
    (0, _react.useEffect)(()=>{
        getDocPermissions();
    }, [
        getDocPermissions
    ]);
    const value = {
        id,
        collection,
        docPermissions,
        getDocPermissions,
        getDocPreferences,
        getVersions,
        global,
        preferencesKey,
        publishedDoc,
        setDocFieldPreferences,
        slug,
        unpublishedVersions,
        versions
    };
    return /*#__PURE__*/ _react.default.createElement(Context.Provider, {
        value: value
    }, children);
};

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9hZG1pbi9jb21wb25lbnRzL3V0aWxpdGllcy9Eb2N1bWVudEluZm8vaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBxcyBmcm9tICdxcydcbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgdXNlVHJhbnNsYXRpb24gfSBmcm9tICdyZWFjdC1pMThuZXh0J1xuaW1wb3J0IHsgdXNlUGFyYW1zIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSdcblxuaW1wb3J0IHR5cGUgeyBUeXBlV2l0aFRpbWVzdGFtcHMgfSBmcm9tICcuLi8uLi8uLi8uLi9jb2xsZWN0aW9ucy9jb25maWcvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFBhZ2luYXRlZERvY3MgfSBmcm9tICcuLi8uLi8uLi8uLi9kYXRhYmFzZS90eXBlcydcbmltcG9ydCB0eXBlIHsgVHlwZVdpdGhJRCB9IGZyb20gJy4uLy4uLy4uLy4uL2dsb2JhbHMvY29uZmlnL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBEb2N1bWVudFByZWZlcmVuY2VzIH0gZnJvbSAnLi4vLi4vLi4vLi4vcHJlZmVyZW5jZXMvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFdoZXJlIH0gZnJvbSAnLi4vLi4vLi4vLi4vdHlwZXMnXG5pbXBvcnQgdHlwZSB7IENvbnRleHRUeXBlLCBEb2N1bWVudFBlcm1pc3Npb25zLCBQcm9wcywgVmVyc2lvbiB9IGZyb20gJy4vdHlwZXMnXG5cbmltcG9ydCB7IHVzZUF1dGggfSBmcm9tICcuLi9BdXRoJ1xuaW1wb3J0IHsgdXNlQ29uZmlnIH0gZnJvbSAnLi4vQ29uZmlnJ1xuaW1wb3J0IHsgdXNlTG9jYWxlIH0gZnJvbSAnLi4vTG9jYWxlJ1xuaW1wb3J0IHsgdXNlUHJlZmVyZW5jZXMgfSBmcm9tICcuLi9QcmVmZXJlbmNlcydcblxuY29uc3QgQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30gYXMgQ29udGV4dFR5cGUpXG5cbmV4cG9ydCBjb25zdCB1c2VEb2N1bWVudEluZm8gPSAoKTogQ29udGV4dFR5cGUgPT4gdXNlQ29udGV4dChDb250ZXh0KVxuXG5leHBvcnQgY29uc3QgRG9jdW1lbnRJbmZvUHJvdmlkZXI6IFJlYWN0LkZDPFByb3BzPiA9ICh7XG4gIGlkOiBpZEZyb21Qcm9wcyxcbiAgY2hpbGRyZW4sXG4gIGNvbGxlY3Rpb24sXG4gIGdsb2JhbCxcbiAgaWRGcm9tUGFyYW1zOiBnZXRJREZyb21QYXJhbXMsXG59KSA9PiB7XG4gIGNvbnN0IHsgaWQ6IGlkRnJvbVBhcmFtcyB9ID0gdXNlUGFyYW1zPHsgaWQ6IHN0cmluZyB9PigpXG4gIGNvbnN0IGlkID0gaWRGcm9tUHJvcHMgfHwgKGdldElERnJvbVBhcmFtcyA/IGlkRnJvbVBhcmFtcyA6IG51bGwpXG5cbiAgY29uc3Qge1xuICAgIHJvdXRlczogeyBhcGkgfSxcbiAgICBzZXJ2ZXJVUkwsXG4gIH0gPSB1c2VDb25maWcoKVxuICBjb25zdCB7IGdldFByZWZlcmVuY2UsIHNldFByZWZlcmVuY2UgfSA9IHVzZVByZWZlcmVuY2VzKClcbiAgY29uc3QgeyBpMThuIH0gPSB1c2VUcmFuc2xhdGlvbigpXG4gIGNvbnN0IHsgcGVybWlzc2lvbnMgfSA9IHVzZUF1dGgoKVxuICBjb25zdCB7IGNvZGUgfSA9IHVzZUxvY2FsZSgpXG4gIGNvbnN0IFtwdWJsaXNoZWREb2MsIHNldFB1Ymxpc2hlZERvY10gPSB1c2VTdGF0ZTxUeXBlV2l0aElEICYgVHlwZVdpdGhUaW1lc3RhbXBzPihudWxsKVxuICBjb25zdCBbdmVyc2lvbnMsIHNldFZlcnNpb25zXSA9IHVzZVN0YXRlPFBhZ2luYXRlZERvY3M8VmVyc2lvbj4+KG51bGwpXG4gIGNvbnN0IFt1bnB1Ymxpc2hlZFZlcnNpb25zLCBzZXRVbnB1Ymxpc2hlZFZlcnNpb25zXSA9IHVzZVN0YXRlPFBhZ2luYXRlZERvY3M8VmVyc2lvbj4+KG51bGwpXG4gIGNvbnN0IFtkb2NQZXJtaXNzaW9ucywgc2V0RG9jUGVybWlzc2lvbnNdID0gdXNlU3RhdGU8RG9jdW1lbnRQZXJtaXNzaW9ucz4obnVsbClcblxuICBjb25zdCBiYXNlVVJMID0gYCR7c2VydmVyVVJMfSR7YXBpfWBcbiAgbGV0IHNsdWc6IHN0cmluZ1xuICBsZXQgcGx1cmFsVHlwZTogJ2NvbGxlY3Rpb25zJyB8ICdnbG9iYWxzJ1xuICBsZXQgcHJlZmVyZW5jZXNLZXk6IHN0cmluZ1xuXG4gIGlmIChnbG9iYWwpIHtcbiAgICBzbHVnID0gZ2xvYmFsLnNsdWdcbiAgICBwbHVyYWxUeXBlID0gJ2dsb2JhbHMnXG4gICAgcHJlZmVyZW5jZXNLZXkgPSBgZ2xvYmFsLSR7c2x1Z31gXG4gIH1cblxuICBpZiAoY29sbGVjdGlvbikge1xuICAgIHNsdWcgPSBjb2xsZWN0aW9uLnNsdWdcbiAgICBwbHVyYWxUeXBlID0gJ2NvbGxlY3Rpb25zJ1xuXG4gICAgaWYgKGlkKSB7XG4gICAgICBwcmVmZXJlbmNlc0tleSA9IGBjb2xsZWN0aW9uLSR7c2x1Z30tJHtpZH1gXG4gICAgfVxuICB9XG5cbiAgY29uc3QgZ2V0VmVyc2lvbnMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgbGV0IHZlcnNpb25GZXRjaFVSTFxuICAgIGxldCBwdWJsaXNoZWRGZXRjaFVSTFxuICAgIGxldCBkcmFmdHNFbmFibGVkID0gZmFsc2VcbiAgICBsZXQgc2hvdWxkRmV0Y2hWZXJzaW9ucyA9IGZhbHNlXG4gICAgbGV0IHVucHVibGlzaGVkVmVyc2lvbkpTT04gPSBudWxsXG4gICAgbGV0IHZlcnNpb25KU09OID0gbnVsbFxuICAgIGxldCBzaG91bGRGZXRjaCA9IHRydWVcblxuICAgIGNvbnN0IHZlcnNpb25QYXJhbXMgPSB7XG4gICAgICBkZXB0aDogMCxcbiAgICAgIHdoZXJlOiB7XG4gICAgICAgIGFuZDogW10sXG4gICAgICB9LFxuICAgIH1cblxuICAgIGNvbnN0IHB1Ymxpc2hlZFZlcnNpb25QYXJhbXM6IHsgZGVwdGg6IG51bWJlcjsgbG9jYWxlOiBzdHJpbmc7IHdoZXJlOiBXaGVyZSB9ID0ge1xuICAgICAgZGVwdGg6IDAsXG4gICAgICBsb2NhbGU6IGNvZGUgfHwgdW5kZWZpbmVkLFxuICAgICAgd2hlcmU6IHtcbiAgICAgICAgYW5kOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgb3I6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9zdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgIGVxdWFsczogJ3B1Ymxpc2hlZCcsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF9zdGF0dXM6IHtcbiAgICAgICAgICAgICAgICAgIGV4aXN0czogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbCkge1xuICAgICAgZHJhZnRzRW5hYmxlZCA9IEJvb2xlYW4oZ2xvYmFsPy52ZXJzaW9ucz8uZHJhZnRzKVxuICAgICAgc2hvdWxkRmV0Y2hWZXJzaW9ucyA9IEJvb2xlYW4oZ2xvYmFsPy52ZXJzaW9ucylcbiAgICAgIHZlcnNpb25GZXRjaFVSTCA9IGAke2Jhc2VVUkx9L2dsb2JhbHMvJHtnbG9iYWwuc2x1Z30vdmVyc2lvbnNgXG4gICAgICBwdWJsaXNoZWRGZXRjaFVSTCA9IGAke2Jhc2VVUkx9L2dsb2JhbHMvJHtnbG9iYWwuc2x1Z30/JHtxcy5zdHJpbmdpZnkoXG4gICAgICAgIHB1Ymxpc2hlZFZlcnNpb25QYXJhbXMsXG4gICAgICApfWBcbiAgICB9XG5cbiAgICBpZiAoY29sbGVjdGlvbikge1xuICAgICAgZHJhZnRzRW5hYmxlZCA9IEJvb2xlYW4oY29sbGVjdGlvbj8udmVyc2lvbnM/LmRyYWZ0cylcbiAgICAgIHNob3VsZEZldGNoVmVyc2lvbnMgPSBCb29sZWFuKGNvbGxlY3Rpb24/LnZlcnNpb25zKVxuICAgICAgdmVyc2lvbkZldGNoVVJMID0gYCR7YmFzZVVSTH0vJHtjb2xsZWN0aW9uLnNsdWd9L3ZlcnNpb25zYFxuXG4gICAgICBwdWJsaXNoZWRWZXJzaW9uUGFyYW1zLndoZXJlLmFuZC5wdXNoKHtcbiAgICAgICAgaWQ6IHtcbiAgICAgICAgICBlcXVhbHM6IGlkLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcHVibGlzaGVkRmV0Y2hVUkwgPSBgJHtiYXNlVVJMfS8ke2NvbGxlY3Rpb24uc2x1Z30/JHtxcy5zdHJpbmdpZnkocHVibGlzaGVkVmVyc2lvblBhcmFtcyl9YFxuXG4gICAgICBpZiAoIWlkKSB7XG4gICAgICAgIHNob3VsZEZldGNoID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgdmVyc2lvblBhcmFtcy53aGVyZS5hbmQucHVzaCh7XG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIGVxdWFsczogaWQsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmIChzaG91bGRGZXRjaCkge1xuICAgICAgbGV0IHB1Ymxpc2hlZEpTT05cblxuICAgICAgaWYgKGRyYWZ0c0VuYWJsZWQpIHtcbiAgICAgICAgcHVibGlzaGVkSlNPTiA9IGF3YWl0IGZldGNoKHB1Ymxpc2hlZEZldGNoVVJMLCB7XG4gICAgICAgICAgY3JlZGVudGlhbHM6ICdpbmNsdWRlJyxcbiAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAnQWNjZXB0LUxhbmd1YWdlJzogaTE4bi5sYW5ndWFnZSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KS50aGVuKChyZXMpID0+IHJlcy5qc29uKCkpXG5cbiAgICAgICAgaWYgKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICBwdWJsaXNoZWRKU09OID0gcHVibGlzaGVkSlNPTj8uZG9jcz8uWzBdXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZEZldGNoVmVyc2lvbnMpIHtcbiAgICAgICAgdmVyc2lvbkpTT04gPSBhd2FpdCBmZXRjaChgJHt2ZXJzaW9uRmV0Y2hVUkx9PyR7cXMuc3RyaW5naWZ5KHZlcnNpb25QYXJhbXMpfWAsIHtcbiAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICdBY2NlcHQtTGFuZ3VhZ2UnOiBpMThuLmxhbmd1YWdlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLnRoZW4oKHJlcykgPT4gcmVzLmpzb24oKSlcblxuICAgICAgICBpZiAocHVibGlzaGVkSlNPTj8udXBkYXRlZEF0KSB7XG4gICAgICAgICAgY29uc3QgbmV3ZXJWZXJzaW9uUGFyYW1zID0ge1xuICAgICAgICAgICAgLi4udmVyc2lvblBhcmFtcyxcbiAgICAgICAgICAgIHdoZXJlOiB7XG4gICAgICAgICAgICAgIC4uLnZlcnNpb25QYXJhbXMud2hlcmUsXG4gICAgICAgICAgICAgIGFuZDogW1xuICAgICAgICAgICAgICAgIC4uLnZlcnNpb25QYXJhbXMud2hlcmUuYW5kLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZWRBdDoge1xuICAgICAgICAgICAgICAgICAgICBncmVhdGVyX3RoYW46IHB1Ymxpc2hlZEpTT04/LnVwZGF0ZWRBdCxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gR2V0IGFueSBuZXdlciB2ZXJzaW9ucyBhdmFpbGFibGVcbiAgICAgICAgICBjb25zdCBuZXdlclZlcnNpb25SZXMgPSBhd2FpdCBmZXRjaChcbiAgICAgICAgICAgIGAke3ZlcnNpb25GZXRjaFVSTH0/JHtxcy5zdHJpbmdpZnkobmV3ZXJWZXJzaW9uUGFyYW1zKX1gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgJ0FjY2VwdC1MYW5ndWFnZSc6IGkxOG4ubGFuZ3VhZ2UsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIClcblxuICAgICAgICAgIGlmIChuZXdlclZlcnNpb25SZXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHVucHVibGlzaGVkVmVyc2lvbkpTT04gPSBhd2FpdCBuZXdlclZlcnNpb25SZXMuanNvbigpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHNldFB1Ymxpc2hlZERvYyhwdWJsaXNoZWRKU09OKVxuICAgICAgc2V0VmVyc2lvbnModmVyc2lvbkpTT04pXG4gICAgICBzZXRVbnB1Ymxpc2hlZFZlcnNpb25zKHVucHVibGlzaGVkVmVyc2lvbkpTT04pXG4gICAgfVxuICB9LCBbaTE4biwgZ2xvYmFsLCBjb2xsZWN0aW9uLCBpZCwgYmFzZVVSTCwgY29kZV0pXG5cbiAgY29uc3QgZ2V0RG9jUGVybWlzc2lvbnMgPSBSZWFjdC51c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgbGV0IGRvY0FjY2Vzc1VSTDogc3RyaW5nXG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgbG9jYWxlOiBjb2RlIHx8IHVuZGVmaW5lZCxcbiAgICB9XG4gICAgaWYgKHBsdXJhbFR5cGUgPT09ICdnbG9iYWxzJykge1xuICAgICAgZG9jQWNjZXNzVVJMID0gYC9nbG9iYWxzLyR7c2x1Z30vYWNjZXNzYFxuICAgIH0gZWxzZSBpZiAocGx1cmFsVHlwZSA9PT0gJ2NvbGxlY3Rpb25zJyAmJiBpZCkge1xuICAgICAgZG9jQWNjZXNzVVJMID0gYC8ke3NsdWd9L2FjY2Vzcy8ke2lkfWBcbiAgICB9XG5cbiAgICBpZiAoZG9jQWNjZXNzVVJMKSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtzZXJ2ZXJVUkx9JHthcGl9JHtkb2NBY2Nlc3NVUkx9PyR7cXMuc3RyaW5naWZ5KHBhcmFtcyl9YCwge1xuICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgJ0FjY2VwdC1MYW5ndWFnZSc6IGkxOG4ubGFuZ3VhZ2UsXG4gICAgICAgIH0sXG4gICAgICB9KVxuICAgICAgY29uc3QganNvbiA9IGF3YWl0IHJlcy5qc29uKClcbiAgICAgIHNldERvY1Blcm1pc3Npb25zKGpzb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhbGxiYWNrIHRvIHBlcm1pc3Npb25zIGZyb20gdGhlIGVudGl0eSB0eXBlXG4gICAgICAvLyAoaS5lLiBjcmVhdGUgaGFzIG5vIGlkKVxuICAgICAgc2V0RG9jUGVybWlzc2lvbnMocGVybWlzc2lvbnNbcGx1cmFsVHlwZV1bc2x1Z10pXG4gICAgfVxuICB9LCBbc2VydmVyVVJMLCBhcGksIHBsdXJhbFR5cGUsIHNsdWcsIGlkLCBwZXJtaXNzaW9ucywgaTE4bi5sYW5ndWFnZSwgY29kZV0pXG5cbiAgY29uc3QgZ2V0RG9jUHJlZmVyZW5jZXMgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgcmV0dXJuIGdldFByZWZlcmVuY2U8RG9jdW1lbnRQcmVmZXJlbmNlcz4ocHJlZmVyZW5jZXNLZXkpXG4gIH0sIFtnZXRQcmVmZXJlbmNlLCBwcmVmZXJlbmNlc0tleV0pXG5cbiAgY29uc3Qgc2V0RG9jRmllbGRQcmVmZXJlbmNlcyA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlWydzZXREb2NGaWVsZFByZWZlcmVuY2VzJ10+KFxuICAgIGFzeW5jIChwYXRoLCBmaWVsZFByZWZlcmVuY2VzKSA9PiB7XG4gICAgICBjb25zdCBhbGxQcmVmZXJlbmNlcyA9IGF3YWl0IGdldERvY1ByZWZlcmVuY2VzKClcblxuICAgICAgaWYgKHByZWZlcmVuY2VzS2V5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgc2V0UHJlZmVyZW5jZShwcmVmZXJlbmNlc0tleSwge1xuICAgICAgICAgICAgLi4uYWxsUHJlZmVyZW5jZXMsXG4gICAgICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgICAgLi4uKGFsbFByZWZlcmVuY2VzPy5maWVsZHMgfHwge30pLFxuICAgICAgICAgICAgICBbcGF0aF06IHtcbiAgICAgICAgICAgICAgICAuLi5hbGxQcmVmZXJlbmNlcz8uZmllbGRzPy5bcGF0aF0sXG4gICAgICAgICAgICAgICAgLi4uZmllbGRQcmVmZXJlbmNlcyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgW3NldFByZWZlcmVuY2UsIHByZWZlcmVuY2VzS2V5LCBnZXREb2NQcmVmZXJlbmNlc10sXG4gIClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGdldFZlcnNpb25zKClcbiAgfSwgW2dldFZlcnNpb25zXSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGdldERvY1Blcm1pc3Npb25zKClcbiAgfSwgW2dldERvY1Blcm1pc3Npb25zXSlcblxuICBjb25zdCB2YWx1ZTogQ29udGV4dFR5cGUgPSB7XG4gICAgaWQsXG4gICAgY29sbGVjdGlvbixcbiAgICBkb2NQZXJtaXNzaW9ucyxcbiAgICBnZXREb2NQZXJtaXNzaW9ucyxcbiAgICBnZXREb2NQcmVmZXJlbmNlcyxcbiAgICBnZXRWZXJzaW9ucyxcbiAgICBnbG9iYWwsXG4gICAgcHJlZmVyZW5jZXNLZXksXG4gICAgcHVibGlzaGVkRG9jLFxuICAgIHNldERvY0ZpZWxkUHJlZmVyZW5jZXMsXG4gICAgc2x1ZyxcbiAgICB1bnB1Ymxpc2hlZFZlcnNpb25zLFxuICAgIHZlcnNpb25zLFxuICB9XG5cbiAgcmV0dXJuIDxDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt2YWx1ZX0+e2NoaWxkcmVufTwvQ29udGV4dC5Qcm92aWRlcj5cbn1cbiJdLCJuYW1lcyI6WyJ1c2VEb2N1bWVudEluZm8iLCJEb2N1bWVudEluZm9Qcm92aWRlciIsIkNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsImlkIiwiaWRGcm9tUHJvcHMiLCJjaGlsZHJlbiIsImNvbGxlY3Rpb24iLCJnbG9iYWwiLCJpZEZyb21QYXJhbXMiLCJnZXRJREZyb21QYXJhbXMiLCJ1c2VQYXJhbXMiLCJyb3V0ZXMiLCJhcGkiLCJzZXJ2ZXJVUkwiLCJ1c2VDb25maWciLCJnZXRQcmVmZXJlbmNlIiwic2V0UHJlZmVyZW5jZSIsInVzZVByZWZlcmVuY2VzIiwiaTE4biIsInVzZVRyYW5zbGF0aW9uIiwicGVybWlzc2lvbnMiLCJ1c2VBdXRoIiwiY29kZSIsInVzZUxvY2FsZSIsInB1Ymxpc2hlZERvYyIsInNldFB1Ymxpc2hlZERvYyIsInVzZVN0YXRlIiwidmVyc2lvbnMiLCJzZXRWZXJzaW9ucyIsInVucHVibGlzaGVkVmVyc2lvbnMiLCJzZXRVbnB1Ymxpc2hlZFZlcnNpb25zIiwiZG9jUGVybWlzc2lvbnMiLCJzZXREb2NQZXJtaXNzaW9ucyIsImJhc2VVUkwiLCJzbHVnIiwicGx1cmFsVHlwZSIsInByZWZlcmVuY2VzS2V5IiwiZ2V0VmVyc2lvbnMiLCJ1c2VDYWxsYmFjayIsInZlcnNpb25GZXRjaFVSTCIsInB1Ymxpc2hlZEZldGNoVVJMIiwiZHJhZnRzRW5hYmxlZCIsInNob3VsZEZldGNoVmVyc2lvbnMiLCJ1bnB1Ymxpc2hlZFZlcnNpb25KU09OIiwidmVyc2lvbkpTT04iLCJzaG91bGRGZXRjaCIsInZlcnNpb25QYXJhbXMiLCJkZXB0aCIsIndoZXJlIiwiYW5kIiwicHVibGlzaGVkVmVyc2lvblBhcmFtcyIsImxvY2FsZSIsInVuZGVmaW5lZCIsIm9yIiwiX3N0YXR1cyIsImVxdWFscyIsImV4aXN0cyIsIkJvb2xlYW4iLCJkcmFmdHMiLCJxcyIsInN0cmluZ2lmeSIsInB1c2giLCJwYXJlbnQiLCJwdWJsaXNoZWRKU09OIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsImhlYWRlcnMiLCJsYW5ndWFnZSIsInRoZW4iLCJyZXMiLCJqc29uIiwiZG9jcyIsInVwZGF0ZWRBdCIsIm5ld2VyVmVyc2lvblBhcmFtcyIsImdyZWF0ZXJfdGhhbiIsIm5ld2VyVmVyc2lvblJlcyIsInN0YXR1cyIsImdldERvY1Blcm1pc3Npb25zIiwiUmVhY3QiLCJkb2NBY2Nlc3NVUkwiLCJwYXJhbXMiLCJnZXREb2NQcmVmZXJlbmNlcyIsInNldERvY0ZpZWxkUHJlZmVyZW5jZXMiLCJwYXRoIiwiZmllbGRQcmVmZXJlbmNlcyIsImFsbFByZWZlcmVuY2VzIiwiZmllbGRzIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsInVzZUVmZmVjdCIsInZhbHVlIiwiUHJvdmlkZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0lBbUJhQSxlQUFlO2VBQWZBOztJQUVBQyxvQkFBb0I7ZUFBcEJBOzs7MkRBckJFOytEQUNvRTs4QkFDcEQ7Z0NBQ0w7c0JBU0Y7d0JBQ0U7d0JBQ0E7NkJBQ0s7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUUvQixNQUFNQyx3QkFBVUMsSUFBQUEsb0JBQWEsRUFBQyxDQUFDO0FBRXhCLE1BQU1ILGtCQUFrQixJQUFtQkksSUFBQUEsaUJBQVUsRUFBQ0Y7QUFFdEQsTUFBTUQsdUJBQXdDLENBQUMsRUFDcERJLElBQUlDLFdBQVcsRUFDZkMsUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLE1BQU0sRUFDTkMsY0FBY0MsZUFBZSxFQUM5QjtJQUNDLE1BQU0sRUFBRU4sSUFBSUssWUFBWSxFQUFFLEdBQUdFLElBQUFBLHlCQUFTO0lBQ3RDLE1BQU1QLEtBQUtDLGVBQWdCSyxDQUFBQSxrQkFBa0JELGVBQWUsSUFBRztJQUUvRCxNQUFNLEVBQ0pHLFFBQVEsRUFBRUMsR0FBRyxFQUFFLEVBQ2ZDLFNBQVMsRUFDVixHQUFHQyxJQUFB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