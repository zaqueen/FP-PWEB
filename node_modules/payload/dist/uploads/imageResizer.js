"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, /**
 * For the provided image sizes, handle the resizing and the transforms
 * (format, trim, etc.) of each requested image size and return the result object.
 * This only handles the image sizes. The transforms of the original image
 * are handled in {@link ./generateFileData.ts}.
 *
 * The image will be resized according to the provided
 * resize config. If no image sizes are requested, the resolved data will be empty.
 * For every image that dos not need to be resized, an result object with `null`
 * parameters will be returned.
 *
 * @param resizeConfig - the resize config
 * @returns the result of the resize operation(s)
 */ "default", {
    enumerable: true,
    get: function() {
        return resizeAndTransformImageSizes;
    }
});
const _filetype = require("file-type");
const _fs = /*#__PURE__*/ _interop_require_default(require("fs"));
const _sanitizefilename = /*#__PURE__*/ _interop_require_default(require("sanitize-filename"));
const _sharp = /*#__PURE__*/ _interop_require_default(require("sharp"));
const _isNumber = require("../utilities/isNumber");
const _fileExists = /*#__PURE__*/ _interop_require_default(require("./fileExists"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
/**
 * Sanitize the image name and extract the extension from the source image
 *
 * @param sourceImage - the source image
 * @returns the sanitized name and extension
 */ const getSanitizedImageData = (sourceImage)=>{
    const extension = sourceImage.split('.').pop();
    const name = (0, _sanitizefilename.default)(sourceImage.substring(0, sourceImage.lastIndexOf('.')) || sourceImage);
    return {
        name,
        ext: extension
    };
};
/**
 * Create a new image name based on the output image name, the dimensions and
 * the extension.
 *
 * Ignore the fact that duplicate names could happen if the there is one
 * size with `width AND height` and one with only `height OR width`. Because
 * space is expensive, we will reuse the same image for both sizes.
 *
 * @param outputImageName - the sanitized image name
 * @param bufferInfo - the buffer info
 * @param extension - the extension to use
 * @returns the new image name that is not taken
 */ const createImageName = (outputImageName, { height, width }, extension)=>`${outputImageName}-${width}x${height}.${extension}`;
/**
 * Create the result object for the image resize operation based on the
 * provided parameters. If the name is not provided, an empty result object
 * is returned.
 *
 * @param name - the name of the image
 * @param filename - the filename of the image
 * @param width - the width of the image
 * @param height - the height of the image
 * @param filesize - the filesize of the image
 * @param mimeType - the mime type of the image
 * @param sizesToSave - the sizes to save
 * @returns the result object
 */ const createResult = (name, filename = null, width = null, height = null, filesize = null, mimeType = null, sizesToSave = [])=>({
        sizeData: {
            [name]: {
                filename,
                filesize,
                height,
                mimeType,
                width
            }
        },
        sizesToSave
    });
/**
 * Check if the image needs to be resized according to the requested dimensions
 * and the original image size. If the resize options withoutEnlargement or withoutReduction are provided,
 * the image will be resized regardless of the requested dimensions, given that the
 * width or height to be resized is provided.
 *
 * @param resizeConfig - object containing the requested dimensions and resize options
 * @param original - the original image size
 * @returns true if resizing is not needed, false otherwise
 */ const preventResize = ({ height: desiredHeight, width: desiredWidth, withoutEnlargement, withoutReduction }, original)=>{
    // default is to allow reduction
    if (withoutReduction !== undefined) {
        return false // needs resize
        ;
    }
    // default is to prevent enlargement
    if (withoutEnlargement !== undefined) {
        return false // needs resize
        ;
    }
    const isWidthOrHeightNotDefined = !desiredHeight || !desiredWidth;
    if (isWidthOrHeightNotDefined) {
        // If width and height are not defined, it means there is a format conversion
        // and the image needs to be "resized" (transformed).
        return false // needs resize
        ;
    }
    const hasInsufficientWidth = desiredWidth > original.width;
    const hasInsufficientHeight = desiredHeight > original.height;
    if (hasInsufficientWidth && hasInsufficientHeight) {
        // doesn't need resize - prevent enlargement. This should only happen if both width and height are insufficient.
        // if only one dimension is insufficient and the other is sufficient, resizing needs to happen, as the image
        // should be resized to the sufficient dimension.
        return true // do not create a new size
        ;
    }
    return false // needs resize
    ;
};
/**
 * Check if the image should be passed directly to sharp without payload adjusting properties.
 *
 * @param resizeConfig - object containing the requested dimensions and resize options
 * @param original - the original image size
 * @returns true if the image should passed directly to sharp
 */ const applyPayloadAdjustments = ({ fit, height, width, withoutEnlargement, withoutReduction }, original)=>{
    if (fit === 'contain' || fit === 'inside') return false;
    if (!(0, _isNumber.isNumber)(height) && !(0, _isNumber.isNumber)(width)) return false;
    const targetAspectRatio = width / height;
    const originalAspectRatio = original.width / original.height;
    if (originalAspectRatio === targetAspectRatio) return false;
    const skipEnlargement = withoutEnlargement && (original.height < height || original.width < width);
    const skipReduction = withoutReduction && (original.height > height || original.width > width);
    if (skipEnlargement || skipReduction) return false;
    return true;
};
/**
 * Sanitize the resize config. If the resize config has the `withoutReduction`
 * property set to true, the `fit` and `position` properties will be set to `contain`
 * and `top left` respectively.
 *
 * @param resizeConfig - the resize config
 * @returns a sanitized resize config
 */ const sanitizeResizeConfig = (resizeConfig)=>{
    if (resizeConfig.withoutReduction) {
        return {
            ...resizeConfig,
            // Why fit `contain` should also be set to https://github.com/lovell/sharp/issues/3595
            fit: resizeConfig?.fit || 'contain',
            position: resizeConfig?.position || 'left top'
        };
    }
    return resizeConfig;
};
async function resizeAndTransformImageSizes({ config, dimensions, file, mimeType, req, savedFilename, staticPath }) {
    const { imageSizes } = config.upload;
    // Noting to resize here so return as early as possible
    if (!imageSizes) return {
        sizeData: {},
        sizesToSave: []
    };
    const sharpBase = (0, _sharp.default)(file.tempFilePath || file.data).rotate() // pass rotate() to auto-rotate based on EXIF data. https://github.com/payloadcms/payload/pull/3081
    ;
    const results = await Promise.all(imageSizes.map(async (imageResizeConfig)=>{
        imageResizeConfig = sanitizeResizeConfig(imageResizeConfig);
        // This checks if a resize should happen. If not, the resized image will be
        // skipped COMPLETELY and thus will not be included in the resulting images.
        // All further format/trim options will thus be skipped as well.
        if (preventResize(imageResizeConfig, dimensions)) {
            return createResult(imageResizeConfig.name);
        }
        const imageToResize = sharpBase.clone();
        let resized = imageToResize.resize(imageResizeConfig);
        if (req.query?.uploadEdits?.focalPoint && applyPayloadAdjustments(imageResizeConfig, dimensions)) {
            const { height: resizeHeight, width: resizeWidth } = imageResizeConfig;
            const resizeAspectRatio = resizeWidth / resizeHeight;
            const originalAspectRatio = dimensions.width / dimensions.height;
            const prioritizeHeight = resizeAspectRatio < originalAspectRatio;
            // Scale the image up or down to fit the resize dimensions
            const scaledImage = imageToResize.resize({
                height: prioritizeHeight ? resizeHeight : null,
                width: prioritizeHeight ? null : resizeWidth
            });
            const { info: scaledImageInfo } = await scaledImage.toBuffer({
                resolveWithObject: true
            });
            // Focal point adjustments
            const focalPoint = {
                x: (0, _isNumber.isNumber)(req.query.uploadEdits.focalPoint?.x) ? req.query.uploadEdits.focalPoint.x : 50,
                y: (0, _isNumber.isNumber)(req.query.uploadEdits.focalPoint?.y) ? req.query.uploadEdits.focalPoint.y : 50
            };
            const safeResizeWidth = resizeWidth ?? scaledImageInfo.width;
            const maxOffsetX = scaledImageInfo.width - safeResizeWidth;
            const leftFocalEdge = Math.round(scaledImageInfo.width * (focalPoint.x / 100) - safeResizeWidth / 2);
            const safeOffsetX = Math.min(Math.max(0, leftFocalEdge), maxOffsetX);
            const safeResizeHeight = resizeHeight ?? scaledImageInfo.height;
            const maxOffsetY = scaledImageInfo.height - safeResizeHeight;
            const topFocalEdge = Math.round(scaledImageInfo.height * (focalPoint.y / 100) - safeResizeHeight / 2);
            const safeOffsetY = Math.min(Math.max(0, topFocalEdge), maxOffsetY);
            // extract the focal area from the scaled image
            resized = scaledImage.extract({
                height: safeResizeHeight,
                left: safeOffsetX,
                top: safeOffsetY,
                width: safeResizeWidth
            });
        }
        if (imageResizeConfig.formatOptions) {
            resized = resized.toFormat(imageResizeConfig.formatOptions.format, imageResizeConfig.formatOptions.options);
        }
        if (imageResizeConfig.trimOptions) {
            resized = resized.trim(imageResizeConfig.trimOptions);
        }
        const { data: bufferData, info: bufferInfo } = await resized.toBuffer({
            resolveWithObject: true
        });
        const sanitizedImage = getSanitizedImageData(savedFilename);
        if (req.payloadUploadSizes) {
            req.payloadUploadSizes[imageResizeConfig.name] = bufferData;
        }
        const mimeInfo = await (0, _filetype.fromBuffer)(bufferData);
        const imageNameWithDimensions = createImageName(sanitizedImage.name, bufferInfo, mimeInfo?.ext || sanitizedImage.ext);
        const imagePath = `${staticPath}/${imageNameWithDimensions}`;
        if (await (0, _fileExists.default)(imagePath)) {
            try {
                _fs.default.unlinkSync(imagePath);
            } catch  {
            // Ignore unlink errors
            }
        }
        const { height, size, width } = bufferInfo;
        return createResult(imageResizeConfig.name, imageNameWithDimensions, width, height, size, mimeInfo?.mime || mimeType, [
            {
                buffer: bufferData,
                path: imagePath
            }
        ]);
    }));
    return results.reduce((acc, result)=>{
        Object.assign(acc.sizeData, result.sizeData);
        acc.sizesToSave.push(...result.sizesToSave);
        return acc;
    }, {
        sizeData: {},
        sizesToSave: []
    });
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91cGxvYWRzL2ltYWdlUmVzaXplci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IFVwbG9hZGVkRmlsZSB9IGZyb20gJ2V4cHJlc3MtZmlsZXVwbG9hZCdcbmltcG9ydCB0eXBlIHsgT3V0cHV0SW5mbyB9IGZyb20gJ3NoYXJwJ1xuXG5pbXBvcnQgeyBmcm9tQnVmZmVyIH0gZnJvbSAnZmlsZS10eXBlJ1xuaW1wb3J0IGZzIGZyb20gJ2ZzJ1xuaW1wb3J0IHNhbml0aXplIGZyb20gJ3Nhbml0aXplLWZpbGVuYW1lJ1xuaW1wb3J0IHNoYXJwIGZyb20gJ3NoYXJwJ1xuXG5pbXBvcnQgdHlwZSB7IFVwbG9hZEVkaXRzIH0gZnJvbSAnLi4vYWRtaW4vY29tcG9uZW50cy92aWV3cy9jb2xsZWN0aW9ucy9FZGl0L3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBTYW5pdGl6ZWRDb2xsZWN0aW9uQ29uZmlnIH0gZnJvbSAnLi4vY29sbGVjdGlvbnMvY29uZmlnL3R5cGVzJ1xuaW1wb3J0IHR5cGUgeyBQYXlsb2FkUmVxdWVzdCB9IGZyb20gJy4uL2V4cHJlc3MvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IEZpbGVTaXplLCBGaWxlU2l6ZXMsIEZpbGVUb1NhdmUsIEltYWdlU2l6ZSwgUHJvYmVkSW1hZ2VTaXplIH0gZnJvbSAnLi90eXBlcydcblxuaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICcuLi91dGlsaXRpZXMvaXNOdW1iZXInXG5pbXBvcnQgZmlsZUV4aXN0cyBmcm9tICcuL2ZpbGVFeGlzdHMnXG5cbnR5cGUgUmVzaXplQXJncyA9IHtcbiAgY29uZmlnOiBTYW5pdGl6ZWRDb2xsZWN0aW9uQ29uZmlnXG4gIGRpbWVuc2lvbnM6IFByb2JlZEltYWdlU2l6ZVxuICBmaWxlOiBVcGxvYWRlZEZpbGVcbiAgbWltZVR5cGU6IHN0cmluZ1xuICByZXE6IFBheWxvYWRSZXF1ZXN0ICYge1xuICAgIHF1ZXJ5Pzoge1xuICAgICAgdXBsb2FkRWRpdHM/OiBVcGxvYWRFZGl0c1xuICAgIH1cbiAgfVxuICBzYXZlZEZpbGVuYW1lOiBzdHJpbmdcbiAgc3RhdGljUGF0aDogc3RyaW5nXG59XG5cbi8qKiBSZXN1bHQgZnJvbSByZXNpemluZyBhbmQgdHJhbnNmb3JtaW5nIHRoZSByZXF1ZXN0ZWQgaW1hZ2Ugc2l6ZXMgKi9cbnR5cGUgSW1hZ2VTaXplc1Jlc3VsdCA9IHtcbiAgc2l6ZURhdGE6IEZpbGVTaXplc1xuICBzaXplc1RvU2F2ZTogRmlsZVRvU2F2ZVtdXG59XG5cbnR5cGUgU2FuaXRpemVkSW1hZ2VEYXRhID0ge1xuICBleHQ6IHN0cmluZ1xuICBuYW1lOiBzdHJpbmdcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgaW1hZ2UgbmFtZSBhbmQgZXh0cmFjdCB0aGUgZXh0ZW5zaW9uIGZyb20gdGhlIHNvdXJjZSBpbWFnZVxuICpcbiAqIEBwYXJhbSBzb3VyY2VJbWFnZSAtIHRoZSBzb3VyY2UgaW1hZ2VcbiAqIEByZXR1cm5zIHRoZSBzYW5pdGl6ZWQgbmFtZSBhbmQgZXh0ZW5zaW9uXG4gKi9cbmNvbnN0IGdldFNhbml0aXplZEltYWdlRGF0YSA9IChzb3VyY2VJbWFnZTogc3RyaW5nKTogU2FuaXRpemVkSW1hZ2VEYXRhID0+IHtcbiAgY29uc3QgZXh0ZW5zaW9uID0gc291cmNlSW1hZ2Uuc3BsaXQoJy4nKS5wb3AoKVxuICBjb25zdCBuYW1lID0gc2FuaXRpemUoc291cmNlSW1hZ2Uuc3Vic3RyaW5nKDAsIHNvdXJjZUltYWdlLmxhc3RJbmRleE9mKCcuJykpIHx8IHNvdXJjZUltYWdlKVxuICByZXR1cm4geyBuYW1lLCBleHQ6IGV4dGVuc2lvbiB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGltYWdlIG5hbWUgYmFzZWQgb24gdGhlIG91dHB1dCBpbWFnZSBuYW1lLCB0aGUgZGltZW5zaW9ucyBhbmRcbiAqIHRoZSBleHRlbnNpb24uXG4gKlxuICogSWdub3JlIHRoZSBmYWN0IHRoYXQgZHVwbGljYXRlIG5hbWVzIGNvdWxkIGhhcHBlbiBpZiB0aGUgdGhlcmUgaXMgb25lXG4gKiBzaXplIHdpdGggYHdpZHRoIEFORCBoZWlnaHRgIGFuZCBvbmUgd2l0aCBvbmx5IGBoZWlnaHQgT1Igd2lkdGhgLiBCZWNhdXNlXG4gKiBzcGFjZSBpcyBleHBlbnNpdmUsIHdlIHdpbGwgcmV1c2UgdGhlIHNhbWUgaW1hZ2UgZm9yIGJvdGggc2l6ZXMuXG4gKlxuICogQHBhcmFtIG91dHB1dEltYWdlTmFtZSAtIHRoZSBzYW5pdGl6ZWQgaW1hZ2UgbmFtZVxuICogQHBhcmFtIGJ1ZmZlckluZm8gLSB0aGUgYnVmZmVyIGluZm9cbiAqIEBwYXJhbSBleHRlbnNpb24gLSB0aGUgZXh0ZW5zaW9uIHRvIHVzZVxuICogQHJldHVybnMgdGhlIG5ldyBpbWFnZSBuYW1lIHRoYXQgaXMgbm90IHRha2VuXG4gKi9cbmNvbnN0IGNyZWF0ZUltYWdlTmFtZSA9IChcbiAgb3V0cHV0SW1hZ2VOYW1lOiBzdHJpbmcsXG4gIHsgaGVpZ2h0LCB3aWR0aCB9OiBPdXRwdXRJbmZvLFxuICBleHRlbnNpb246IHN0cmluZyxcbikgPT4gYCR7b3V0cHV0SW1hZ2VOYW1lfS0ke3dpZHRofXgke2hlaWdodH0uJHtleHRlbnNpb259YFxuXG4vKipcbiAqIENyZWF0ZSB0aGUgcmVzdWx0IG9iamVjdCBmb3IgdGhlIGltYWdlIHJlc2l6ZSBvcGVyYXRpb24gYmFzZWQgb24gdGhlXG4gKiBwcm92aWRlZCBwYXJhbWV0ZXJzLiBJZiB0aGUgbmFtZSBpcyBub3QgcHJvdmlkZWQsIGFuIGVtcHR5IHJlc3VsdCBvYmplY3RcbiAqIGlzIHJldHVybmVkLlxuICpcbiAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gZmlsZW5hbWUgLSB0aGUgZmlsZW5hbWUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gd2lkdGggLSB0aGUgd2lkdGggb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gaGVpZ2h0IC0gdGhlIGhlaWdodCBvZiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSBmaWxlc2l6ZSAtIHRoZSBmaWxlc2l6ZSBvZiB0aGUgaW1hZ2VcbiAqIEBwYXJhbSBtaW1lVHlwZSAtIHRoZSBtaW1lIHR5cGUgb2YgdGhlIGltYWdlXG4gKiBAcGFyYW0gc2l6ZXNUb1NhdmUgLSB0aGUgc2l6ZXMgdG8gc2F2ZVxuICogQHJldHVybnMgdGhlIHJlc3VsdCBvYmplY3RcbiAqL1xuY29uc3QgY3JlYXRlUmVzdWx0ID0gKFxuICBuYW1lOiBzdHJpbmcsXG4gIGZpbGVuYW1lOiBGaWxlU2l6ZVsnZmlsZW5hbWUnXSA9IG51bGwsXG4gIHdpZHRoOiBGaWxlU2l6ZVsnd2lkdGgnXSA9IG51bGwsXG4gIGhlaWdodDogRmlsZVNpemVbJ2hlaWdodCddID0gbnVsbCxcbiAgZmlsZXNpemU6IEZpbGVTaXplWydmaWxlc2l6ZSddID0gbnVsbCxcbiAgbWltZVR5cGU6IEZpbGVTaXplWydtaW1lVHlwZSddID0gbnVsbCxcbiAgc2l6ZXNUb1NhdmU6IEZpbGVUb1NhdmVbXSA9IFtdLFxuKTogSW1hZ2VTaXplc1Jlc3VsdCA9PiAoe1xuICBzaXplRGF0YToge1xuICAgIFtuYW1lXToge1xuICAgICAgZmlsZW5hbWUsXG4gICAgICBmaWxlc2l6ZSxcbiAgICAgIGhlaWdodCxcbiAgICAgIG1pbWVUeXBlLFxuICAgICAgd2lkdGgsXG4gICAgfSxcbiAgfSxcbiAgc2l6ZXNUb1NhdmUsXG59KVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBpbWFnZSBuZWVkcyB0byBiZSByZXNpemVkIGFjY29yZGluZyB0byB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnNcbiAqIGFuZCB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZS4gSWYgdGhlIHJlc2l6ZSBvcHRpb25zIHdpdGhvdXRFbmxhcmdlbWVudCBvciB3aXRob3V0UmVkdWN0aW9uIGFyZSBwcm92aWRlZCxcbiAqIHRoZSBpbWFnZSB3aWxsIGJlIHJlc2l6ZWQgcmVnYXJkbGVzcyBvZiB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnMsIGdpdmVuIHRoYXQgdGhlXG4gKiB3aWR0aCBvciBoZWlnaHQgdG8gYmUgcmVzaXplZCBpcyBwcm92aWRlZC5cbiAqXG4gKiBAcGFyYW0gcmVzaXplQ29uZmlnIC0gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3RlZCBkaW1lbnNpb25zIGFuZCByZXNpemUgb3B0aW9uc1xuICogQHBhcmFtIG9yaWdpbmFsIC0gdGhlIG9yaWdpbmFsIGltYWdlIHNpemVcbiAqIEByZXR1cm5zIHRydWUgaWYgcmVzaXppbmcgaXMgbm90IG5lZWRlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmNvbnN0IHByZXZlbnRSZXNpemUgPSAoXG4gIHsgaGVpZ2h0OiBkZXNpcmVkSGVpZ2h0LCB3aWR0aDogZGVzaXJlZFdpZHRoLCB3aXRob3V0RW5sYXJnZW1lbnQsIHdpdGhvdXRSZWR1Y3Rpb24gfTogSW1hZ2VTaXplLFxuICBvcmlnaW5hbDogUHJvYmVkSW1hZ2VTaXplLFxuKTogYm9vbGVhbiA9PiB7XG4gIC8vIGRlZmF1bHQgaXMgdG8gYWxsb3cgcmVkdWN0aW9uXG4gIGlmICh3aXRob3V0UmVkdWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmFsc2UgLy8gbmVlZHMgcmVzaXplXG4gIH1cblxuICAvLyBkZWZhdWx0IGlzIHRvIHByZXZlbnQgZW5sYXJnZW1lbnRcbiAgaWYgKHdpdGhvdXRFbmxhcmdlbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlIC8vIG5lZWRzIHJlc2l6ZVxuICB9XG5cbiAgY29uc3QgaXNXaWR0aE9ySGVpZ2h0Tm90RGVmaW5lZCA9ICFkZXNpcmVkSGVpZ2h0IHx8ICFkZXNpcmVkV2lkdGhcbiAgaWYgKGlzV2lkdGhPckhlaWdodE5vdERlZmluZWQpIHtcbiAgICAvLyBJZiB3aWR0aCBhbmQgaGVpZ2h0IGFyZSBub3QgZGVmaW5lZCwgaXQgbWVhbnMgdGhlcmUgaXMgYSBmb3JtYXQgY29udmVyc2lvblxuICAgIC8vIGFuZCB0aGUgaW1hZ2UgbmVlZHMgdG8gYmUgXCJyZXNpemVkXCIgKHRyYW5zZm9ybWVkKS5cbiAgICByZXR1cm4gZmFsc2UgLy8gbmVlZHMgcmVzaXplXG4gIH1cblxuICBjb25zdCBoYXNJbnN1ZmZpY2llbnRXaWR0aCA9IGRlc2lyZWRXaWR0aCA+IG9yaWdpbmFsLndpZHRoXG4gIGNvbnN0IGhhc0luc3VmZmljaWVudEhlaWdodCA9IGRlc2lyZWRIZWlnaHQgPiBvcmlnaW5hbC5oZWlnaHRcbiAgaWYgKGhhc0luc3VmZmljaWVudFdpZHRoICYmIGhhc0luc3VmZmljaWVudEhlaWdodCkge1xuICAgIC8vIGRvZXNuJ3QgbmVlZCByZXNpemUgLSBwcmV2ZW50IGVubGFyZ2VtZW50LiBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiBib3RoIHdpZHRoIGFuZCBoZWlnaHQgYXJlIGluc3VmZmljaWVudC5cbiAgICAvLyBpZiBvbmx5IG9uZSBkaW1lbnNpb24gaXMgaW5zdWZmaWNpZW50IGFuZCB0aGUgb3RoZXIgaXMgc3VmZmljaWVudCwgcmVzaXppbmcgbmVlZHMgdG8gaGFwcGVuLCBhcyB0aGUgaW1hZ2VcbiAgICAvLyBzaG91bGQgYmUgcmVzaXplZCB0byB0aGUgc3VmZmljaWVudCBkaW1lbnNpb24uXG4gICAgcmV0dXJuIHRydWUgLy8gZG8gbm90IGNyZWF0ZSBhIG5ldyBzaXplXG4gIH1cblxuICByZXR1cm4gZmFsc2UgLy8gbmVlZHMgcmVzaXplXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGltYWdlIHNob3VsZCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gc2hhcnAgd2l0aG91dCBwYXlsb2FkIGFkanVzdGluZyBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSByZXNpemVDb25maWcgLSBvYmplY3QgY29udGFpbmluZyB0aGUgcmVxdWVzdGVkIGRpbWVuc2lvbnMgYW5kIHJlc2l6ZSBvcHRpb25zXG4gKiBAcGFyYW0gb3JpZ2luYWwgLSB0aGUgb3JpZ2luYWwgaW1hZ2Ugc2l6ZVxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgaW1hZ2Ugc2hvdWxkIHBhc3NlZCBkaXJlY3RseSB0byBzaGFycFxuICovXG5jb25zdCBhcHBseVBheWxvYWRBZGp1c3RtZW50cyA9IChcbiAgeyBmaXQsIGhlaWdodCwgd2lkdGgsIHdpdGhvdXRFbmxhcmdlbWVudCwgd2l0aG91dFJlZHVjdGlvbiB9OiBJbWFnZVNpemUsXG4gIG9yaWdpbmFsOiBQcm9iZWRJbWFnZVNpemUsXG4pID0+IHtcbiAgaWYgKGZpdCA9PT0gJ2NvbnRhaW4nIHx8IGZpdCA9PT0gJ2luc2lkZScpIHJldHVybiBmYWxzZVxuICBpZiAoIWlzTnVtYmVyKGhlaWdodCkgJiYgIWlzTnVtYmVyKHdpZHRoKSkgcmV0dXJuIGZhbHNlXG5cbiAgY29uc3QgdGFyZ2V0QXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodFxuICBjb25zdCBvcmlnaW5hbEFzcGVjdFJhdGlvID0gb3JpZ2luYWwud2lkdGggLyBvcmlnaW5hbC5oZWlnaHRcbiAgaWYgKG9yaWdpbmFsQXNwZWN0UmF0aW8gPT09IHRhcmdldEFzcGVjdFJhdGlvKSByZXR1cm4gZmFsc2VcblxuICBjb25zdCBza2lwRW5sYXJnZW1lbnQgPSB3aXRob3V0RW5sYXJnZW1lbnQgJiYgKG9yaWdpbmFsLmhlaWdodCA8IGhlaWdodCB8fCBvcmlnaW5hbC53aWR0aCA8IHdpZHRoKVxuICBjb25zdCBza2lwUmVkdWN0aW9uID0gd2l0aG91dFJlZHVjdGlvbiAmJiAob3JpZ2luYWwuaGVpZ2h0ID4gaGVpZ2h0IHx8IG9yaWdpbmFsLndpZHRoID4gd2lkdGgpXG4gIGlmIChza2lwRW5sYXJnZW1lbnQgfHwgc2tpcFJlZHVjdGlvbikgcmV0dXJuIGZhbHNlXG5cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBTYW5pdGl6ZSB0aGUgcmVzaXplIGNvbmZpZy4gSWYgdGhlIHJlc2l6ZSBjb25maWcgaGFzIHRoZSBgd2l0aG91dFJlZHVjdGlvbmBcbiAqIHByb3BlcnR5IHNldCB0byB0cnVlLCB0aGUgYGZpdGAgYW5kIGBwb3NpdGlvbmAgcHJvcGVydGllcyB3aWxsIGJlIHNldCB0byBgY29udGFpbmBcbiAqIGFuZCBgdG9wIGxlZnRgIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBAcGFyYW0gcmVzaXplQ29uZmlnIC0gdGhlIHJlc2l6ZSBjb25maWdcbiAqIEByZXR1cm5zIGEgc2FuaXRpemVkIHJlc2l6ZSBjb25maWdcbiAqL1xuY29uc3Qgc2FuaXRpemVSZXNpemVDb25maWcgPSAocmVzaXplQ29uZmlnOiBJbWFnZVNpemUpOiBJbWFnZVNpemUgPT4ge1xuICBpZiAocmVzaXplQ29uZmlnLndpdGhvdXRSZWR1Y3Rpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzaXplQ29uZmlnLFxuICAgICAgLy8gV2h5IGZpdCBgY29udGFpbmAgc2hvdWxkIGFsc28gYmUgc2V0IHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9sb3ZlbGwvc2hhcnAvaXNzdWVzLzM1OTVcbiAgICAgIGZpdDogcmVzaXplQ29uZmlnPy5maXQgfHwgJ2NvbnRhaW4nLFxuICAgICAgcG9zaXRpb246IHJlc2l6ZUNvbmZpZz8ucG9zaXRpb24gfHwgJ2xlZnQgdG9wJyxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc2l6ZUNvbmZpZ1xufVxuXG4vKipcbiAqIEZvciB0aGUgcHJvdmlkZWQgaW1hZ2Ugc2l6ZXMsIGhhbmRsZSB0aGUgcmVzaXppbmcgYW5kIHRoZSB0cmFuc2Zvcm1zXG4gKiAoZm9ybWF0LCB0cmltLCBldGMuKSBvZiBlYWNoIHJlcXVlc3RlZCBpbWFnZSBzaXplIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBvYmplY3QuXG4gKiBUaGlzIG9ubHkgaGFuZGxlcyB0aGUgaW1hZ2Ugc2l6ZXMuIFRoZSB0cmFuc2Zvcm1zIG9mIHRoZSBvcmlnaW5hbCBpbWFnZVxuICogYXJlIGhhbmRsZWQgaW4ge0BsaW5rIC4vZ2VuZXJhdGVGaWxlRGF0YS50c30uXG4gKlxuICogVGhlIGltYWdlIHdpbGwgYmUgcmVzaXplZCBhY2NvcmRpbmcgdG8gdGhlIHByb3ZpZGVkXG4gKiByZXNpemUgY29uZmlnLiBJZiBubyBpbWFnZSBzaXplcyBhcmUgcmVxdWVzdGVkLCB0aGUgcmVzb2x2ZWQgZGF0YSB3aWxsIGJlIGVtcHR5LlxuICogRm9yIGV2ZXJ5IGltYWdlIHRoYXQgZG9zIG5vdCBuZWVkIHRvIGJlIHJlc2l6ZWQsIGFuIHJlc3VsdCBvYmplY3Qgd2l0aCBgbnVsbGBcbiAqIHBhcmFtZXRlcnMgd2lsbCBiZSByZXR1cm5lZC5cbiAqXG4gKiBAcGFyYW0gcmVzaXplQ29uZmlnIC0gdGhlIHJlc2l6ZSBjb25maWdcbiAqIEByZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIHJlc2l6ZSBvcGVyYXRpb24ocylcbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcmVzaXplQW5kVHJhbnNmb3JtSW1hZ2VTaXplcyh7XG4gIGNvbmZpZyxcbiAgZGltZW5zaW9ucyxcbiAgZmlsZSxcbiAgbWltZVR5cGUsXG4gIHJlcSxcbiAgc2F2ZWRGaWxlbmFtZSxcbiAgc3RhdGljUGF0aCxcbn06IFJlc2l6ZUFyZ3MpOiBQcm9taXNlPEltYWdlU2l6ZXNSZXN1bHQ+IHtcbiAgY29uc3QgeyBpbWFnZVNpemVzIH0gPSBjb25maWcudXBsb2FkXG4gIC8vIE5vdGluZyB0byByZXNpemUgaGVyZSBzbyByZXR1cm4gYXMgZWFybHkgYXMgcG9zc2libGVcbiAgaWYgKCFpbWFnZVNpemVzKSByZXR1cm4geyBzaXplRGF0YToge30sIHNpemVzVG9TYXZlOiBbXSB9XG5cbiAgY29uc3Qgc2hhcnBCYXNlID0gc2hhcnAoZmlsZS50ZW1wRmlsZVBhdGggfHwgZmlsZS5kYXRhKS5yb3RhdGUoKSAvLyBwYXNzIHJvdGF0ZSgpIHRvIGF1dG8tcm90YXRlIGJhc2VkIG9uIEVYSUYgZGF0YS4gaHR0cHM6Ly9naXRodWIuY29tL3BheWxvYWRjbXMvcGF5bG9hZC9wdWxsLzMwODFcblxuICBjb25zdCByZXN1bHRzOiBJbWFnZVNpemVzUmVzdWx0W10gPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICBpbWFnZVNpemVzLm1hcChhc3luYyAoaW1hZ2VSZXNpemVDb25maWcpOiBQcm9taXNlPEltYWdlU2l6ZXNSZXN1bHQ+ID0+IHtcbiAgICAgIGltYWdlUmVzaXplQ29uZmlnID0gc2FuaXRpemVSZXNpemVDb25maWcoaW1hZ2VSZXNpemVDb25maWcpXG5cbiAgICAgIC8vIFRoaXMgY2hlY2tzIGlmIGEgcmVzaXplIHNob3VsZCBoYXBwZW4uIElmIG5vdCwgdGhlIHJlc2l6ZWQgaW1hZ2Ugd2lsbCBiZVxuICAgICAgLy8gc2tpcHBlZCBDT01QTEVURUxZIGFuZCB0aHVzIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHRpbmcgaW1hZ2VzLlxuICAgICAgLy8gQWxsIGZ1cnRoZXIgZm9ybWF0L3RyaW0gb3B0aW9ucyB3aWxsIHRodXMgYmUgc2tpcHBlZCBhcyB3ZWxsLlxuICAgICAgaWYgKHByZXZlbnRSZXNpemUoaW1hZ2VSZXNpemVDb25maWcsIGRpbWVuc2lvbnMpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVSZXN1bHQoaW1hZ2VSZXNpemVDb25maWcubmFtZSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW1hZ2VUb1Jlc2l6ZSA9IHNoYXJwQmFzZS5jbG9uZSgpXG4gICAgICBsZXQgcmVzaXplZCA9IGltYWdlVG9SZXNpemUucmVzaXplKGltYWdlUmVzaXplQ29uZmlnKVxuXG4gICAgICBpZiAoXG4gICAgICAgIHJlcS5xdWVyeT8udXBsb2FkRWRpdHM/LmZvY2FsUG9pbnQgJiZcbiAgICAgICAgYXBwbHlQYXlsb2FkQWRqdXN0bWVudHMoaW1hZ2VSZXNpemVDb25maWcsIGRpbWVuc2lvbnMpXG4gICAgICApIHtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQ6IHJlc2l6ZUhlaWdodCwgd2lkdGg6IHJlc2l6ZVdpZHRoIH0gPSBpbWFnZVJlc2l6ZUNvbmZpZ1xuICAgICAgICBjb25zdCByZXNpemVBc3BlY3RSYXRpbyA9IHJlc2l6ZVdpZHRoIC8gcmVzaXplSGVpZ2h0XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQXNwZWN0UmF0aW8gPSBkaW1lbnNpb25zLndpZHRoIC8gZGltZW5zaW9ucy5oZWlnaHRcbiAgICAgICAgY29uc3QgcHJpb3JpdGl6ZUhlaWdodCA9IHJlc2l6ZUFzcGVjdFJhdGlvIDwgb3JpZ2luYWxBc3BlY3RSYXRpb1xuXG4gICAgICAgIC8vIFNjYWxlIHRoZSBpbWFnZSB1cCBvciBkb3duIHRvIGZpdCB0aGUgcmVzaXplIGRpbWVuc2lvbnNcbiAgICAgICAgY29uc3Qgc2NhbGVkSW1hZ2UgPSBpbWFnZVRvUmVzaXplLnJlc2l6ZSh7XG4gICAgICAgICAgaGVpZ2h0OiBwcmlvcml0aXplSGVpZ2h0ID8gcmVzaXplSGVpZ2h0IDogbnVsbCxcbiAgICAgICAgICB3aWR0aDogcHJpb3JpdGl6ZUhlaWdodCA/IG51bGwgOiByZXNpemVXaWR0aCxcbiAgICAgICAgfSlcbiAgICAgICAgY29uc3QgeyBpbmZvOiBzY2FsZWRJbWFnZUluZm8gfSA9IGF3YWl0IHNjYWxlZEltYWdlLnRvQnVmZmVyKHsgcmVzb2x2ZVdpdGhPYmplY3Q6IHRydWUgfSlcblxuICAgICAgICAvLyBGb2NhbCBwb2ludCBhZGp1c3RtZW50c1xuICAgICAgICBjb25zdCBmb2NhbFBvaW50ID0ge1xuICAgICAgICAgIHg6IGlzTnVtYmVyKHJlcS5xdWVyeS51cGxvYWRFZGl0cy5mb2NhbFBvaW50Py54KVxuICAgICAgICAgICAgPyByZXEucXVlcnkudXBsb2FkRWRpdHMuZm9jYWxQb2ludC54XG4gICAgICAgICAgICA6IDUwLFxuICAgICAgICAgIHk6IGlzTnVtYmVyKHJlcS5xdWVyeS51cGxvYWRFZGl0cy5mb2NhbFBvaW50Py55KVxuICAgICAgICAgICAgPyByZXEucXVlcnkudXBsb2FkRWRpdHMuZm9jYWxQb2ludC55XG4gICAgICAgICAgICA6IDUwLFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2FmZVJlc2l6ZVdpZHRoID0gcmVzaXplV2lkdGggPz8gc2NhbGVkSW1hZ2VJbmZvLndpZHRoXG4gICAgICAgIGNvbnN0IG1heE9mZnNldFggPSBzY2FsZWRJbWFnZUluZm8ud2lkdGggLSBzYWZlUmVzaXplV2lkdGhcbiAgICAgICAgY29uc3QgbGVmdEZvY2FsRWRnZSA9IE1hdGgucm91bmQoXG4gICAgICAgICAgc2NhbGVkSW1hZ2VJbmZvLndpZHRoICogKGZvY2FsUG9pbnQueCAvIDEwMCkgLSBzYWZlUmVzaXplV2lkdGggLyAyLFxuICAgICAgICApXG4gICAgICAgIGNvbnN0IHNhZmVPZmZzZXRYID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgbGVmdEZvY2FsRWRnZSksIG1heE9mZnNldFgpXG5cbiAgICAgICAgY29uc3Qgc2FmZVJlc2l6ZUhlaWdodCA9IHJlc2l6ZUhlaWdodCA/PyBzY2FsZWRJbWFnZUluZm8uaGVpZ2h0XG4gICAgICAgIGNvbnN0IG1heE9mZnNldFkgPSBzY2FsZWRJbWFnZUluZm8uaGVpZ2h0IC0gc2FmZVJlc2l6ZUhlaWdodFxuICAgICAgICBjb25zdCB0b3BGb2NhbEVkZ2UgPSBNYXRoLnJvdW5kKFxuICAgICAgICAgIHNjYWxlZEltYWdlSW5mby5oZWlnaHQgKiAoZm9jYWxQb2ludC55IC8gMTAwKSAtIHNhZmVSZXNpemVIZWlnaHQgLyAyLFxuICAgICAgICApXG4gICAgICAgIGNvbnN0IHNhZmVPZmZzZXRZID0gTWF0aC5taW4oTWF0aC5tYXgoMCwgdG9wRm9jYWxFZGdlKSwgbWF4T2Zmc2V0WSlcblxuICAgICAgICAvLyBleHRyYWN0IHRoZSBmb2NhbCBhcmVhIGZyb20gdGhlIHNjYWxlZCBpbWFnZVxuICAgICAgICByZXNpemVkID0gc2NhbGVkSW1hZ2UuZXh0cmFjdCh7XG4gICAgICAgICAgaGVpZ2h0OiBzYWZlUmVzaXplSGVpZ2h0LFxuICAgICAgICAgIGxlZnQ6IHNhZmVPZmZzZXRYLFxuICAgICAgICAgIHRvcDogc2FmZU9mZnNldFksXG4gICAgICAgICAgd2lkdGg6IHNhZmVSZXNpemVXaWR0aCxcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKGltYWdlUmVzaXplQ29uZmlnLmZvcm1hdE9wdGlvbnMpIHtcbiAgICAgICAgcmVzaXplZCA9IHJlc2l6ZWQudG9Gb3JtYXQoXG4gICAgICAgICAgaW1hZ2VSZXNpemVDb25maWcuZm9ybWF0T3B0aW9ucy5mb3JtYXQsXG4gICAgICAgICAgaW1hZ2VSZXNpemVDb25maWcuZm9ybWF0T3B0aW9ucy5vcHRpb25zLFxuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIGlmIChpbWFnZVJlc2l6ZUNvbmZpZy50cmltT3B0aW9ucykge1xuICAgICAgICByZXNpemVkID0gcmVzaXplZC50cmltKGltYWdlUmVzaXplQ29uZmlnLnRyaW1PcHRpb25zKVxuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGRhdGE6IGJ1ZmZlckRhdGEsIGluZm86IGJ1ZmZlckluZm8gfSA9IGF3YWl0IHJlc2l6ZWQudG9CdWZmZXIoe1xuICAgICAgICByZXNvbHZlV2l0aE9iamVjdDogdHJ1ZSxcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHNhbml0aXplZEltYWdlID0gZ2V0U2FuaXRpemVkSW1hZ2VEYXRhKHNhdmVkRmlsZW5hbWUpXG5cbiAgICAgIGlmIChyZXEucGF5bG9hZFVwbG9hZFNpemVzKSB7XG4gICAgICAgIHJlcS5wYXlsb2FkVXBsb2FkU2l6ZXNbaW1hZ2VSZXNpemVDb25maWcubmFtZV0gPSBidWZmZXJEYXRhXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1pbWVJbmZvID0gYXdhaXQgZnJvbUJ1ZmZlcihidWZmZXJEYXRhKVxuXG4gICAgICBjb25zdCBpbWFnZU5hbWVXaXRoRGltZW5zaW9ucyA9IGNyZWF0ZUltYWdlTmFtZShcbiAgICAgICAgc2FuaXRpemVkSW1hZ2UubmFtZSxcbiAgICAgICAgYnVmZmVySW5mbyxcbiAgICAgICAgbWltZUluZm8/LmV4dCB8fCBzYW5pdGl6ZWRJbWFnZS5leHQsXG4gICAgICApXG5cbiAgICAgIGNvbnN0IGltYWdlUGF0aCA9IGAke3N0YXRpY1BhdGh9LyR7aW1hZ2VOYW1lV2l0aERpbWVuc2lvbnN9YFxuXG4gICAgICBpZiAoYXdhaXQgZmlsZUV4aXN0cyhpbWFnZVBhdGgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZnMudW5saW5rU3luYyhpbWFnZVBhdGgpXG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8vIElnbm9yZSB1bmxpbmsgZXJyb3JzXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBoZWlnaHQsIHNpemUsIHdpZHRoIH0gPSBidWZmZXJJbmZvXG4gICAgICByZXR1cm4gY3JlYXRlUmVzdWx0KFxuICAgICAgICBpbWFnZVJlc2l6ZUNvbmZpZy5uYW1lLFxuICAgICAgICBpbWFnZU5hbWVXaXRoRGltZW5zaW9ucyxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgc2l6ZSxcbiAgICAgICAgbWltZUluZm8/Lm1pbWUgfHwgbWltZVR5cGUsXG4gICAgICAgIFt7IGJ1ZmZlcjogYnVmZmVyRGF0YSwgcGF0aDogaW1hZ2VQYXRoIH1dLFxuICAgICAgKVxuICAgIH0pLFxuICApXG5cbiAgcmV0dXJuIHJlc3VsdHMucmVkdWNlKFxuICAgIChhY2MsIHJlc3VsdCkgPT4ge1xuICAgICAgT2JqZWN0LmFzc2lnbihhY2Muc2l6ZURhdGEsIHJlc3VsdC5zaXplRGF0YSlcbiAgICAgIGFjYy5zaXplc1RvU2F2ZS5wdXNoKC4uLnJlc3VsdC5zaXplc1RvU2F2ZSlcbiAgICAgIHJldHVybiBhY2NcbiAgICB9LFxuICAgIHsgc2l6ZURhdGE6IHt9LCBzaXplc1RvU2F2ZTogW10gfSxcbiAgKVxufVxuIl0sIm5hbWVzIjpbInJlc2l6ZUFuZFRyYW5zZm9ybUltYWdlU2l6ZXMiLCJnZXRTYW5pdGl6ZWRJbWFnZURhdGEiLCJzb3VyY2VJbWFnZSIsImV4dGVuc2lvbiIsInNwbGl0IiwicG9wIiwibmFtZSIsInNhbml0aXplIiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCJleHQiLCJjcmVhdGVJbWFnZU5hbWUiLCJvdXRwdXRJbWFnZU5hbWUiLCJoZWlnaHQiLCJ3aWR0aCIsImNyZWF0ZVJlc3VsdCIsImZpbGVuYW1lIiwiZmlsZXNpemUiLCJtaW1lVHlwZSIsInNpemVzVG9TYXZlIiwic2l6ZURhdGEiLCJwcmV2ZW50UmVzaXplIiwiZGVzaXJlZEhlaWdodCIsImRlc2lyZWRXaWR0aCIsIndpdGhvdXRFbmxhcmdlbWVudCIsIndpdGhvdXRSZWR1Y3Rpb24iLCJvcmlnaW5hbCIsInVuZGVmaW5lZCIsImlzV2lkdGhPckhlaWdodE5vdERlZmluZWQiLCJoYXNJbnN1ZmZpY2llbnRXaWR0aCIsImhhc0luc3VmZmljaWVudEhlaWdodCIsImFwcGx5UGF5bG9hZEFkanVzdG1lbnRzIiwiZml0IiwiaXNOdW1iZXIiLCJ0YXJnZXRBc3BlY3RSYXRpbyIsIm9yaWdpbmFsQXNwZWN0UmF0aW8iLCJza2lwRW5sYXJnZW1lbnQiLCJza2lwUmVkdWN0aW9uIiwic2FuaXRpemVSZXNpemVDb25maWciLCJyZXNpemVDb25maWciLCJwb3NpdGlvbiIsImNvbmZpZyIsImRpbWVuc2lvbnMiLCJmaWxlIiwicmVxIiwic2F2ZWRGaWxlbmFtZSIsInN0YXRpY1BhdGgiLCJpbWFnZVNpemVzIiwidXBsb2FkIiwic2hhcnBCYXNlIiwic2hhcnAiLCJ0ZW1wRmlsZVBhdGgiLCJkYXRhIiwicm90YXRlIiwicmVzdWx0cyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJpbWFnZVJlc2l6ZUNvbmZpZyIsImltYWdlVG9SZXNpemUiLCJjbG9uZSIsInJlc2l6ZWQiLCJyZXNpemUiLCJxdWVyeSIsInVwbG9hZEVkaXRzIiwiZm9jYWxQb2ludCIsInJlc2l6ZUhlaWdodCIsInJlc2l6ZVdpZHRoIiwicmVzaXplQXNwZWN0UmF0aW8iLCJwcmlvcml0aXplSGVpZ2h0Iiwic2NhbGVkSW1hZ2UiLCJpbmZvIiwic2NhbGVkSW1hZ2VJbmZvIiwidG9CdWZmZXIiLCJyZXNvbHZlV2l0aE9iamVjdCIsIngiLCJ5Iiwic2FmZVJlc2l6ZVdpZHRoIiwibWF4T2Zmc2V0WCIsImxlZnRGb2NhbEVkZ2UiLCJNYXRoIiwicm91bmQiLCJzYWZlT2Zmc2V0WCIsIm1pbiIsIm1heCIsInNhZmVSZXNpemVIZWlnaHQiLCJtYXhPZmZzZXRZIiwidG9wRm9jYWxFZGdlIiwic2FmZU9mZnNldFkiLCJleHRyYWN0IiwibGVmdCIsInRvcCIsImZvcm1hdE9wdGlvbnMiLCJ0b0Zvcm1hdCIsImZvcm1hdCIsIm9wdGlvbnMiLCJ0cmltT3B0aW9ucyIsInRyaW0iLCJidWZmZXJEYXRhIiwiYnVmZmVySW5mbyIsInNhbml0aXplZEltYWdlIiwicGF5bG9hZFVwbG9hZFNpemVzIiwibWltZUluZm8iLCJmcm9tQnVmZmVyIiwiaW1hZ2VOYW1lV2l0aERpbWVuc2lvbnMiLCJpbWFnZVBhdGgiLCJmaWxlRXhpc3RzIiwiZnMiLCJ1bmxpbmtTeW5jIiwic2l6ZSIsIm1pbWUiLCJidWZmZXIiLCJwYXRoIiwicmVkdWNlIiwiYWNjIiwicmVzdWx0IiwiT2JqZWN0IiwiYXNzaWduIiwicHVzaCJdLCJtYXBwaW5ncyI6Ijs7OzsrQkFtTUE7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNEOzs7ZUFBOEJBOzs7MEJBOU1IOzJEQUNaO3lFQUNNOzhEQUNIOzBCQU9PO21FQUNGOzs7Ozs7QUEyQnZCOzs7OztDQUtDLEdBQ0QsTUFBTUMsd0JBQXdCLENBQUNDO0lBQzdCLE1BQU1DLFlBQVlELFlBQVlFLEtBQUssQ0FBQyxLQUFLQyxHQUFHO0lBQzVDLE1BQU1DLE9BQU9DLElBQUFBLHlCQUFRLEVBQUNMLFlBQVlNLFNBQVMsQ0FBQyxHQUFHTixZQUFZTyxXQUFXLENBQUMsU0FBU1A7SUFDaEYsT0FBTztRQUFFSTtRQUFNSSxLQUFLUDtJQUFVO0FBQ2hDO0FBRUE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ0QsTUFBTVEsa0JBQWtCLENBQ3RCQyxpQkFDQSxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBYyxFQUM3QlgsWUFDRyxDQUFDLEVBQUVTLGdCQUFnQixDQUFDLEVBQUVFLE1BQU0sQ0FBQyxFQUFFRCxPQUFPLENBQUMsRUFBRVYsVUFBVSxDQUFDO0FBRXpEOzs7Ozs7Ozs7Ozs7O0NBYUMsR0FDRCxNQUFNWSxl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