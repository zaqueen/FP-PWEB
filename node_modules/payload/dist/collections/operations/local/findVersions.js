"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "default", {
    enumerable: true,
    get: function() {
        return findVersionsLocal;
    }
});
const _errors = require("../../../errors");
const _setRequestContext = require("../../../express/setRequestContext");
const _init = require("../../../translations/init");
const _dataloader = require("../../dataloader");
const _findVersions = /*#__PURE__*/ _interop_require_default(require("../findVersions"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function findVersionsLocal(payload, options) {
    const { collection: collectionSlug, context, depth, fallbackLocale, limit, locale = null, overrideAccess = true, page, req: incomingReq, showHiddenFields, sort, user, where } = options;
    const collection = payload.collections[collectionSlug];
    const defaultLocale = payload?.config?.localization ? payload?.config?.localization?.defaultLocale : null;
    if (!collection) {
        throw new _errors.APIError(`The collection with slug ${String(collectionSlug)} can't be found. Find Versions Operation.`);
    }
    const i18n = (0, _init.i18nInit)(payload.config.i18n);
    const req = {
        fallbackLocale: typeof fallbackLocale !== 'undefined' ? fallbackLocale : defaultLocale,
        i18n,
        locale: locale ?? defaultLocale,
        payload,
        payloadAPI: 'local',
        transactionID: incomingReq?.transactionID,
        user
    };
    (0, _setRequestContext.setRequestContext)(req, context);
    if (!req.t) req.t = req.i18n.t;
    if (!req.payloadDataLoader) req.payloadDataLoader = (0, _dataloader.getDataLoader)(req);
    return (0, _findVersions.default)({
        collection,
        depth,
        limit,
        overrideAccess,
        page,
        req,
        showHiddenFields,
        sort,
        where
    });
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9jb2xsZWN0aW9ucy9vcGVyYXRpb25zL2xvY2FsL2ZpbmRWZXJzaW9ucy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IEdlbmVyYXRlZFR5cGVzIH0gZnJvbSAnLi4vLi4vLi4vJ1xuaW1wb3J0IHR5cGUgeyBQYWdpbmF0ZWREb2NzIH0gZnJvbSAnLi4vLi4vLi4vZGF0YWJhc2UvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFBheWxvYWRSZXF1ZXN0LCBSZXF1ZXN0Q29udGV4dCB9IGZyb20gJy4uLy4uLy4uL2V4cHJlc3MvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IFBheWxvYWQgfSBmcm9tICcuLi8uLi8uLi9wYXlsb2FkJ1xuaW1wb3J0IHR5cGUgeyBEb2N1bWVudCwgV2hlcmUgfSBmcm9tICcuLi8uLi8uLi90eXBlcydcbmltcG9ydCB0eXBlIHsgVHlwZVdpdGhWZXJzaW9uIH0gZnJvbSAnLi4vLi4vLi4vdmVyc2lvbnMvdHlwZXMnXG5cbmltcG9ydCB7IEFQSUVycm9yIH0gZnJvbSAnLi4vLi4vLi4vZXJyb3JzJ1xuaW1wb3J0IHsgc2V0UmVxdWVzdENvbnRleHQgfSBmcm9tICcuLi8uLi8uLi9leHByZXNzL3NldFJlcXVlc3RDb250ZXh0J1xuaW1wb3J0IHsgaTE4bkluaXQgfSBmcm9tICcuLi8uLi8uLi90cmFuc2xhdGlvbnMvaW5pdCdcbmltcG9ydCB7IGdldERhdGFMb2FkZXIgfSBmcm9tICcuLi8uLi9kYXRhbG9hZGVyJ1xuaW1wb3J0IGZpbmRWZXJzaW9ucyBmcm9tICcuLi9maW5kVmVyc2lvbnMnXG5cbmV4cG9ydCB0eXBlIE9wdGlvbnM8VCBleHRlbmRzIGtleW9mIEdlbmVyYXRlZFR5cGVzWydjb2xsZWN0aW9ucyddPiA9IHtcbiAgY29sbGVjdGlvbjogVFxuICAvKipcbiAgICogY29udGV4dCwgd2hpY2ggd2lsbCB0aGVuIGJlIHBhc3NlZCB0byByZXEuY29udGV4dCwgd2hpY2ggY2FuIGJlIHJlYWQgYnkgaG9va3NcbiAgICovXG4gIGNvbnRleHQ/OiBSZXF1ZXN0Q29udGV4dFxuICBkZXB0aD86IG51bWJlclxuICBkcmFmdD86IGJvb2xlYW5cbiAgZmFsbGJhY2tMb2NhbGU/OiBzdHJpbmdcbiAgbGltaXQ/OiBudW1iZXJcbiAgbG9jYWxlPzogc3RyaW5nXG4gIG92ZXJyaWRlQWNjZXNzPzogYm9vbGVhblxuICBwYWdlPzogbnVtYmVyXG4gIHJlcT86IFBheWxvYWRSZXF1ZXN0XG4gIHNob3dIaWRkZW5GaWVsZHM/OiBib29sZWFuXG4gIHNvcnQ/OiBzdHJpbmdcbiAgdXNlcj86IERvY3VtZW50XG4gIHdoZXJlPzogV2hlcmVcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZmluZFZlcnNpb25zTG9jYWw8VCBleHRlbmRzIGtleW9mIEdlbmVyYXRlZFR5cGVzWydjb2xsZWN0aW9ucyddPihcbiAgcGF5bG9hZDogUGF5bG9hZCxcbiAgb3B0aW9uczogT3B0aW9uczxUPixcbik6IFByb21pc2U8UGFnaW5hdGVkRG9jczxUeXBlV2l0aFZlcnNpb248R2VuZXJhdGVkVHlwZXNbJ2NvbGxlY3Rpb25zJ11bVF0+Pj4ge1xuICBjb25zdCB7XG4gICAgY29sbGVjdGlvbjogY29sbGVjdGlvblNsdWcsXG4gICAgY29udGV4dCxcbiAgICBkZXB0aCxcbiAgICBmYWxsYmFja0xvY2FsZSxcbiAgICBsaW1pdCxcbiAgICBsb2NhbGUgPSBudWxsLFxuICAgIG92ZXJyaWRlQWNjZXNzID0gdHJ1ZSxcbiAgICBwYWdlLFxuICAgIHJlcTogaW5jb21pbmdSZXEsXG4gICAgc2hvd0hpZGRlbkZpZWxkcyxcbiAgICBzb3J0LFxuICAgIHVzZXIsXG4gICAgd2hlcmUsXG4gIH0gPSBvcHRpb25zXG5cbiAgY29uc3QgY29sbGVjdGlvbiA9IHBheWxvYWQuY29sbGVjdGlvbnNbY29sbGVjdGlvblNsdWddXG4gIGNvbnN0IGRlZmF1bHRMb2NhbGUgPSBwYXlsb2FkPy5jb25maWc/LmxvY2FsaXphdGlvblxuICAgID8gcGF5bG9hZD8uY29uZmlnPy5sb2NhbGl6YXRpb24/LmRlZmF1bHRMb2NhbGVcbiAgICA6IG51bGxcblxuICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICB0aHJvdyBuZXcgQVBJRXJyb3IoXG4gICAgICBgVGhlIGNvbGxlY3Rpb24gd2l0aCBzbHVnICR7U3RyaW5nKGNvbGxlY3Rpb25TbHVnKX0gY2FuJ3QgYmUgZm91bmQuIEZpbmQgVmVyc2lvbnMgT3BlcmF0aW9uLmAsXG4gICAgKVxuICB9XG5cbiAgY29uc3QgaTE4biA9IGkxOG5Jbml0KHBheWxvYWQuY29uZmlnLmkxOG4pXG4gIGNvbnN0IHJlcSA9IHtcbiAgICBmYWxsYmFja0xvY2FsZTogdHlwZW9mIGZhbGxiYWNrTG9jYWxlICE9PSAndW5kZWZpbmVkJyA/IGZhbGxiYWNrTG9jYWxlIDogZGVmYXVsdExvY2FsZSxcbiAgICBpMThuLFxuICAgIGxvY2FsZTogbG9jYWxlID8/IGRlZmF1bHRMb2NhbGUsXG4gICAgcGF5bG9hZCxcbiAgICBwYXlsb2FkQVBJOiAnbG9jYWwnLFxuICAgIHRyYW5zYWN0aW9uSUQ6IGluY29taW5nUmVxPy50cmFuc2FjdGlvbklELFxuICAgIHVzZXIsXG4gIH0gYXMgUGF5bG9hZFJlcXVlc3RcbiAgc2V0UmVxdWVzdENvbnRleHQocmVxLCBjb250ZXh0KVxuXG4gIGlmICghcmVxLnQpIHJlcS50ID0gcmVxLmkxOG4udFxuICBpZiAoIXJlcS5wYXlsb2FkRGF0YUxvYWRlcikgcmVxLnBheWxvYWREYXRhTG9hZGVyID0gZ2V0RGF0YUxvYWRlcihyZXEpXG5cbiAgcmV0dXJuIGZpbmRWZXJzaW9ucyh7XG4gICAgY29sbGVjdGlvbixcbiAgICBkZXB0aCxcbiAgICBsaW1pdCxcbiAgICBvdmVycmlkZUFjY2VzcyxcbiAgICBwYWdlLFxuICAgIHJlcSxcbiAgICBzaG93SGlkZGVuRmllbGRzLFxuICAgIHNvcnQsXG4gICAgd2hlcmUsXG4gIH0pXG59XG4iXSwibmFtZXMiOlsiZmluZFZlcnNpb25zTG9jYWwiLCJwYXlsb2FkIiwib3B0aW9ucyIsImNvbGxlY3Rpb24iLCJjb2xsZWN0aW9uU2x1ZyIsImNvbnRleHQiLCJkZXB0aCIsImZhbGxiYWNrTG9jYWxlIiwibGltaXQiLCJsb2NhbGUiLCJvdmVycmlkZUFjY2VzcyIsInBhZ2UiLCJyZXEiLCJpbmNvbWluZ1JlcSIsInNob3dIaWRkZW5GaWVsZHMiLCJzb3J0IiwidXNlciIsIndoZXJlIiwiY29sbGVjdGlvbnMiLCJkZWZhdWx0TG9jYWxlIiwiY29uZmlnIiwibG9jYWxpemF0aW9uIiwiQVBJRXJyb3IiLCJTdHJpbmciLCJpMThuIiwiaTE4bkluaXQiLCJwYXlsb2FkQVBJIiwidHJhbnNhY3Rpb25JRCIsInNldFJlcXVlc3RDb250ZXh0IiwidCIsInBheWxvYWREYXRhTG9hZGVyIiwiZ2V0RGF0YUxvYWRlciIsImZpbmRWZXJzaW9ucyJdLCJtYXBwaW5ncyI6Ijs7OzsrQkFpQ0E7OztlQUE4QkE7Ozt3QkExQkw7bUNBQ1M7c0JBQ1Q7NEJBQ0s7cUVBQ0w7Ozs7OztBQXNCVixlQUFlQSxrQkFDNUJDLE9BQWdCLEVBQ2hCQyxPQUFtQjtJQUVuQixNQUFNLEVBQ0pDLFlBQVlDLGNBQWMsRUFDMUJDLE9BQU8sRUFDUEMsS0FBSyxFQUNMQyxjQUFjLEVBQ2RDLEtBQUssRUFDTEMsU0FBUyxJQUFJLEVBQ2JDLGlCQUFpQixJQUFJLEVBQ3JCQyxJQUFJLEVBQ0pDLEtBQUtDLFdBQVcsRUFDaEJDLGdCQUFnQixFQUNoQkMsSUFBSSxFQUNKQyxJQUFJLEVBQ0pDLEtBQUssRUFDTixHQUFHZjtJQUVKLE1BQU1DLGFBQWFGLFFBQVFpQixXQUFXLENBQUNkLGVBQWU7SUFDdEQsTUFBTWUsZ0JBQWdCbEIsU0FBU21CLFFBQVFDLGVBQ25DcEIsU0FBU21CLFFBQVFDLGNBQWNGLGdCQUMvQjtJQUVKLElBQUksQ0FBQ2hCLFlBQVk7UUFDZixNQUFNLElBQUltQixnQkFBUSxDQUNoQixDQUFDLHlCQUF5QixFQUFFQyxPQUFPbkIsZ0JBQWdCLHlDQUF5QyxDQUFDO0lBRWpHO0lBRUEsTUFBTW9CLE9BQU9DLElBQUFBLGNBQVEsRUFBQ3hCLFFBQVFtQixNQUFNLENBQUNJLElBQUk7SUFDekMsTUFBTVosTUFBTTtRQUNWTCxnQkFBZ0IsT0FBT0EsbUJBQW1CLGNBQWNBLGlCQUFpQlk7UUFDekVLO1FBQ0FmLFFBQVFBLFVBQVVVO1FBQ2xCbEI7UUFDQXlCLFlBQVk7UUFDWkMsZUFBZWQsYUFBYWM7UUFDNUJYO0lBQ0Y7SUFDQVksSUFBQUEsb0NBQWlCLEVBQUNoQixLQUFLUDtJQUV2QixJQUFJLENBQUNPLElBQUlpQixDQUFDLEVBQUVqQixJQUFJaUIsQ0FBQyxHQUFHakIsSUFBSVksSUFBSSxDQUFDSyxDQUFDO0lBQzlCLElBQUksQ0FBQ2pCLElBQUlrQixpQkFBaUIsRUFBRWxCLElBQUlrQixpQkFBaUIsR0FBR0MsSUFBQUEseUJBQWEsRUFBQ25CO0lBRWxFLE9BQU9vQixJQUFBQSxxQkFBWSxFQUFDO1FBQ2xCN0I7UUFDQUc7UUFDQUU7UUFDQUU7UUFDQUM7UUFDQUM7UUFDQUU7UUFDQUM7UUFDQUU7SUFDRjtBQUNGIn0=