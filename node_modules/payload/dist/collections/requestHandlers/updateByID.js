"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    deprecatedUpdate: function() {
        return deprecatedUpdate;
    },
    default: function() {
        return updateByIDHandler;
    }
});
const _httpstatus = /*#__PURE__*/ _interop_require_default(require("http-status"));
const _formatSuccess = /*#__PURE__*/ _interop_require_default(require("../../express/responses/formatSuccess"));
const _updateByID = /*#__PURE__*/ _interop_require_default(require("../operations/updateByID"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
async function deprecatedUpdate(req, res, next) {
    req.payload.logger.warn('The PUT method is deprecated and will no longer be supported in a future release. Please use the PATCH method for update requests.');
    return updateByIDHandler(req, res, next);
}
async function updateByIDHandler(req, res, next) {
    try {
        const draft = req.query.draft === 'true';
        const autosave = req.query.autosave === 'true';
        const doc = await (0, _updateByID.default)({
            id: req.params.id,
            autosave,
            collection: req.collection,
            data: req.body,
            depth: parseInt(String(req.query.depth), 10),
            draft,
            req
        });
        let message = req.t('general:updatedSuccessfully');
        if (draft) message = req.t('version:draftSavedSuccessfully');
        if (autosave) message = req.t('version:autosavedSuccessfully');
        res.status(_httpstatus.default.OK).json({
            ...(0, _formatSuccess.default)(message, 'message'),
            doc
        });
    } catch (error) {
        next(error);
    }
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9jb2xsZWN0aW9ucy9yZXF1ZXN0SGFuZGxlcnMvdXBkYXRlQnlJRC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE5leHRGdW5jdGlvbiwgUmVzcG9uc2UgfSBmcm9tICdleHByZXNzJ1xuXG5pbXBvcnQgaHR0cFN0YXR1cyBmcm9tICdodHRwLXN0YXR1cydcblxuaW1wb3J0IHR5cGUgeyBQYXlsb2FkUmVxdWVzdCB9IGZyb20gJy4uLy4uL2V4cHJlc3MvdHlwZXMnXG5cbmltcG9ydCBmb3JtYXRTdWNjZXNzUmVzcG9uc2UgZnJvbSAnLi4vLi4vZXhwcmVzcy9yZXNwb25zZXMvZm9ybWF0U3VjY2VzcydcbmltcG9ydCB1cGRhdGVCeUlEIGZyb20gJy4uL29wZXJhdGlvbnMvdXBkYXRlQnlJRCdcblxuZXhwb3J0IHR5cGUgVXBkYXRlUmVzdWx0ID0ge1xuICBkb2M6IERvY3VtZW50XG4gIG1lc3NhZ2U6IHN0cmluZ1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVwcmVjYXRlZFVwZGF0ZShcbiAgcmVxOiBQYXlsb2FkUmVxdWVzdCxcbiAgcmVzOiBSZXNwb25zZSxcbiAgbmV4dDogTmV4dEZ1bmN0aW9uLFxuKTogUHJvbWlzZTxSZXNwb25zZTxVcGRhdGVSZXN1bHQ+IHwgdm9pZD4ge1xuICByZXEucGF5bG9hZC5sb2dnZXIud2FybihcbiAgICAnVGhlIFBVVCBtZXRob2QgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBubyBsb25nZXIgYmUgc3VwcG9ydGVkIGluIGEgZnV0dXJlIHJlbGVhc2UuIFBsZWFzZSB1c2UgdGhlIFBBVENIIG1ldGhvZCBmb3IgdXBkYXRlIHJlcXVlc3RzLicsXG4gIClcblxuICByZXR1cm4gdXBkYXRlQnlJREhhbmRsZXIocmVxLCByZXMsIG5leHQpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUJ5SURIYW5kbGVyKFxuICByZXE6IFBheWxvYWRSZXF1ZXN0LFxuICByZXM6IFJlc3BvbnNlLFxuICBuZXh0OiBOZXh0RnVuY3Rpb24sXG4pOiBQcm9taXNlPFJlc3BvbnNlPFVwZGF0ZVJlc3VsdD4gfCB2b2lkPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZHJhZnQgPSByZXEucXVlcnkuZHJhZnQgPT09ICd0cnVlJ1xuICAgIGNvbnN0IGF1dG9zYXZlID0gcmVxLnF1ZXJ5LmF1dG9zYXZlID09PSAndHJ1ZSdcblxuICAgIGNvbnN0IGRvYyA9IGF3YWl0IHVwZGF0ZUJ5SUQoe1xuICAgICAgaWQ6IHJlcS5wYXJhbXMuaWQsXG4gICAgICBhdXRvc2F2ZSxcbiAgICAgIGNvbGxlY3Rpb246IHJlcS5jb2xsZWN0aW9uLFxuICAgICAgZGF0YTogcmVxLmJvZHksXG4gICAgICBkZXB0aDogcGFyc2VJbnQoU3RyaW5nKHJlcS5xdWVyeS5kZXB0aCksIDEwKSxcbiAgICAgIGRyYWZ0LFxuICAgICAgcmVxLFxuICAgIH0pXG5cbiAgICBsZXQgbWVzc2FnZSA9IHJlcS50KCdnZW5lcmFsOnVwZGF0ZWRTdWNjZXNzZnVsbHknKVxuXG4gICAgaWYgKGRyYWZ0KSBtZXNzYWdlID0gcmVxLnQoJ3ZlcnNpb246ZHJhZnRTYXZlZFN1Y2Nlc3NmdWxseScpXG4gICAgaWYgKGF1dG9zYXZlKSBtZXNzYWdlID0gcmVxLnQoJ3ZlcnNpb246YXV0b3NhdmVkU3VjY2Vzc2Z1bGx5JylcblxuICAgIHJlcy5zdGF0dXMoaHR0cFN0YXR1cy5PSykuanNvbih7XG4gICAgICAuLi5mb3JtYXRTdWNjZXNzUmVzcG9uc2UobWVzc2FnZSwgJ21lc3NhZ2UnKSxcbiAgICAgIGRvYyxcbiAgICB9KVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIG5leHQoZXJyb3IpXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJkZXByZWNhdGVkVXBkYXRlIiwidXBkYXRlQnlJREhhbmRsZXIiLCJyZXEiLCJyZXMiLCJuZXh0IiwicGF5bG9hZCIsImxvZ2dlciIsIndhcm4iLCJkcmFmdCIsInF1ZXJ5IiwiYXV0b3NhdmUiLCJkb2MiLCJ1cGRhdGVCeUlEIiwiaWQiLCJwYXJhbXMiLCJjb2xsZWN0aW9uIiwiZGF0YSIsImJvZHkiLCJkZXB0aCIsInBhcnNlSW50IiwiU3RyaW5nIiwibWVzc2FnZSIsInQiLCJzdGF0dXMiLCJodHRwU3RhdHVzIiwiT0siLCJqc29uIiwiZm9ybWF0U3VjY2Vzc1Jlc3BvbnNlIiwiZXJyb3IiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0lBY3NCQSxnQkFBZ0I7ZUFBaEJBOztJQVl0QixPQStCQztlQS9CNkJDOzs7bUVBeEJQO3NFQUlXO21FQUNYOzs7Ozs7QUFPaEIsZUFBZUQsaUJBQ3BCRSxHQUFtQixFQUNuQkMsR0FBYSxFQUNiQyxJQUFrQjtJQUVsQkYsSUFBSUcsT0FBTyxDQUFDQyxNQUFNLENBQUNDLElBQUksQ0FDckI7SUFHRixPQUFPTixrQkFBa0JDLEtBQUtDLEtBQUtDO0FBQ3JDO0FBRWUsZUFBZUgsa0JBQzVCQyxHQUFtQixFQUNuQkMsR0FBYSxFQUNiQyxJQUFrQjtJQUVsQixJQUFJO1FBQ0YsTUFBTUksUUFBUU4sSUFBSU8sS0FBSyxDQUFDRCxLQUFLLEtBQUs7UUFDbEMsTUFBTUUsV0FBV1IsSUFBSU8sS0FBSyxDQUFDQyxRQUFRLEtBQUs7UUFFeEMsTUFBTUMsTUFBTSxNQUFNQyxJQUFBQSxtQkFBVSxFQUFDO1lBQzNCQyxJQUFJWCxJQUFJWSxNQUFNLENBQUNELEVBQUU7WUFDakJIO1lBQ0FLLFlBQVliLElBQUlhLFVBQVU7WUFDMUJDLE1BQU1kLElBQUllLElBQUk7WUFDZEMsT0FBT0MsU0FBU0MsT0FBT2xCLElBQUlPLEtBQUssQ0FBQ1MsS0FBSyxHQUFHO1lBQ3pDVjtZQUNBTjtRQUNGO1FBRUEsSUFBSW1CLFVBQVVuQixJQUFJb0IsQ0FBQyxDQUFDO1FBRXBCLElBQUlkLE9BQU9hLFVBQVVuQixJQUFJb0IsQ0FBQyxDQUFDO1FBQzNCLElBQUlaLFVBQVVXLFVBQVVuQixJQUFJb0IsQ0FBQyxDQUFDO1FBRTlCbkIsSUFBSW9CLE1BQU0sQ0FBQ0MsbUJBQVUsQ0FBQ0MsRUFBRSxFQUFFQyxJQUFJLENBQUM7WUFDN0IsR0FBR0MsSUFBQUEsc0JBQXFCLEVBQUNOLFNBQVMsVUFBVTtZQUM1Q1Y7UUFDRjtJQUNGLEVBQUUsT0FBT2lCLE9BQU87UUFDZHhCLEtBQUt3QjtJQUNQO0FBQ0YifQ==